<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="Math Libraries Help" />
<meta name="DC.relation" scheme="URI" content="GUID-546D2D8B-EC03-4BF5-B23F-D618F41955FB.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="math-libraries-help" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>Math Libraries Help</title>
<meta name="Microsoft.Help.Id" content="GUID-9A1A39D4-F5A9-4AB5-89CC-20C51E2EECD5-math-libraries-help" />
<meta name="Microsoft.Help.TocParent" content="GUID-9A1A39D4-F5A9-4AB5-89CC-20C51E2EECD5" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB® Harmony Audio Help Reference A 05/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-95E9D1C6-B2E2-4086-9E56-1D468B7F83ED"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="math-libraries-help">
<h1 class="title topictitle1" id="ariaid-title1">Math Libraries Help</h1><div class="body"></div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-546D2D8B-EC03-4BF5-B23F-D618F41955FB.html">MPLAB® Harmony 3 Audio, Support Package</a></div>
</div>
</div><div class="topic nested1" aria-labelledby="ariaid-title2" id="introduction"><h2 class="title topictitle2" id="ariaid-title2">Introduction</h2><div class="body"><p class="p">This section provides descriptions of the Math libraries that are available in MPLAB-X Harmony 3.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title3" id="description"><h3 class="title topictitle3" id="ariaid-title3">Description</h3><div class="body"><p class="p">The fixed point math libraries use fractional value represented in "Q" format as described below</p>
<p class="p"><strong class="ph b">Integer Representation of Fractions</strong></p>
<p class="p">Fractional representation of a real number is given by:</p>
<p class="p"><em class="ph i">Qn.m</em> where:</p>
<p class="p">• <em class="ph i">n</em> is the number of data bits to the left of the radix point</p>
<p class="p">• <em class="ph i">m</em> is the number of data bits to the right of the radix point</p>
<p class="p">• a signed bit is implied, and takes one bit of resolution</p>
<p class="p">• Shorthand may eliminate the leading 0, such as in Q0.15, which may be shortened to Q15, and similarly Q0.31, which is shortened to Q31</p>
<p class="p"><em class="ph i">Qn.m</em> numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. Therefore, the range of the numerical value is:</p>
<span class="undefined_element">-2<sup class="ph sup">(n-1)</sup> to [2<sup class="ph sup">(n-1)</sup>) - 2<sup class="ph sup">(-m)</sup>]; with a resolution of 2<sup class="ph sup">(-m)</sup>.</span><p class="p">A Q16 format number (Q15.16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259 (or 2<sup class="ph sup">(-16)</sup>). For example, a numerical representation of the number 3.14159 in Q2.13 notation would be:</p>
<span class="undefined_element">3.14159 * 213<sup class="ph sup">(13)</sup> = 25735.9 =&gt; 0x6488</span><p class="p">And converting from the Q7.8 format with the value 0x1D89 would be:</p>
<span class="undefined_element">0x1D89 / 2<sup class="ph sup">(8)</sup> = 7561 / 256 =&gt; 29.5316, accurate to 0.00391</span><p class="p">The majority of the math libraries uses functions with variables in Q15 or Q31 format. This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary. All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution. Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.</p>
<p class="p">Usually, a Q16, Q31 and version of each function is available. Floating point versions are also available for CMSIS-DSP.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title4" id="cmsis-dsp"><h2 class="title topictitle2" id="ariaid-title4">CMSIS-DSP</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title5" id="cmsis-dsp-library"><h3 class="title topictitle3" id="ariaid-title5">CMSIS-DSP Library</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title6" id="introduction-1"><h3 class="title topictitle3" id="ariaid-title6">Introduction</h3><div class="body"><p class="p">This topic describes the CMSIS-DSP Library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title7" id="description-1"><h3 class="title topictitle3" id="ariaid-title7">Description</h3><div class="body"><p class="p">The Cortex Microcontroller System Interface Standard-DSP (CMSIS-DSP) Library is the ARM® DSP Math Library integrated with MPLAB Harmony. It can only be used for ARM Cortex cores M0 through M7.</p>
<p class="p">The CMSIS-DSP Library contains functions implementing 16-bit (Q15) and 32-bit (Q31) fixed-point math, as well as 32-bit floating point (F32) math.</p>
<p class="p">Functions included in the CMSIS-DSP Library include complex math, vector math, matrix math, digital filters, adaptive filters, control and transforms. In many cases, these functions require specific data structures to operate, which are detailed in the header file.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title8" id="using-the-library"><h3 class="title topictitle3" id="ariaid-title8">Using the Library</h3><div class="body"><p class="p">This topic describes the basic architecture of the CMSIS-DSP Library and provides information and examples on its use.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title9" id="description-2"><h3 class="title topictitle3" id="ariaid-title9">Description</h3><div class="body"><p class="p"><strong class="ph b">Interface Header File:</strong>  <strong class="ph b">arm_math.h</strong></p>
<p class="p">The interface to the DSP Fixed-Point library is defined in the arm_math.h header file. Any C language source (.c) file that uses the DSP Fixed-Point library must include arm_math.h.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title10" id="library-source-files"><h3 class="title topictitle3" id="ariaid-title10">Library Source Files</h3><div class="body"><p class="p">The CMSIS-DSP Library source files are provided in the dev_packs repo under:</p>
<p class="p">packs\arm\CMSIS&amp;lt;Version Number&gt;\CMSIS\DSP\Source</p>
<p class="p">The source is not generated to the Harmony 3 project but will give the implementation details and the ability to rebuild the library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title11" id="library-files"><h3 class="title topictitle3" id="ariaid-title11">Library Files</h3><div class="body"><p class="p">The CMSIS-DSP Library archive file is generated by MHC to the following project directory:</p>
<p class="p">firmware\src\packs\CMSIS\CMSIS\DSP\Lib\GCC</p>
<p class="p">The following prebuilt versions of the library are available:</p>
<p class="p">libarm_cortexM0l_math.a</p>
<p class="p">libarm_cortexM3l_math.a</p>
<p class="p">libarm_cortexM4l_math.a</p>
<p class="p">libarm_cortexM4lf_math.a</p>
<p class="p">libarm_cortexM7l_math.a</p>
<p class="p">libarm_cortexM7lfdp_math.a</p>
<p class="p">libarm_cortexM7lfsp_math.a</p>
<p class="p">The naming convention is as follows:</p>
<p class="p">libarm_&lt;ARM,cortex&gt;&lt;core&gt;&lt;codes&gt;_math.a</p>
<p class="p">The cores are: M0,M3,M4, or M7,</p>
<p class="p">The codes are as follows:</p>
<p class="p">&lt;l,b&gt; - little or big endian byte order</p>
<p class="p">&lt;dp,sp&gt; – double or single precision</p>
<p class="p">&lt;f&gt; - Floating Point Unit on</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title12" id="configuring-the-library-using-mhc"><h3 class="title topictitle3" id="ariaid-title12">Configuring the Library using MHC</h3><div class="body"><p class="p">Provides information on using MPLAB Harmony Configurator (MHC) to configure the library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title13" id="description-3"><h3 class="title topictitle3" id="ariaid-title13">Description</h3><div class="body"><p class="p">The library can be generated by the MPLAB Harmony Configurator to any MPLAB® Harmony 3 project that has the CMSIS Pack component, i.e. only MPLAB® Harmony 3 projects that target ARM processors. Select the CMSIS Pack component highlighted in from the Project Graph.</p>
<p class="p">The Configuration Options window looks like the following, with the selection for the CMSIS-DSP Library</p>
<p class="p">The speed optimized library for the given processor will be generated to the project.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title14" id="library-overview"><h3 class="title topictitle3" id="ariaid-title14">Library Overview</h3><div class="body"><p class="p">The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the CMSIS-DSP Library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title15" id="library-interface"><h3 class="title topictitle3" id="ariaid-title15">Library Interface</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title16" id="section"><h3 class="title topictitle3" id="ariaid-title16">Section</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title17" id="description-4"><h3 class="title topictitle3" id="ariaid-title17">Description</h3><div class="body"><p class="p"><strong class="ph b">Basic Math Functions</strong></p>
<p class="p">Basic vector math functions.</p>
<p class="p"><strong class="ph b">Fast Math Functions</strong></p>
<p class="p">This set of functions provides a fast approximation to sine, cosine, and square root.</p>
<p class="p"><strong class="ph b">Complex Math Functions</strong></p>
<p class="p">This set of functions operates on complex data vectors. The data in the complex arrays is stored in an interleaved fashion (real, imaginary, real, imaginary, ...). In the API functions, the number of samples in a complex array refers to the number of complex values; the array contains twice this number of real values.</p>
<p class="p"><strong class="ph b">Filter</strong></p>
<p class="p">Implementation of biquad cascade, IIR Direct Form I and II Transposed, convolution, correlation, FIR, IIR Lattice, LMS, and Normalized LMS filter functions</p>
<p class="p"><strong class="ph b">Matrix Functions</strong></p>
<p class="p">This set of functions provides basic matrix math operations. The functions operate on matrix data
structures.</p>
<p class="p"><strong class="ph b">Transforms</strong></p>
<p class="p">FFT, DCT Type IV, and Real FFT functions.</p>
<p class="p"><strong class="ph b">Statistical Functions</strong></p>
<p class="p">Maximum, Minimum, Mean, Power, RMS, Standard Deviation and Variance calculations.</p>
<p class="p"><strong class="ph b">Support Functions</strong></p>
<p class="p">Vector Copy, Vector Fill, and conversion between F32, Q15, Q32 and Q7 values.</p>
<p class="p"><strong class="ph b">Interpolation Functions</strong></p>
<p class="p">Linear and Bilinear interpolation functions.</p>
<p class="p"><strong class="ph b">Motor Control Functions</strong></p>
<p class="p">PID Motor Control and Vector Clark, Vector Park, and Vector Inverse</p>
<p class="p">The CMSIS-DSP Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.</p>
<p class="p">Floating point versions of the function are also available.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title18" id="library-interface-1"><h3 class="title topictitle3" id="ariaid-title18">Library Interface</h3><div class="body"><p class="p">Provides information on the list of available functions and interfaces.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title19" id="description-5"><h3 class="title topictitle3" id="ariaid-title19">Description</h3><div class="body"><p class="p">Documentation of the available CMSIS-DSP Library functions and interfaces and their descriptions can be found at:</p>
<p class="p">https://arm-software.github.io/CMSIS_5/DSP/html/modules.html</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title20" id="dsp"><h2 class="title topictitle2" id="ariaid-title20">DSP</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title21" id="dsp-fixed-point-math-libraries"><h3 class="title topictitle3" id="ariaid-title21">DSP Fixed-Point Math Libraries</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title22" id="introduction-2"><h3 class="title topictitle3" id="ariaid-title22">Introduction</h3><div class="body"><p class="p">This topic describes the DSP Fixed-Point Math Libraries.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title23" id="description-6"><h3 class="title topictitle3" id="ariaid-title23">Description</h3><div class="body"><p class="p">The DSP Fixed-Point Library are available for the PIC32MZ family of microcontrollers. This library was created from optimized
assembly routines written specifically for devices with microAptiv™ core features that utilize DSP ASE.</p>
<p class="p">_ <strong class="ph b">The LIBQ library is required to use the DSP library.</strong> _</p>
<p class="p">The DSP Fixed-Point Library contains building block functions for developing digital signal processing algorithms. The library supports the Q15 and Q31 fractional data formats. The functions are implemented in efficient assembly specifically targeted at the DSP extensions in this core family.</p>
<p class="p">The library makes these functions available in a simple C-callable structure.</p>
<p class="p">Functions included in the DSP Fixed-Point Library include complex math, vector math, matrix math, digital filters, and transforms.</p>
<p class="p">In many cases, these functions require specific data structures to operate, which are detailed in the header file and examples.</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the DSP Fixed-Point Library and provides information and examples on its use.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title24" id="description-7"><h3 class="title topictitle3" id="ariaid-title24">Description</h3><div class="body"><p class="p"><strong class="ph b">Interface Header File:</strong>  <strong class="ph b">dsp.h,</strong></p>
<p class="p">The interface to the DSP Fixed-Point library is defined in the dsp.h header file. Any C language source (.c) file that uses the DSP</p>
<p class="p">Fixed-Point library must include dsp.h. This file is automatically included by definitions.h when the library is generated using MHC.</p>
<p class="p">Some functions make special use of the optimized fixed-point math library libq.h. For use of those functions, the libq.h file
must also be included in a project. The libq.h file is also installed with MPLAB Harmony. Specific notes within each function will describe if the function is dependent on the LibQ Fixed-Point Math Library.</p>
<p class="p">Library Files:</p>
<p class="p">The DSP Fixed-Point library archive (.a) files are installed with MPLAB Harmony. Although there are two PIC32 DSP files, the linker will only utilize one of these depending on your device usage.</p>
<p class="p">This library is only available in prebuilt binary form, with prototypes for each function described in the dsp.h file. The available</p>
<p class="p">library versions are:</p>
<p class="p">• dsp_mips32_mz_ef_nfO3.a</p>
<p class="p">• dsp_mips32_mz_ef_nfOs.a</p>
<p class="p">The naming convention for these libraries is as follows:</p>
<p class="p">&lt;name&gt;<em class="ph i">&lt;arch&gt;</em>&lt;core&gt;<em class="ph i">&lt;fpu&gt;</em>&lt;codes&gt;.a</p>
<p class="p">where, "name" is the name of the library (DSP); "arch" is the 32 MIPS architecture (MIPS32); "core" is the microAptive core with</p>
<p class="p">DSP ASE extensions (MZ); and "fpu" indicates that a Floating Point Unit(FPU) is available. The "codes" are as follows:</p>
<p class="p">• &lt;nf, fpu&gt; - FPU disabled or enabled</p>
<p class="p">• &lt;O3,OS&gt; - Fully optimized for speed or optimized for size.</p>
<p class="p"><strong class="ph b">Configuring the Library using MHC</strong></p>
<p class="p">Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries.</p>
<p class="p">The project configuration should now contain the Math Libraries block.</p>
<p class="p">Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.</p>
<p class="p">NOTE: LIBQ is also required to be selected.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title25" id="library-overview-1"><h3 class="title topictitle3" id="ariaid-title25">Library Overview</h3><div class="body"><p class="p">The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the</p>
<p class="p">DSP Fixed-Point Math Library.</p>
<p class="p"><strong class="ph b">Library Interface Section Description</strong></p>
<p class="p"><strong class="ph b">Complex Math Functions</strong></p>
<p class="p">General mathematical operations using a complex structure with the form (a + bi)</p>
<p class="p"><strong class="ph b">Vector Math Functions</strong></p>
<p class="p">Mathematical operations on a array of numbers or vector</p>
<p class="p"><strong class="ph b">Matrix Math Functions</strong></p>
<p class="p">Mathematical operations on a matrix</p>
<p class="p"><strong class="ph b">Digital Filter Functions</strong></p>
<p class="p">FIR and IIR filtering functions with various architectures</p>
<p class="p"><strong class="ph b">Transform Functions</strong></p>
<p class="p">FFT, Windows and related transform elements</p>
<p class="p"><strong class="ph b">Support Functions</strong></p>
<p class="p">Quick support functions for numerical transform</p>
<p class="p">The DSP Fixed-Point Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.</p>
<p class="p">A majority of the DSP Fixed-Point Library uses functions with variables in Q15 or Q31 format. Representations of these numbers are given in <strong class="ph b">Data Types and Constants</strong> in the Library Interface section, and generally are int16_t (for Q15 fractional representation) and int32_t (for Q31 fractional representation). This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary.</p>
<p class="p">All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution.</p>
<p class="p">Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title26" id="library-interface-2"><h3 class="title topictitle3" id="ariaid-title26">Library Interface</h3><div class="body"><p class="p"><strong class="ph b">Functions</strong></p>
<p class="p"><strong class="ph b">Name Description</strong></p>
<p class="p">DSP_ComplexAdd32 Calculates the sum of two complex numbers.</p>
<p class="p">DSP_ComplexConj16 Calculates the complex conjugate of a complex number.</p>
<p class="p">DSP_ComplexConj32 Calculates the complex conjugate of a complex number.</p>
<p class="p">DSP_ComplexDotProd32 Calculates the dot product of two complex numbers.</p>
<p class="p">DSP_ComplexMult32 Multiplies two complex numbers.</p>
<p class="p">DSP_ComplexScalarMult32 Multiplies a complex number and a scalar number.</p>
<p class="p">DSP_ComplexSub32 Calculates the difference of two complex numbers.</p>
<p class="p">DSP_FilterFIR32 Performs a Finite Infinite Response (FIR) filter on a vector.</p>
<p class="p">DSP_FilterFIRDecim32 Performs a decimating FIR filter on the input array.</p>
<p class="p">DSP_FilterFIRInterp32 Performs an interpolating FIR filter on the input array.</p>
<p class="p">DSP_FilterIIR16 Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.</p>
<p class="p">DSP_FilterIIRBQ16 Performs a single-pass IIR Biquad Filter.</p>
<p class="p">DSP_FilterIIRBQ16_cascade8 Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.</p>
<p class="p">DSP_FilterIIRBQ16_cascade8_fast Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.</p>
<p class="p">DSP_FilterIIRBQ16_fast Performs a single-pass IIR Biquad Filter.</p>
<p class="p">DSP_FilterIIRBQ16_parallel8 Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.</p>
<p class="p">DSP_FilterIIRBQ16_parallel8_fast Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.</p>
<p class="p">DSP_FilterIIRBQ32 Performs a high resolution single-pass IIR Biquad Filter.</p>
<p class="p">DSP_FilterIIRSetup16 Converts biquad structure to coeffs array to set up IIR filter.</p>
<p class="p">DSP_FilterLMS16 Performs a single sample Least Mean Squares FIR Filter.</p>
<p class="p">DSP_MatrixAdd32 Addition of two matrices C = (A + B).</p>
<p class="p">DSP_MatrixEqual32 Equality of two matrices C = (A).</p>
<p class="p">DSP_MatrixInit32 Initializes the first N elements of a Matrix to the value num.</p>
<p class="p">DSP_MatrixMul32 Multiplication of two matrices C = A x B.</p>
<p class="p">DSP_MatrixScale32 Scales each element of an input buffer (matrix) by a fixed number.</p>
<p class="p">DSP_MatrixSub32 Subtraction of two matrices C = (A - B).</p>
<p class="p">DSP_MatrixTranspose32 Transpose of a Matrix C = A (T).</p>
<p class="p">DSP_TransformFFT16 Creates an Fast Fourier Transform (FFT) from a time domain input.</p>
<p class="p">DSP_TransformFFT16_setup Creates FFT coefficients for use in the FFT16 function.</p>
<p class="p">DSP_TransformFFT32 Creates an Fast Fourier Transform (FFT) from a time domain input.</p>
<p class="p">DSP_TransformFFT32_setup Creates FFT coefficients for use in the FFT32 function.</p>
<p class="p">DSP_TransformIFFT16 Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.</p>
<p class="p">DSP_TransformWindow_Bart16 Perform a Bartlett window on a vector.</p>
<p class="p">DSP_TransformWindow_Bart32 Perform a Bartlett window on a vector.</p>
<p class="p">DSP_TransformWindow_Black16 Perform a Blackman window on a vector.</p>
<p class="p">DSP_TransformWindow_Black32 Perform a Blackman window on a vector.</p>
<p class="p">DSP_TransformWindow_Cosine16 Perform a Cosine (Sine) window on a vector.</p>
<p class="p">DSP_TransformWindow_Cosine32 Perform a Cosine (Sine) window on a vector.</p>
<p class="p">DSP_TransformWindow_Hamm16 Perform a Hamming window on a vector.</p>
<p class="p">DSP_TransformWindow_Hamm32 Perform a Hamming window on a vector.</p>
<p class="p">DSP_TransformWindow_Hann16 Perform a Hanning window on a vector.</p>
<p class="p">DSP_TransformWindow_Hann32 Perform a Hanning window on a vector.</p>
<p class="p">DSP_TransformWindow_Kaiser16 Perform a Kaiser window on a vector.</p>
<p class="p">DSP_TransformWindow_Kaiser32 Perform a Kaiser window on a vector.</p>
<p class="p">DSP_TransformWinInit_Bart16 Create a Bartlett window.</p>
<p class="p">DSP_TransformWinInit_Bart32 Create a Bartlett window.</p>
<p class="p">DSP_TransformWinInit_Black16 Create a Blackman window.</p>
<p class="p">DSP_TransformWinInit_Black32 Create a Blackman window.</p>
<p class="p">DSP_TransformWinInit_Cosine16 Create a Cosine (Sine) window.</p>
<p class="p">DSP_TransformWinInit_Cosine32 Create a Cosine (Sine) window.</p>
<p class="p">DSP_TransformWinInit_Hamm16 Create a Hamming window.</p>
<p class="p">DSP_TransformWinInit_Hamm32 Create a Hamming window.</p>
<p class="p">DSP_TransformWinInit_Hann16 Create a Hanning window.</p>
<p class="p">DSP_TransformWinInit_Hann32 Create a Hanning window.</p>
<p class="p">DSP_TransformWinInit_Kaiser16 Create a Kaiser window.</p>
<p class="p">DSP_TransformWinInit_Kaiser32 Create a Kaiser window.</p>
<p class="p">DSP_VectorAbs16 Calculate the absolute value of a vector.</p>
<p class="p">DSP_VectorAbs32 Calculate the absolute value of a vector.</p>
<p class="p">DSP_VectorAdd16 Calculate the sum of two vectors.</p>
<p class="p">DSP_VectorAdd32 Calculate the sum of two vectors.</p>
<p class="p">DSP_VectorAddc16 Calculate the sum of a vector and a constant.</p>
<p class="p">DSP_VectorAddc32 Calculate the sum of a vector and a constant.</p>
<p class="p">DSP_VectorAutocorr16 Computes the Autocorrelation of a Vector.</p>
<p class="p">DSP_VectorBexp16 Computes the maximum binary exponent of a vector.</p>
<p class="p">DSP_VectorBexp32 Computes the maximum binary exponent of a vector.</p>
<p class="p">DSP_VectorChkEqu32 Compares two input vectors, returns an integer 1 if equal, and 0 if not equal.</p>
<p class="p">DSP_VectorCopy Copies the elements of one vector to another.</p>
<p class="p">DSP_VectorCopyReverse32 Reverses the order of elements in one vector and copies them into another.</p>
<p class="p">DSP_VectorDivC Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.</p>
<p class="p">DSP_VectorDotp16 Computes the dot product of two vectors, and scales the output by a binary factor.</p>
<p class="p">DSP_VectorDotp32 Computes the dot product of two vectors, and scales the output by a binary factor</p>
<p class="p">DSP_VectorExp Computes the EXP (e^x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorFill Fills an input vector with scalar data.</p>
<p class="p">DSP_VectorLn Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorLog10 Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorLog2 Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorMax32 Returns the maximum value of a vector.</p>
<p class="p">DSP_VectorMaxIndex32 Returns the index of the maximum value of a vector.</p>
<p class="p">DSP_VectorMean32 Calculates the mean average of an input vector.</p>
<p class="p">DSP_VectorMin32 Returns the minimum value of a vector.</p>
<p class="p">DSP_VectorMinIndex32 Returns the index of the minimum value of a vector.</p>
<p class="p">DSP_VectorMul16 Multiplication of a series of numbers in one vector to another vector.</p>
<p class="p">DSP_VectorMul32 Multiplication of a series of numbers in one vector to another vector.</p>
<p class="p">DSP_VectorMulc16 Multiplication of a series of numbers in one vector to a scalar value.</p>
<p class="p">DSP_VectorMulc32 Multiplication of a series of numbers in one vector to a scalar value.</p>
<p class="p">DSP_VectorNegate Inverses the sign (negates) the elements of a vector.</p>
<p class="p">DSP_VectorRecip Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorRMS16 Computes the root mean square (RMS) value of a vector.</p>
<p class="p">DSP_VectorShift Shifts the data index of an input data vector.</p>
<p class="p">DSP_VectorSqrt Computes the square root of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p">DSP_VectorStdDev16 Computes the Standard Deviation of a Vector.</p>
<p class="p">DSP_VectorSub16 Calculate the difference of two vectors.</p>
<p class="p">DSP_VectorSub32 Calculate the difference of two vectors.</p>
<p class="p">DSP_VectorSumSquares16 Computes the sum of squares of a vector, and scales the output by a binary factor.</p>
<p class="p">DSP_VectorSumSquares32 Computes the sum of squares of a vector, and scales the output by a binary factor.</p>
<p class="p">DSP_VectorVari16 Computes the variance of N elements of a Vector.</p>
<p class="p">DSP_VectorVariance Computes the variance of N elements of inVector.</p>
<p class="p">DSP_VectorZeroPad Fills an input vector with zeros.</p>
<p class="p">mul16 multiply and shift integer</p>
<p class="p">mul16r multiply and shift Q15</p>
<p class="p">mul32 multiply and shift Q31</p>
<p class="p">SAT16 saturate both positive and negative Q15</p>
<p class="p">SAT16N saturate negative Q15</p>
<p class="p">SAT16P saturate positive Q15</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">_ <strong class="ph b">Functions</strong> _</p>
<p class="p"><strong class="ph b">DSP_ComplexAdd32 Function</strong></p>
<p class="p">Calculates the sum of two complex numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexAdd32:</p>
<p class="p">void DSP_ComplexAdd32(int32c *indata1, int32c *indata2, int32c *Output);</p>
<p class="p">Calculates the sum of two complex numbers, indata1 and indata2, and stores the complex result in Output. Complex numbers must be in the structural form that includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. All values are in Q31 fractional data format. (a + bi) + (c + di) =&gt; (a + c) + (b + d)i</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input complex number (int32c)</p>
<p class="p">indata2 pointer to input complex number (int32c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1, *input2;</p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">int32c test_complex_2 = {0x73333333,0xB3333334};</p>
<p class="p"><em class="ph i">// (0.9 - 0.6i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">input2=&amp;test_complex_2;</p>
<p class="p">DSP_ComplexAdd32(input1, input2, res);</p>
<p class="p"><em class="ph i">// result = {0x73333333, 0xC0000000} = (0.9 - 0.5i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexAdd32</strong> (int32c * <strong class="ph b">indata1</strong> , int32c * <strong class="ph b">indata2</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexConj16 Function</strong></p>
<p class="p">Calculates the complex conjugate of a complex number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">DSP_ComplexConj16:</p>
<p class="p">void DSP_ComplexConj16(int16c *indata, int16c *Output);</p>
<p class="p">CCalculates the complex conjugate of Indata, and stores the result in Outdata. Both numbers must be in the complex number data structure which includes real and imaginary components. Values are in Q15 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =&gt; (a - bi)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input complex number (int16c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int16c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16c *res, result;</p>
<p class="p">int16c *input1;</p>
<p class="p">int16c test_complex_1 = {0x4000,0x0CCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">DSP_ComplexConj16(input1, res);</p>
<p class="p"><em class="ph i">// result = {0x4000, 0xF334} = (0.5 - 0.1i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexConj16</strong> (int16c * <strong class="ph b">indata</strong> , int16c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexConj32 Function</strong></p>
<p class="p">Calculates the complex conjugate of a complex number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexConj32:</p>
<p class="p">void DSP_ComplexConj32(int32c *indata, int32c *Output);</p>
<p class="p">Calculates the complex conjugate of indata, and stores the result in Output. Both numbers must be in the complex number data structure, which includes real and imaginary components. Values are in Q31 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =&gt; (a - bi)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input complex number (int32c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1;</p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">DSP_ComplexConj32(input1, res);</p>
<p class="p"><em class="ph i">// result = {0x40000000, 0xF3333334} = (0.5 - 0.1i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexConj32</strong> (int32c * <strong class="ph b">indata</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexDotProd32 Function</strong></p>
<p class="p">Calculates the dot product of two complex numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexDotProd32:</p>
<p class="p">void DSP_ComplexDotProd32(int32c *indata1, int32c *indata2, int32c *Output);</p>
<p class="p">Calculates the dot product of two complex numbers, indata1 and indata2, and stores the result in Output. All numbers must be in complex structural format that includes real and imaginary components, and the numbers are in fractional Q31 format. The function will saturate the output if it exceeds maximum or minimum ratings. The formula for the dot product is as follows:</p>
<p class="p">Output(real) = (Input1.re * Input2.re) + (Input1.im * Input2.im); Output(img) = <span class="xref"></span>i (a +</p>
<p class="p">bi) dot (c + di) =&gt; (a * c + b * d) + (a * d - b * c)i</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input complex number (int32c)</p>
<p class="p">indata2 pointer to input complex number (int32c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1, *input2;</p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">int32c test_complex_2 = {0x73333333,0xB3333334};</p>
<p class="p"><em class="ph i">// (0.9 - 0.6i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">input2=&amp;test_complex_2;</p>
<p class="p">DSP_ComplexDotProd32(input1, input2, res);</p>
<p class="p"><em class="ph i">// result = {0x31EB851E, 0xCE147AE3} = (0.39 - 0.39i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexDotProd32</strong> (int32c * <strong class="ph b">indata1</strong> , int32c * <strong class="ph b">indata2</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexMult32 Function</strong></p>
<p class="p">Multiplies two complex numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexMult32:</p>
<p class="p">void DSP_ComplexMult32(int32c *indata1, int32c *indata2, int32c *Output);</p>
<p class="p">Multiplies two complex numbers, indata1 and indata2, and stores the complex result in Output. All numbers must be in the int32c complex data structure. All data is in Q31 fractional format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re * Input2.re) - (Input1.im * Input2.im); Output(img) = [(Input1.re * Input2.im) + (Input1.im *</p>
<p class="p">Input2.re)]i (a + bi) x (c + di) =&gt; (a * c - b * d) + (a * d + b * c)i</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input complex number (int32c)</p>
<p class="p">indata2 pointer to input complex number (int32c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1, *input2;</p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">int32c test_complex_2 = {0x73333333,0xB3333334};</p>
<p class="p"><em class="ph i">// (0.9 - 0.6i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">input2=&amp;test_complex_2;</p>
<p class="p">DSP_ComplexMult32(input1, input2, res);</p>
<p class="p"><em class="ph i">// result = {0x4147AE14, 0xE51EB8551} = (0.51 - 0.21i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexMult32</strong> (int32c * <strong class="ph b">indata1</strong> , int32c * <strong class="ph b">indata2</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexScalarMult32 Function</strong></p>
<p class="p">Multiplies a complex number and a scalar number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexScalarMult32:</p>
<p class="p">void DSP_ComplexScalarMult32(int32c *indata, int32_t Scalar, int32c *Output);</p>
<p class="p">Multiplies a complex number, indata, by a scalar number, Scalar, and stores the result in Output. indata and Output must be in</p>
<p class="p">int32c structure with real and imaginary components. All data must be in the fractional Q31 format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re * Scalar); Output(img) = <span class="xref"></span>i (a + bi) * C =&gt;</p>
<p class="p">(a * C + b * Ci)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input complex number (int32c)</p>
<p class="p">Scalar fractional scalar input value (int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1;</p>
<p class="p">int32_t scalarInput = 0x20000000; <em class="ph i">// 0.25</em></p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">DSP_ComplexScalarMult32(input1, scalarInput, res);</p>
<p class="p"><em class="ph i">// result = {0x10000000, 0x03333333} = (0.125 + 0.025i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexScalarMult32</strong> (int32c * <strong class="ph b">indata</strong> , int32_t <strong class="ph b">Scalar</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_ComplexSub32 Function</strong></p>
<p class="p">Calculates the difference of two complex numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_ComplexSub32:</p>
<p class="p">void DSP_ComplexSub32(int32c *indata1, int32c *indata2, int32c *Output);</p>
<p class="p">Calculates the difference of two complex numbers, indata1 less indata2, and stores the complex result in Output. Both numbers must be in a complex data structure, which includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. Real and imaginary components are in the Q31 fractional data format. (a + bi) - (c + di) =&gt; (a</p>
<ul class="ul"><li class="li"><p class="p">c) + (b - d)i</p>
</li>
</ul>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Complex numbers must be in the int32c format.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input complex number (int32c)</p>
<p class="p">indata2 pointer to input complex number (int32c)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pointer to result complex numbers (int32c)</p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32c *res, result;</p>
<p class="p">int32c *input1, *input2;</p>
<p class="p">int32c test_complex_1 = {0x40000000,0x0CCCCCCC};</p>
<p class="p"><em class="ph i">// (0.5 + 0.1i)</em></p>
<p class="p">int32c test_complex_2 = {0x73333333,0xB3333334};</p>
<p class="p"><em class="ph i">// (0.9 - 0.6i)</em></p>
<p class="p">res=&amp;result;</p>
<p class="p">input1=&amp;test_complex_1;</p>
<p class="p">input2=&amp;test_complex_2;</p>
<p class="p">DSP_ComplexSub32(input1, input2, res);</p>
<p class="p"><em class="ph i">// result = {0xCCCCCCCD, 0x59999998} = (-0.4 + 0.7i)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_ComplexSub32</strong> (int32c * <strong class="ph b">indata1</strong> , int32c * <strong class="ph b">indata2</strong> , int32c * <strong class="ph b">Output</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterFIR32 Function</strong></p>
<p class="p">Performs a Finite Infinite Response (FIR) filter on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterFIR32:</p>
<p class="p">void DSP_FilterFIR32(int32_t *outdata, int32_t *indata, int32_t *coeffs2x, int32_t *delayline, int N, int K, int scale);</p>
<p class="p">Performs an FIR filter on the vector indata, and stores the output in the vector outdata. The number of samples processed in the array is given by N. The number of filter taps is given by K. The values are scaled upon input by the binary scaling factor (right shift), scale. The array of 2*K coefficients is contained in the array coeffs2x, where the values are in order b0, b1, b2... and repeated. Lastly the delayline is an array of K values that are initialized to zero and represent previous values. All values are in fractional Q31 data format. The function will saturate results if minimum or maximum values are exceeded.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four. K must be greater than 2 and a multiple of 2. delayline must have K elements, and be initialized to zero. coeffs2x must have
2*K elements.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (int32_t)</p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">coeffs2x pointer to an array of coefficients (int32_t)</p>
<p class="p">delayline pointer to an array of delay variables (int32_t)</p>
<p class="p">N number of points in the array to process (int) number of samples (int)</p>
<p class="p">K number of filter taps</p>
<p class="p">scale binary scaler divisor (1 / 2^scale) (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Filter coefs must be repeated within the array. The array is twice as large as the number of taps, and the values are repeated in order b0, b1, b2,...bn, b0, b1, b2,... bn. The function updates the delayline array, which must be K elements long. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> TAPS 4</p>
<p class="p"><strong class="ph b">#define</strong> numPOINTS 256</p>
<p class="p">int filterN = numPOINTS;</p>
<p class="p">int filterK = TAPS;</p>
<p class="p">int filterScale = 1; <em class="ph i">// scale output by 1/2^1 =&gt; output * 0.5</em></p>
<p class="p">int32_t FilterCoefs<span class="xref"></span> = {0x40000000, 0x20000000, 0x20000000, 0x20000000,</p>
<p class="p">0x40000000, 0x20000000, 0x20000000, 0x20000000};</p>
<p class="p"><em class="ph i">// note repeated filter coefs, A B C D A B C D</em></p>
<p class="p"><em class="ph i">// 0.5, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25</em></p>
<p class="p">int32_t outFilterData<span class="xref"></span>={0};</p>
<p class="p">int32_t inFilterData<span class="xref"></span>;</p>
<p class="p">int filterDelayLine<span class="xref"></span>={0};</p>
<p class="p">while ( <strong class="ph b">true</strong> )</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// put some data into input array, inFilterData, here //</em></p>
<p class="p">DSP_FilterFIR32(outFilterData, inFilterData, FilterCoefs, filterDelayLine,</p>
<p class="p">filterN, filterK, filterScale);</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_FilterFIR32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int32_t * <strong class="ph b">coeffs2x</strong> , int32_t *</p>
<p class="p"><strong class="ph b">delayline</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">K</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterFIRDecim32 Function</strong></p>
<p class="p">Performs a decimating FIR filter on the input array.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterFIRDecim32:</p>
<p class="p">void DSP_FilterFIRDecim32(int32_t *outdata, int32_t *indata, int32_t *coeffs, int32_t *delayline, int N, int K, int scale, int rate);</p>
<p class="p">Compute a FIR decimation filter on the input vector indata, and store the results to the vector outdata. The total number of output elements is set by N, and therefore the outdata array must be at least N in length. The decimation ratio is given by rate. The input is sampled every integer value of rate, skipping every (rate-1) input samples. The input array must therefore be (rate*N) samples long. The amount of filter taps is specified by K. Coeffs specifies the coefficients array. The delayline array holds delay inputs for
calculation, and must be initialized to zero prior to calling the filter. Both coeffs and delayline must be K in length. Scale divides the input by a scaling factor by right shifting the number of bits (1/2^scale). All values of input, output, and coeffs are given in Q31 fractional data format. The function will saturate if the output value exceeds the maximum or minimum value.</p>
<p class="p">Y = b0 * X0 + (b1 * X(-1)) + (b2 * X(-2)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have K elements, and be initialized to zero.</p>
<p class="p">coeffs must have K elements. outdata must have N elements indata must have (N*rate) elements</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of elements (int32_t)</p>
<p class="p">indata pointer to input array of elements (int32_t)</p>
<p class="p">coeffs pointer to an array of coefficients (int32_t)</p>
<p class="p">delayline pointer to an array of delay variables (int32_t)</p>
<p class="p">N number of output elements to be processed (int)</p>
<p class="p">K number of filter taps and coeffs (int)</p>
<p class="p">scale binary scaler divisor (1 / 2^scale) (int)</p>
<p class="p">rate decimation ratio (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Coefs are loaded into the array with corresponding to the least delay first (C0, C(-1), C(-2)). K must be greater than rate. Even while decimating the input stream, every input passes through the delayline. So FIR filters of arbitrary length will give the same</p>
<p class="p">output as a non-decimating FIR, just with fewer responses.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> N 8 <em class="ph i">// number of output samples</em></p>
<p class="p"><strong class="ph b">#define</strong> TAPS 5</p>
<p class="p"><strong class="ph b">#define</strong> SKIP 3</p>
<p class="p">int testFilterN = N; <em class="ph i">// number of output elements</em></p>
<p class="p">int testFilterK = TAPS; <em class="ph i">// number of taps</em></p>
<p class="p">int testFilterRate = SKIP; <em class="ph i">// decimation rate R</em></p>
<p class="p">int32_t outFiltDataDec<span class="xref"></span>={0};</p>
<p class="p">int32_t *inTestFilter<span class="xref"></span>;</p>
<p class="p">int filtScaleNum = 1; <em class="ph i">// scale output (1 /2^n) =&gt; Y * 0.5</em></p>
<p class="p">int32_t filtDelayTest<span class="xref"></span>={0}; <em class="ph i">// always initialize to zero</em></p>
<p class="p"><em class="ph i">// get pointer to input buffer here //</em></p>
<p class="p">inTestFilter = &amp;inputBuffer;</p>
<p class="p">DSP_FilterFIRDecim32(outFiltDataDec, inTestFilter, inTestCoefs,</p>
<p class="p">filtDelayTest, testFilterN, testFilterK, filtScaleNum, testFilterRate);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_FilterFIRDecim32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int32_t * <strong class="ph b">coeffs</strong> , int32_t *</p>
<p class="p"><strong class="ph b">delayline</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">K</strong> , int  <strong class="ph b">scale</strong> , int  <strong class="ph b">rate</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterFIRInterp32 Function</strong></p>
<p class="p">Performs an interpolating FIR filter on the input array.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterFIRInterp32:</p>
<p class="p">void DSP_FilterFIRInterp32(int32_t *outdata, int32_t *indata, int32_t *coeffs, int32_t *delayline, int N, int K, int scale, int rate);</p>
<p class="p">Perform an interpolating FIR filter on the first N samples of indata, and stores the result in outdata. The number of output elements is N*rate. The number of filter taps, K, must be an even multiple of N. The coefficients array, Coeffs, must be K elements long. The delay line array, delayline, must be K/R elements long, and be initialized to zero. All data elements must be in Q31 fractional data format. Scaling is performed via binary shift on the input equivalent to (1/2^shift). The function will saturate the output if it exceeds maximum or minimum values. The function creates R output values for each input value processed. The delayline of previous values is processed with R elements of the coefficient array. Numerically:</p>
<p class="p">Y(1,0) = X(0)*C(0) + X(-1)*C(rate) + X(-2)<em class="ph i">C(2</em>rate) ... Y(1,1) = X(0)*C(1) + X(-1)*C(rate+1) + X(-2)<em class="ph i">C(2</em>rate + 1) ... Y(1,rate) =</p>
<p class="p">X(0)*C(N) + X(-1)*C(rate+N) + X(-2)<em class="ph i">C(2</em>rate + N) ...</p>
<p class="p">where output Y corresponds to (input,rate) different outputs, input X has (M/rate) sample delays and C is the coefficient array.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K/R) elements, and be initialized to zero. K (taps) must be an even multiple of R (rate). outdata must have R*N elements.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of elements (int32_t)</p>
<p class="p">indata pointer to input array of elements (int32_t)</p>
<p class="p">coeffs pointer to an array of coefficients (int32_t)</p>
<p class="p">delayline pointer to an array of delay variables (int32_t)</p>
<p class="p">N number of output elements to be processed (int)</p>
<p class="p">K number of filter taps and coeffs (int)</p>
<p class="p">scale binary scaler divisor (1 / 2^scale) (int)</p>
<p class="p">rate decimation ratio (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function processes each input (rate) times. With each pass, coefficients are offset so that (K/rate) multiply accumulate cycles</p>
<p class="p">occur.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// interpret evenly 1/3 spaced values</em></p>
<p class="p"><strong class="ph b">#define</strong> N 4 <em class="ph i">// number of output samples</em></p>
<p class="p"><strong class="ph b">#define</strong> TAPS 6</p>
<p class="p"><strong class="ph b">#define</strong> INTERP 3</p>
<p class="p">int ifiltN = N;</p>
<p class="p">int ifiltK = TAPS; <em class="ph i">// k must be an even multiple of R</em></p>
<p class="p">int ifiltR = INTERP;</p>
<p class="p">int32_t ifiltOut<span class="xref"></span>={0};</p>
<p class="p">int32_t ifiltDelay<span class="xref"></span>={0}; <em class="ph i">// must be initialized to zero</em></p>
<p class="p">int ifiltScale = 0; <em class="ph i">// no scaling</em></p>
<p class="p">int32_t ifiltCoefsThirds<span class="xref"></span>={0x2AAAAAA9, 0x55555555,0x7FFFFFFE,</p>
<p class="p">0x55555555,0x2AAAAAA9,0x00000000};</p>
<p class="p"><em class="ph i">// 0.333333, 0.6666667, 0.99999999, 0.6666667, 0.33333333, 0</em></p>
<p class="p">int32_t ifiltInput<span class="xref"></span>={0x0CCCCCCD, 0x19999999, 0x26666666, 0x33333333};</p>
<p class="p"><em class="ph i">// 0.1, 0.2, 0.3, 0.4</em></p>
<p class="p">DSP_FilterFIRInterp32(ifiltOut, ifiltInput, ifiltCoefsThirds, ifiltDelay,</p>
<p class="p">ifiltN, ifiltK, ifiltScale, ifiltR);</p>
<p class="p"><em class="ph i">// ifiltOut = {0x04444444, 0x08888889, 0x0CCCCCCD, 0x11111111, 0x15555555, 0x19999999,</em></p>
<p class="p"><em class="ph i">// 0x1DDDDDDD, 0x22222221, 0x26666665, 0x2AAAAAAA,0x2EEEEEEE, 0x33333332}</em></p>
<p class="p"><em class="ph i">// = 0.0333, 0.0667, 0.1, 0.1333, 0.1667, 0.2, 0.2333, 0.2667, 0.3, 0.3333, 0.3667, 0.4</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_FilterFIRInterp32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int32_t * <strong class="ph b">coeffs</strong> , int32_t *</p>
<p class="p"><strong class="ph b">delayline</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">K</strong> , int  <strong class="ph b">scale</strong> , int  <strong class="ph b">rate</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIR16 Function</strong></p>
<p class="p">Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIR16:</p>
<p class="p">int16_t DSP_FilterIIR16(int16_t in, int16_t *coeffs, int16_t *delayline, int B, int scale);</p>
<p class="p">Performs a single element cascaded biquad IIR filter on the input, in. The filter contains B number of biquad sections, and cascades the output of one to the input of the next. B must be greater than 2 and a multiple of 2. The int16_t output generated by the function is the computation from the final biquad stage. Delay pipeline array delayline must contain 2<em class="ph i">B values and be initialized to zero prior to use. The coefficient array must contain 4</em>B elements, and must be set up in order of biquad a1, a2, b1, b2. A binary (right shift) factor, scale, will scale the output equivalent to (1/2^scale). All numerical values must be in Q15 fractional data format. The function will saturate values if maximum or minimum values are exceeded.</p>
<p class="p">Y = X0 + (b1 * X(-1)) + (b2 * X(-2) + (a1 * Y(-1)) + (a2 * Y(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. B must be greater than 2 and a multiple of 2. delayline</p>
<p class="p">must have 2<em class="ph i">B elements, and be initialized to zero. coeffs must have 4</em>B elements.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">in input data element X (int16_t)</p>
<p class="p">coeffs pointer to an array of coefficients (int16_t)</p>
<p class="p">delayline pointer to an array of delay variables (int16_t)</p>
<p class="p">B number of cascaded biquad filter groups to process (int)</p>
<p class="p">scale binary scaler divisor (1 / 2^scale) (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> B 8 <em class="ph i">// use * biquad filters in cascade</em></p>
<p class="p">int dataSamples = 256;</p>
<p class="p">int i, j;</p>
<p class="p">biquad16 bquad<span class="xref"></span>;</p>
<p class="p">int16_t coefs<span class="xref"></span>= {0};</p>
<p class="p">int16_t delaylines<span class="xref"></span>= {0};</p>
<p class="p">int16_t Y, X;</p>
<p class="p">int scaleBquad = 1; <em class="ph i">// scale output (1 /2^n) =&gt; Y * 0.5</em></p>
<p class="p"><em class="ph i">// do something to set up coefs, for instance this example //</em></p>
<p class="p">for (j=0; jRemarks:Filter coefs must be stored within the array as a1, a2, b1, b2, a1, a2, b1, b2, in order of biquads form input to output. A function to translate the coeffs from biquad structure to coeffs is available in DSP_FilterIIRSetup16. The function updates the delayline array, which must be 2*B elements <strong class="ph b">long</strong>. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIR16</strong> (int16_t <strong class="ph b">in</strong> , int16_t * <strong class="ph b">coeffs</strong> , int16_t * <strong class="ph b">delayline</strong> , int  <strong class="ph b">B</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16 Function</strong></p>
<p class="p">Performs a single-pass IIR Biquad Filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16:</p>
<p class="p">int16_t DSP_FilterIIRBQ16(int16_t Xin, PARM_EQUAL_FILTER *pFilter);</p>
<p class="p">Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.</p>
<p class="p">All values are fractional Q15 and Q31, see data structure for specifics.</p>
<p class="p">Y = X(0)*b0 + (b1 * X(-1)) + (b2 * X(-2)) - (a1 * Y(-1)) - (a2 * Y(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER *ptrFilterEQ;</p>
<p class="p">PARM_EQUAL_FILTER FilterEQ;</p>
<p class="p">uint16_t DataIn, DataOut;</p>
<p class="p">ptrFilterEQ = &amp;FilterEQ;</p>
<p class="p"><em class="ph i">// 48KHz sampling; 1 KHz bandpass filter; Q=0.9</em></p>
<p class="p"><em class="ph i">// divide by 2 and convert to Q15</em></p>
<p class="p"><em class="ph i">// b0 = 0.06761171785499065</em></p>
<p class="p"><em class="ph i">// b1 = 0</em></p>
<p class="p"><em class="ph i">// b2 = -0.06761171785499065</em></p>
<p class="p"><em class="ph i">// a1 = -1.848823142275648</em></p>
<p class="p"><em class="ph i">// a2 = 0.8647765642900187</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0x0453; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0xFBAD; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x89AD; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x3758; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get some input data here</em></p>
<p class="p">DataIn32 = three_hundred_hz<span class="xref"></span>;</p>
<p class="p">DataOut = DSP_FilterIIRBQ16(DataIn, ptrFilterEQ);</p>
<p class="p"><em class="ph i">// *** do something with the DataOut here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER * <strong class="ph b">pFilter</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16_cascade8 Function</strong></p>
<p class="p">Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16_cascade8:</p>
<p class="p">int16_t DSP_FilterIIRBQ16_cascade8(int16_t Xin, PARM_EQUAL_FILTER *pFilter_Array);</p>
<p class="p">Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 32 bit delay lines are maintained for each. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. Global gain values are available on the output. Fracgain is a Q15 fractional gain value and expgain is a binary shift gain value. The combination of the two can be utilized to normalize the output as desired. All values
are fractional Q15 and Q31, see data structure for specifics.</p>
<p class="p">Y = Y7 &lt;- Y6 &lt;- Y5 &lt;- Y4 &lt;- Y3 &lt;- Y2 &lt;- Y1 &lt;- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)*b0 +</p>
<p class="p">(b1 * Y(n-2)) + (b2 * Y(n-3)) - (a1 * Yn(-1)) - (a2 * Yn(-2)) and: for Y0; Y(n-1) = Xin(0)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER filtArray<span class="xref"></span>;</p>
<p class="p">uint16_t dataY, dataX;</p>
<p class="p"><em class="ph i">// example to use 2 filter blocks as notch filters</em></p>
<p class="p"><em class="ph i">// fill entire Filter Array with coefs</em></p>
<p class="p">for (i=0;i&lt;8;i++)</p>
<p class="p">{</p>
<p class="p">filtArray<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArray<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// all pass</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x4000;</p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Unique filters for example</em></p>
<p class="p"><em class="ph i">// 10KHz notch filter -- divide coefs by 2</em></p>
<p class="p">b0 = 0.5883783602332997</p>
<p class="p">b1 = -0.17124071441396285</p>
<p class="p">b2 = 0.5883783602332997</p>
<p class="p">a1 = -0.17124071441396285</p>
<p class="p">a2 = 0.1767567204665992</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x25a7; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0xf508; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x25a7; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0xf508; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x0b4f; <em class="ph i">// feedback a2 coef</em></p>
<p class="p"><em class="ph i">// 1 KHz notch filter -- divide coefs by 2</em></p>
<p class="p">b0 = 0.9087554064944908</p>
<p class="p">b1 = -1.7990948352036205</p>
<p class="p">b2 = 0.9087554064944908</p>
<p class="p">a1 = -1.7990948352036205</p>
<p class="p">a2 = 0.8175108129889816</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x3a29; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x8cdc; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x3a29; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x8cdc; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x3452; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get input data here</em></p>
<p class="p">dataX = compound_300_1K_hz16<span class="xref"></span>;</p>
<p class="p">dataY = DSP_FilterIIRBQ16_cascade8(dataX, filtArray);</p>
<p class="p"><em class="ph i">// *** do something with the DataY here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16_cascade8</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER * <strong class="ph b">pFilter_Array</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16_cascade8_fast Function</strong></p>
<p class="p">Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16_cascade8_fast:</p>
<p class="p">int16_t DSP_FilterIIRBQ16_cascade8_fast(int16_t Xin, PARM_EQUAL_FILTER_16 *pFilter_Array);</p>
<p class="p">Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 16 bit delay lines are maintained for each. All math is performed using 16 bit instructions, which results rounded to 16-bits for the output. All values are fractional Q15, see data structure for specifics. The function will saturate the output should it exceed maximum or minimum values.</p>
<p class="p">Y = Y7 &lt;- Y6 &lt;- Y5 &lt;- Y4 &lt;- Y3 &lt;- Y2 &lt;- Y1 &lt;- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)*b0 +</p>
<p class="p">(b1 * Y(n-2)) + (b2 * Y(n-3)) - (a1 * Yn(-1)) - (a2 * Yn(-2)) and: for Y0; Y(n-1) = Xin(0)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input a t half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER_16 filtArray<span class="xref"></span>;</p>
<p class="p">uint16_t dataY, dataX;</p>
<p class="p"><em class="ph i">// example to use 2 filter blocks as notch filters</em></p>
<p class="p"><em class="ph i">// fill entire Filter Array with coefs</em></p>
<p class="p">for (i=0;i&lt;8;i++)</p>
<p class="p">{</p>
<p class="p">filtArray<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArray<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// all pass</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x4000;</p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Unique filters for example</em></p>
<p class="p"><em class="ph i">// 10KHz notch filter -- divide coefs by 2</em></p>
<p class="p">b0 = 0.5883783602332997</p>
<p class="p">b1 = -0.17124071441396285</p>
<p class="p">b2 = 0.5883783602332997</p>
<p class="p">a1 = -0.17124071441396285</p>
<p class="p">a2 = 0.1767567204665992</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x25a7; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0xf508; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x25a7; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0xf508; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x0b4f; <em class="ph i">// feedback a2 coef</em></p>
<p class="p"><em class="ph i">// 1 KHz notch filter -- divide coefs by 2</em></p>
<p class="p">b0 = 0.9087554064944908</p>
<p class="p">b1 = -1.7990948352036205</p>
<p class="p">b2 = 0.9087554064944908</p>
<p class="p">a1 = -1.7990948352036205</p>
<p class="p">a2 = 0.8175108129889816</p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x3a29; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x8cdc; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.b<span class="xref"></span>=0x3a29; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x8cdc; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArray<span class="xref"></span>.a<span class="xref"></span>=0x3452; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get input data here</em></p>
<p class="p">dataX = compound_300_1K_hz16<span class="xref"></span>;</p>
<p class="p">dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);</p>
<p class="p"><em class="ph i">// *** do something with the DataY here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16_cascade8_fast</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER_16 * <strong class="ph b">pFilter_Array</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16_fast Function</strong></p>
<p class="p">Performs a single-pass IIR Biquad Filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16_fast:</p>
<p class="p">int16_t DSP_FilterIIRBQ16_fast(int16_t Xin, PARM_EQUAL_FILTER_16 *pFilter);</p>
<p class="p">Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 16 bit instructions, with results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions.</p>
<p class="p">The function will saturate the results if maximum or minimum fractional values are exceeded. All values are fractional Q15 format.</p>
<p class="p">Y = X(0)*b0 + (b1 * X(-1)) + (b2 * X(-2)) - (a1 * Y(-1)) - (a2 * Y(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER_16 *ptrFilterEQ;</p>
<p class="p">PARM_EQUAL_FILTER_16 FilterEQ;</p>
<p class="p">uint16_t DataIn, DataOut;</p>
<p class="p">ptrFilterEQ = &amp;FilterEQ;</p>
<p class="p"><em class="ph i">// 48KHz sampling; 1 KHz bandpass filter; Q=0.9</em></p>
<p class="p"><em class="ph i">// divide by 2 and convert to Q15</em></p>
<p class="p"><em class="ph i">// b0 = 0.06761171785499065</em></p>
<p class="p"><em class="ph i">// b1 = 0</em></p>
<p class="p"><em class="ph i">// b2 = -0.06761171785499065</em></p>
<p class="p"><em class="ph i">// a1 = -1.848823142275648</em></p>
<p class="p"><em class="ph i">// a2 = 0.8647765642900187</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0x0453; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0xFBAD; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x89AD; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x3758; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get some input data here</em></p>
<p class="p">DataIn32 = three_hundred_hz<span class="xref"></span>;</p>
<p class="p">DataOut = DSP_FilterIIRBQ16_fast(DataIn, ptrFilterEQ);</p>
<p class="p"><em class="ph i">// *** do something with the DataOut here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16_fast</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER_16 * <strong class="ph b">pFilter</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16_parallel8 Function</strong></p>
<p class="p">Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16_parallel8:</p>
<p class="p">int16_t DSP_FilterIIRBQ16_parallel8(int16_t Xin, PARM_EQUAL_FILTER *pFilter);</p>
<p class="p">Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15 and Q31, see data structure for specifics.</p>
<p class="p">Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =</p>
<p class="p">X(0)*b0 + (b1 * X(n-1)) + (b2 * X(n-2)) - (a1 * Yn(-1)) - (a2 * Yn(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero. The sum of all fracgain should be &lt;= 1</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2</p>
<p class="p">has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER filtArrayPara<span class="xref"></span>;</p>
<p class="p">uint16_t dataY, dataX;</p>
<p class="p"><em class="ph i">// fill entire Filter Array with coefs</em></p>
<p class="p">for (i=0;i&lt;8;i++)</p>
<p class="p">{</p>
<p class="p">filtArrayPara<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArrayPara<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x7FFF; <em class="ph i">// gain = 1 default</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.expGain = 1; <em class="ph i">// == 2^N; gain of 2</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// none pass -- default</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// 1K bandpass Q=0.9</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x4000; <em class="ph i">// gain = 0.5 because using 2 outputs</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0x04ad;</p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0xfb53; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x8a90; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x36a4; <em class="ph i">// feedback a2 coef</em></p>
<p class="p"><em class="ph i">// 300 Hz bandpass Q=0.9</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x1000; <em class="ph i">// gain = 0.125 as an example</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0x017b; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0xfe85; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x8316; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x3d08; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get input data here</em></p>
<p class="p">dataX = compound_300_1K_hz16<span class="xref"></span>;</p>
<p class="p">dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);</p>
<p class="p"><em class="ph i">// *** do something with the DataY here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16_parallel8</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER * <strong class="ph b">pFilter</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ16_parallel8_fast Function</strong></p>
<p class="p">Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ16_parallel8_fast:</p>
<p class="p">int16_t DSP_FilterIIRBQ16_parallel8_fast(int16_t Xin, PARM_EQUAL_FILTER_16 *pFilter);</p>
<p class="p">Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is</p>
<p class="p">performed using 16 bit instructions, which results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15. The function will round outputs and saturate if maximum or minimum values are exceeded.</p>
<p class="p">Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =</p>
<p class="p">X(0)*b0 + (b1 * X(n-1)) + (b2 * X(n-2)) - (a1 * Yn(-1)) - (a2 * Yn(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero. The sum of all fracgain should be &lt;= 1</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int16_t)</p>
<p class="p">pFilter pointer to filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int16_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER_16 filtArrayPara<span class="xref"></span>; <em class="ph i">// note change in data structure</em></p>
<p class="p">uint16_t dataY, dataX;</p>
<p class="p"><em class="ph i">// fill entire Filter Array with coefs</em></p>
<p class="p">for (i=0;i&lt;8;i++)</p>
<p class="p">{</p>
<p class="p">filtArrayPara<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArrayPara<span class="xref"></span>.Z<span class="xref"></span>=0;</p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x7FFF; <em class="ph i">// gain = 1 default</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.expGain = 1; <em class="ph i">// log2N; gain of 2</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// none pass -- default</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// 1K bandpass Q=0.9</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x4000; <em class="ph i">// gain = 0.5 because using 2 outputs</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0x04ad;</p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0xfb53; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x8a90; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x36a4; <em class="ph i">// feedback a2 coef</em></p>
<p class="p"><em class="ph i">// 300 Hz bandpass Q=0.9</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.G.fracGain = 0x1000; <em class="ph i">// gain = 0.125 as an example</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0x017b; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.b<span class="xref"></span>=0xfe85; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x8316; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">filtArrayPara<span class="xref"></span>.a<span class="xref"></span>=0x3d08; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get input data here</em></p>
<p class="p">dataX = compound_300_1K_hz16<span class="xref"></span>;</p>
<p class="p">dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);</p>
<p class="p"><em class="ph i">// *** do something with the DataY here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterIIRBQ16_parallel8_fast</strong> (int16_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER_16 * <strong class="ph b">pFilter</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRBQ32 Function</strong></p>
<p class="p">Performs a high resolution single-pass IIR Biquad Filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRBQ32:</p>
<p class="p">int32_t DSP_FilterIIRBQ32(int32_t Xin, PARM_EQUAL_FILTER_32 *pFilter);</p>
<p class="p">Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 32-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.</p>
<p class="p">All values are fractional Q31, see data structure for specifics.</p>
<p class="p">Y = X(0)*b0 + (b1 * X(-1)) + (b2 * X(-2)) - (a1 * Y(-1)) - (a2 * Y(-2))</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Delay register values should be initialized to zero.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">Xin input data element X (int32_t)</p>
<p class="p">pFilter pointer to high resolution filter coef and delay structure</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Sample output Y (int32_t)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">PARM_EQUAL_FILTER_32 *ptrFiltEQ32;</p>
<p class="p">PARM_EQUAL_FILTER_32 FilterEQ32;</p>
<p class="p">int32_t DataIn32, DataOut32;</p>
<p class="p">ptrFiltEQ32 = &amp;FilterEQ32;</p>
<p class="p">ptrFiltEQ32-&gt;Z<span class="xref"></span>=0;</p>
<p class="p">ptrFiltEQ32-&gt;Z<span class="xref"></span>=0;</p>
<p class="p"><em class="ph i">// 1000 Hz Q= 0.9 BP filter design, 44.1K sampling</em></p>
<p class="p"><em class="ph i">//</em></p>
<p class="p"><em class="ph i">// b0 = 0.07311778239751009 forward</em></p>
<p class="p"><em class="ph i">// b1 = 0</em></p>
<p class="p"><em class="ph i">// b2 = -0.07311778239751009</em></p>
<p class="p"><em class="ph i">// a1 = -1.8349811166056893 back</em></p>
<p class="p"><em class="ph i">// a2 = 0.8537644352049799</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0x04ADF635; <em class="ph i">// feed forward b0 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0; <em class="ph i">// feed forward b1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;b<span class="xref"></span>=0xFB5209CB; <em class="ph i">// feed forward b2 coef</em></p>
<p class="p"><em class="ph i">// note all coefs are half value of original design, gain handled in algorithm</em></p>
<p class="p"><em class="ph i">// note subtract is handled in algorithm, so coefs go in at actual value</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x8A8FAB5D; <em class="ph i">// feedback a1 coef</em></p>
<p class="p">ptrFiltEQ32-&gt;a<span class="xref"></span>=0x36A41395; <em class="ph i">// feedback a2 coef</em></p>
<p class="p">for (i=0;i&lt;256;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// *** get input data here</em></p>
<p class="p">DataIn32 = three_hundred_hz<span class="xref"></span>;</p>
<p class="p">DataOut32 = DSP_FilterIIRBQ32(DataIn32, ptrFiltEQ32);</p>
<p class="p"><em class="ph i">// *** do something with the DataOut32 here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_FilterIIRBQ32</strong> (int32_t <strong class="ph b">Xin</strong> , PARM_EQUAL_FILTER_32 * <strong class="ph b">pFilter</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterIIRSetup16 Function</strong></p>
<p class="p">Converts biquad structure to coeffs array to set up IIR filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterIIRSetup16:</p>
<p class="p">void DSP_FilterIIRSetup16(int16_t *coeffs, biquad16 *bq, int B);</p>
<p class="p">Converts an array of biquad coefficients, bq, into an linear array of coefficients, coeffs. The output array must be 4*B elements long. The number of biquads in the resulting factor is given by B. All numerical values must be in Q15 fractional data format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">coeffs must have 4*B elements.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">coeffs pointer to an array of coefficients (int16_t)</p>
<p class="p">bq pointer to array of biquad structure filter coefs (biquad16)</p>
<p class="p">B number of cascaded biquad filter groups to process (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">see DSP_FilterIIR16 for example.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_FilterIIRSetup16</strong> (int16_t * <strong class="ph b">coeffs</strong> , biquad16 * <strong class="ph b">bq</strong> , int  <strong class="ph b">B</strong> );</p>
<p class="p"><strong class="ph b">DSP_FilterLMS16 Function</strong></p>
<p class="p">Performs a single sample Least Mean Squares FIR Filter.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_FilterLMS16:</p>
<p class="p">int16_t DSP_FilterLMS16(int16_t in, int16_t ref, int16_t *coeffs, int16_t *delayline, int16_t *error, int K, int16_t mu);</p>
<p class="p">Computes an LMS adaptive filter on the input in. Filter output of the FIR is given as a 16 bit value. The filter target is ref, and the</p>
<p class="p">calculation difference between the output and the target is error. The filter adapts its coefficients, coefs, on each pass. Th number of coefficients (filter taps) is given by the value K. The delayline array should be initialized to zero prior to calling the filter for the first time, and have K elements. The value mu is the rate at which the filter adapts. All values are Q15 fractional numbers.</p>
<p class="p">The function will saturate the output if it exceeds maximum or minimum values. The LMS will adapt its coefs to attempt to drive the output value toward the ref value. The rate of adaption on each pass depends on mu and the error from the previous calculation.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K) elements, and be initialized to</p>
<p class="p">zero. K (taps) must be a multiple of 4, and &gt;= 8. mu must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">in input data value (int16_t)</p>
<p class="p">ref target output value (int16_t)</p>
<p class="p">coeffs pointer to an array of coefficients (int16_t)</p>
<p class="p">delayline pointer to an array of delay variables (int16_t)</p>
<p class="p">error output minus reference (int16_t)</p>
<p class="p">K number of filter taps and coeffs (int)</p>
<p class="p">mu adaption rate (int16_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">(int16_t) - FIR filter output</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Filter coefs may start at random or zero value, but convergence is dependent on the amount of update required.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> lmsTAPS 8</p>
<p class="p">int16_t lmsOut;</p>
<p class="p">int lmsTaps = lmsTAPS;</p>
<p class="p">int16_t lmsCoefs<span class="xref"></span>={0x5000, 0x4000,0x3000, 0x2000,0x1000, 0x0000,0xF000, 0xE000};</p>
<p class="p">int16_t lmsDelay<span class="xref"></span>={0};</p>
<p class="p">int16_t *ptrLMSError;</p>
<p class="p">int16_t lmsError = 0x0200;</p>
<p class="p">int16_t inVal=0;</p>
<p class="p">int16_t refVal = 0x0CCC; <em class="ph i">// some target value = 0.1</em></p>
<p class="p">int16_t lmsAdapt = 0x3000;</p>
<p class="p">ptrLMSError = &amp;lmsError;</p>
<p class="p">for (i=0;i&lt;200;i++)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// get some input value here //</em></p>
<p class="p"><strong class="ph b">if</strong> (i &lt; 100)</p>
<p class="p">{</p>
<p class="p">inVal = 0x4233;</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">else</strong></p>
<p class="p">{</p>
<p class="p">inVal = 0xCF10;</p>
<p class="p">}</p>
<p class="p">lmsOut = DSP_FilterLMS16(inVal, refVal, lmsCoefs, lmsDelay,</p>
<p class="p">ptrLMSError, lmsTaps, lmsAdapt);</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_FilterLMS16</strong> (int16_t <strong class="ph b">in</strong> , int16_t <strong class="ph b">ref</strong> , int16_t * <strong class="ph b">coeffs</strong> , int16_t * <strong class="ph b">delayline</strong> , int16_t</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">error</strong> , int  <strong class="ph b">K</strong> , int16_t <strong class="ph b">mu</strong> );</p>
</li>
</ul>
<p class="p"><strong class="ph b">DSP_MatrixAdd32 Function</strong></p>
<p class="p">Addition of two matrices C = (A + B).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixAdd32:</p>
<p class="p">void DSP_MatrixAdd32(matrix32 *resMat, matrix32 *srcMat1, matrix32 *srcMat2);</p>
<p class="p">Vector summation of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Both matrices must be equivalent in rows and columns. Both Matrices must be set into structure (ROWS, COLUMNS,</p>
<p class="p">vector_pointer).</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">resMat pointer to new sum Matrix C (*int32_t)</p>
<p class="p">srcMat1 pointer to the Matrix A structure (*int32_t)</p>
<p class="p">srcMat2 pointer to the Matrix B structure (*int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 225 cycles + 23 / matrix_element. The function will saturate the output value if it exceeds maximum limits</p>
<p class="p">per element.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW 2</p>
<p class="p"><strong class="ph b">#define</strong> COL 2</p>
<p class="p">matrix32 *resMat, *srcMat1, *srcMat2;</p>
<p class="p">int32_t result<span class="xref"></span>;</p>
<p class="p">int32_t matA<span class="xref"></span> = {1,2,3,4};</p>
<p class="p">int32_t matB<span class="xref"></span> = {2,4,6,8};</p>
<p class="p">matrix32 mat, mat2, mat3;</p>
<p class="p">resMat=&amp;mat;</p>
<p class="p">srcMat1=&amp;mat2;</p>
<p class="p">srcMat2=&amp;mat3;</p>
<p class="p">srcMat1-&gt;row=ROW;</p>
<p class="p">srcMat1-&gt;col=COL;</p>
<p class="p">srcMat1-&gt;pMatrix=matA;</p>
<p class="p">srcMat2-&gt;col=COL;</p>
<p class="p">srcMat2-&gt;row=ROW;</p>
<p class="p">srcMat2-&gt;pMatrix=matB;</p>
<p class="p">resMat-&gt;row=ROW;</p>
<p class="p">resMat-&gt;col=COL;</p>
<p class="p">resMat-&gt;pMatrix=result;</p>
<p class="p">DSP_MatrixAdd32(resMat, srcMat1, srcMat2);</p>
<p class="p"><em class="ph i">// result<span class="xref"></span> = matA<span class="xref"></span> + matB<span class="xref"></span> = {3,6,9,0xA}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixAdd32</strong> (matrix32 * <strong class="ph b">resMat</strong> , matrix32 * <strong class="ph b">srcMat1</strong> , matrix32 * <strong class="ph b">srcMat2</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixEqual32 Function</strong></p>
<p class="p">Equality of two matrices C = (A).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixEqual32:</p>
<p class="p">void DSP_MatrixEqual32(matrix32 *resMat, matrix32 *srcMat);</p>
<p class="p">Vector copy of all elements from one matrix to another. C is a duplicate of A.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">resMat pointer to completed new Matrix C (*int32_t)</p>
<p class="p">srcMat pointer to the Matrix A structure (*int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 163 cycles + 12 / matrix_element.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW 2</p>
<p class="p"><strong class="ph b">#define</strong> COL 2</p>
<p class="p">matrix32 *resMat, *srcMat1, *srcMat2;</p>
<p class="p">int32_t result<span class="xref"></span>;</p>
<p class="p">int32_t matA<span class="xref"></span> = {5,2,-3,8};</p>
<p class="p">matrix32 mat, mat2;</p>
<p class="p">resMat=&amp;mat;</p>
<p class="p">srcMat1=&amp;mat2;</p>
<p class="p">srcMat1-&gt;row=ROW;</p>
<p class="p">srcMat1-&gt;col=COL;</p>
<p class="p">srcMat1-&gt;pMatrix=matA;</p>
<p class="p">resMat-&gt;row=ROW;</p>
<p class="p">resMat-&gt;col=COL;</p>
<p class="p">resMat-&gt;pMatrix=result;</p>
<p class="p">DSP_MatrixEqual32(resMat, srcMat1, srcMat2);</p>
<p class="p"><em class="ph i">// result<span class="xref"></span> = matA<span class="xref"></span> = {5, 2, -3, 8}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixEqual32</strong> (matrix32 * <strong class="ph b">resMat</strong> , matrix32 * <strong class="ph b">srcMat</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixInit32 Function</strong></p>
<p class="p">Initializes the first N elements of a Matrix to the value num.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixInit32:</p>
<p class="p">void DSP_MatrixInit32(int32_t *data_buffer, int N, int32_t num);</p>
<p class="p">Copy the value num into the first N Matrix elements of data_buffer.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">data_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or it will truncate to the nearest factor of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">data_buffer pointer to the Matrix to be initialized (int32_t<span class="xref"></span>)</p>
<p class="p">N number of elements to be initialized (int32_t)</p>
<p class="p">num value to be initialized into the matrix (int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW 3</p>
<p class="p"><strong class="ph b">#define</strong> COL 3</p>
<p class="p">int32_t numElements = 4; <em class="ph i">// multiple of 4</em></p>
<p class="p">int valueElements = -1;</p>
<p class="p">int32_t matA<span class="xref"></span> = {5,2,-3,8,4,2,-6,8,9};</p>
<p class="p">DSP_MatrixInit32(matA, numElements, valueElements);</p>
<p class="p"><em class="ph i">// matA<span class="xref"></span> = {-1,-1,-1,-1,4,2,-6,8,9}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixInit32</strong> (int32_t * <strong class="ph b">data_buffer</strong> , int  <strong class="ph b">N</strong> , int32_t <strong class="ph b">num</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixMul32 Function</strong></p>
<p class="p">Multiplication of two matrices C = A x B.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixMul32:</p>
<p class="p">void DSP_MatrixMul32(matrix32 *resMat, matrix32 *srcMat1, matrix32 *srcMat2);</p>
<p class="p">Multiplication of two matrices, with inputs and outputs being in fractional Q31 numerical format. The output elements will saturate if the dot product exceeds maximum or minimum fractional values.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Matrices must be aligned such that columns of A = rows of B. resMat must have the format of rows of A, columns of B. All Matrices must be set into structure (ROWS, COLUMNS, vector_pointer).</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">resMat pointer to different Matrix C structure (*int32_t)</p>
<p class="p">srcMat1 pointer to the Matrix A structure (*int32_t)</p>
<p class="p">srcMat2 pointer to the Matrix B structure (*int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 319 cycles + 38 / output matrix_element. The function will saturate the output value if it exceeds maximum limits per element.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW1 3</p>
<p class="p"><strong class="ph b">#define</strong> COL1 2</p>
<p class="p"><strong class="ph b">#define</strong> ROW2 2</p>
<p class="p"><strong class="ph b">#define</strong> COL2 2</p>
<p class="p">matrix32 *resMat, *srcMat1, *srcMat2;</p>
<p class="p">int32_t result<span class="xref"></span>;</p>
<p class="p">int32_t test_MatrixA<span class="xref"></span>=</p>
<p class="p">{</p>
<p class="p">0x40000000,0x20000000, <em class="ph i">// 0.5, 0.25</em></p>
<p class="p">0xD999999A,0x4CCCCCCC, <em class="ph i">// -0.3, 0.6</em></p>
<p class="p">0xC0000000,0x0CCCCCCD <em class="ph i">// -0.5 0.1</em></p>
<p class="p">};</p>
<p class="p">int32_t test_MatrixB<span class="xref"></span>=</p>
<p class="p">{</p>
<p class="p">0x40000000,0x20000000, <em class="ph i">// 0.5, 0.25</em></p>
<p class="p">0x0CCCCCCD,0xCCCCCCCD <em class="ph i">// 0.1, -0.4</em></p>
<p class="p">};</p>
<p class="p">matrix32 mat, mat2, mat3;</p>
<p class="p">resMat=&amp;mat;</p>
<p class="p">srcMat1=&amp;mat2;</p>
<p class="p">srcMat2=&amp;mat3;</p>
<p class="p">srcMat1-&gt;row=ROW1;</p>
<p class="p">srcMat1-&gt;col=COL1;</p>
<p class="p">srcMat1-&gt;pMatrix=test_MatrixA;</p>
<p class="p">srcMat2-&gt;col=COL2;</p>
<p class="p">srcMat2-&gt;row=ROW2;</p>
<p class="p">srcMat2-&gt;pMatrix=test_MatrixB;</p>
<p class="p">resMat-&gt;row=ROW1; <em class="ph i">// note resulting matrix MUST have ROW1 &amp; COL2 format</em></p>
<p class="p">resMat-&gt;col=COL2;</p>
<p class="p">resMat-&gt;pMatrix=result;</p>
<p class="p">DSP_MatrixMul32(resMat, srcMat1, srcMat2);</p>
<p class="p"><em class="ph i">// result<span class="xref"></span> = matA<span class="xref"></span> x matB<span class="xref"></span> =</em></p>
<p class="p"><em class="ph i">// { 0x23333333, 0x03333333 // 0.275, 0.025</em></p>
<p class="p"><em class="ph i">// 0xF47AE147, 0xD7AE147B // -0.9, -0.315</em></p>
<p class="p"><em class="ph i">// 0xE147AE14, 0xEAE147AE } // -0.24, -0.165</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixMul32</strong> (matrix32 * <strong class="ph b">resMat</strong> , matrix32 * <strong class="ph b">srcMat1</strong> , matrix32 * <strong class="ph b">srcMat2</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixScale32 Function</strong></p>
<p class="p">Scales each element of an input buffer (matrix) by a fixed number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixScale32:</p>
<p class="p">void DSP_MatrixScale32(int32_t *data_buffer, int N, int32_t num);</p>
<p class="p">Multiply the first N elements of an input buffer by a fixed scalar num. The resulting value is stored back into the input buffer. N number total samples of the input buffer are processed. All values are in Q31 fractional integer format. The result of calculations is saturated to the MAX32 or MIN32 value if exceeded.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">data_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or will truncate to the nearest factor of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">data_buffer pointer to the Matrix to be initialized (int32_t<span class="xref"></span>)</p>
<p class="p">N number of elements to be initialized (int)</p>
<p class="p">num value to be initialized into the matrix (int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution time (cycles): 190 + 9 cycles / element, typical.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t numScale = 0x40000000; <em class="ph i">// 0.5</em></p>
<p class="p">int valN = 12;</p>
<p class="p">int32_t inputBufScale<span class="xref"></span> = {0x40000000, 0x40000000, 0x20000000, 0x20000000,</p>
<p class="p">0x19999999, 0xCCCCCCCD, 0xF3333333, 0x80000000,</p>
<p class="p">0x7FFFFFFF, 0x00000000, 0x40000000, 0x70000000 };</p>
<p class="p"><em class="ph i">// 0.5, 0.5, 0.25, 0.25, 0.25, 0.2, -0.4, -0.1, -1, 1, 0, 0.5, 0.875</em></p>
<p class="p">DSP_MatrixScale32(inputBufScale,valN,numScale);</p>
<p class="p"><em class="ph i">// inputBufScale<span class="xref"></span> = {0x20000000, 0x20000000, 0x10000000, 0x10000000,</em></p>
<p class="p"><em class="ph i">// 0x0CCCCCCC, 0xE6666666, 0xF9999999, 0xC0000000,</em></p>
<p class="p"><em class="ph i">// 0x3FFFFFFF, 0x00000000, 0x20000000, 0x38000000}</em></p>
<p class="p"><em class="ph i">// 0.25, 0.25, 0.125, 0.125, 0.1, -0.2, -0.05, -0.5, 0.5, 0, 0.25, 0.4375</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixScale32</strong> (int32_t * <strong class="ph b">data_buffer</strong> , int  <strong class="ph b">N</strong> , int32_t <strong class="ph b">num</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixSub32 Function</strong></p>
<p class="p">Subtraction of two matrices C = (A - B).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixSub32:</p>
<p class="p">void DSP_MatrixSub32(matrix32 *resMat, matrix32 *srcMat1, matrix32 *srcMat2);</p>
<p class="p">Vector subtraction of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Both matrices must be equivalent in rows and columns. All Matrices must be set into structure (ROWS, COLUMNS, vector_pointer)</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">resMat pointer to different Matrix C structure (*int32_t)</p>
<p class="p">srcMat1 pointer to the Matrix A structure (*int32_t)</p>
<p class="p">srcMat2 pointer to the Matrix B structure (*int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 222 cycles + 21 / matrix_element. The function will saturate the output value if it exceeds maximum limits per element.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW 2</p>
<p class="p"><strong class="ph b">#define</strong> COL 2</p>
<p class="p">matrix32 *resMat, *srcMat1, *srcMat2;</p>
<p class="p">int32_t result<span class="xref"></span>;</p>
<p class="p">int32_t matA<span class="xref"></span> = {5,2,-3,8};</p>
<p class="p">int32_t matB<span class="xref"></span> = {2,2,2,2};</p>
<p class="p">matrix32 mat, mat2, mat3;</p>
<p class="p">resMat=&amp;mat;</p>
<p class="p">srcMat1=&amp;mat2;</p>
<p class="p">srcMat2=&amp;mat3;</p>
<p class="p">srcMat1-&gt;row=ROW;</p>
<p class="p">srcMat1-&gt;col=COL;</p>
<p class="p">srcMat1-&gt;pMatrix=matA;</p>
<p class="p">srcMat2-&gt;col=COL;</p>
<p class="p">srcMat2-&gt;row=ROW;</p>
<p class="p">srcMat2-&gt;pMatrix=matB;</p>
<p class="p">resMat-&gt;row=ROW;</p>
<p class="p">resMat-&gt;col=COL;</p>
<p class="p">resMat-&gt;pMatrix=result;</p>
<p class="p">DSP_MatrixSub32(resMat, srcMat1, srcMat2);</p>
<p class="p"><em class="ph i">// result<span class="xref"></span> = matA<span class="xref"></span> - matB<span class="xref"></span> = {3,0,-5,6}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixSub32</strong> (matrix32 * <strong class="ph b">resMat</strong> , matrix32 * <strong class="ph b">srcMat1</strong> , matrix32 * <strong class="ph b">srcMat2</strong> );</p>
<p class="p"><strong class="ph b">DSP_MatrixTranspose32 Function</strong></p>
<p class="p">Transpose of a Matrix C = A (T).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_MatrixTranspose32:</p>
<p class="p">void DSP_MatrixTranspose32(matrix32 *desMat, matrix32 *srcMat);</p>
<p class="p">Transpose of rows and columns of a matrix.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Matrix definitions for ROWS and COLS must be transposed prior to the function call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">desMat pointer to transposed new Matrix C (*int32_t)</p>
<p class="p">srcMat pointer to the Matrix A structure (*int32_t)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 210 cycles + 10 / matrix_element.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">#define</strong> ROW 3</p>
<p class="p"><strong class="ph b">#define</strong> COL 4</p>
<p class="p">matrix32 *resMat, *srcMat1;</p>
<p class="p">int32_t result<span class="xref"></span>;</p>
<p class="p">int32_t matA<span class="xref"></span> = { 1, 2, 3, 4,</p>
<p class="p">5, 6, 7, 8,</p>
<p class="p">-1, -3, -5, -7};</p>
<p class="p">matrix32 mat, mat2;</p>
<p class="p">resMat=&amp;mat;</p>
<p class="p">srcMat1=&amp;mat2;</p>
<p class="p">srcMat1-&gt;row=ROW;</p>
<p class="p">srcMat1-&gt;col=COL;</p>
<p class="p">srcMat1-&gt;pMatrix=matA;</p>
<p class="p">resMat-&gt;row=COL; <em class="ph i">// note the shift in columns and rows</em></p>
<p class="p">resMat-&gt;col=ROW;</p>
<p class="p">resMat-&gt;pMatrix=result;</p>
<p class="p">DSP_MatrixTranspose32(resMat, srcMat1);</p>
<p class="p"><em class="ph i">// result<span class="xref"></span> = matA(T)<span class="xref"></span> = { 1, 5, -1,</em></p>
<p class="p"><em class="ph i">// 2, 6, -3,</em></p>
<p class="p"><em class="ph i">// 3, 7, -5,</em></p>
<p class="p"><em class="ph i">// 4, 8, -7}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_MatrixTranspose32</strong> (matrix32 * <strong class="ph b">desMat</strong> , matrix32 * <strong class="ph b">srcMat</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformFFT16 Function</strong></p>
<p class="p">Creates an Fast Fourier Transform (FFT) from a time domain input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformFFT16:</p>
<p class="p">void DSP_TransformFFT16(int16c *dout, int16c *din, int16c *twiddles, int16c *scratch, int log2N);</p>
<p class="p">Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q15) fractional.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be &gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT16_setup</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">dout pointer to complex output array (int16c)</p>
<p class="p">din pointer to complex input array (int16c)</p>
<p class="p">twiddles pointer to an complex array of factors (int16c)</p>
<p class="p">scratch pointer to a complex scratch pad buffer (int16c)</p>
<p class="p">log2N binary exponent of number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int log2N = 8; <em class="ph i">// log2(256) = 8</em></p>
<p class="p">int fftSamples = 256;</p>
<p class="p">int16c *fftDin;</p>
<p class="p">int16c fftDout<span class="xref"></span>;</p>
<p class="p">int16c scratch<span class="xref"></span>;</p>
<p class="p">int16c fftCoefs<span class="xref"></span>;</p>
<p class="p">int16c *fftc;</p>
<p class="p">fftc = &amp;fftCoefs;</p>
<p class="p">DSP_TransformFFT16_setup(fftc, log2N); <em class="ph i">// call setup function</em></p>
<p class="p">while (1)</p>
<p class="p">{</p>
<p class="p">fftDin = &amp;fftin_8Khz_long_window16; <em class="ph i">// get 256 point complex data</em></p>
<p class="p">DSP_TransformFFT16(fftDout, fftDin, fftc, scratch, log2N);</p>
<p class="p"><em class="ph i">// do something with the output, fftDout</em></p>
<p class="p">};</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformFFT16</strong> (int16c * <strong class="ph b">dout</strong> , int16c * <strong class="ph b">din</strong> , int16c * <strong class="ph b">twiddles</strong> , int16c * <strong class="ph b">scratch</strong> , int</p>
<p class="p"><strong class="ph b">log2N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformFFT16_setup Function</strong></p>
<p class="p">Creates FFT coefficients for use in the FFT16 function.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformFFT16_setup:</p>
<p class="p">void DSP_TransformFFT16_setup(int16c *twiddles, int log2N);</p>
<p class="p">Calculates the N twiddle factors required to operate the FFT16 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a</p>
<p class="p">buffer.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">twiddles must be N in length N is calculated (2^log2N)</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">twiddles pointer to a complex array of factors (int16c)</p>
<p class="p">log2N binary exponent of number of data points (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">see DSP_TransformFFT16 for example.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformFFT16_setup</strong> (int16c * <strong class="ph b">twiddles</strong> , int  <strong class="ph b">log2N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformFFT32 Function</strong></p>
<p class="p">Creates an Fast Fourier Transform (FFT) from a time domain input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformFFT32:</p>
<p class="p">void DSP_TransformFFT32(int32c *dout, int32c *din, int32c *twiddles, int32c *scratch, int log2N);</p>
<p class="p">Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q31) fractional.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be &gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT32_setup</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">dout pointer to complex output array (int32c)</p>
<p class="p">din pointer to complex input array (int32c)</p>
<p class="p">twiddles pointer to an complex array of FFT factors (int32c)</p>
<p class="p">scratch pointer to a complex scratch pad buffer (int32c)</p>
<p class="p">log2N binary exponent of number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int log2N = 8; <em class="ph i">// log2(256) = 8</em></p>
<p class="p">int fftSamples = 256;</p>
<p class="p">int32c *fftDin;</p>
<p class="p">int32c fftDout<span class="xref"></span>;</p>
<p class="p">int32c scratch<span class="xref"></span>;</p>
<p class="p">int32c fftCoefs<span class="xref"></span>;</p>
<p class="p">int32c *fftc;</p>
<p class="p">fftc = &amp;fftCoefs;</p>
<p class="p">DSP_TransformFFT32_setup(fftc, log2N); <em class="ph i">// call setup function</em></p>
<p class="p">while (1)</p>
<p class="p">{</p>
<p class="p">fftDin = &amp;fftin_5Khz_long_window32; <em class="ph i">// get 256 point complex data</em></p>
<p class="p">DSP_TransformFFT32(fftDout, fftDin, fftc, scratch, log2N);</p>
<p class="p"><em class="ph i">// do something with the output, fftDout</em></p>
<p class="p">};</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformFFT32</strong> (int32c * <strong class="ph b">dout</strong> , int32c * <strong class="ph b">din</strong> , int32c * <strong class="ph b">twiddles</strong> , int32c * <strong class="ph b">scratch</strong> , int</p>
<p class="p"><strong class="ph b">log2N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformFFT32_setup Function</strong></p>
<p class="p">Creates FFT coefficients for use in the FFT32 function.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformFFT32_setup:</p>
<p class="p">void DSP_TransformFFT32_setup(int32c *twiddles, int log2N);</p>
<p class="p">Calculates the N FFT twiddle factors required to operate the FFT32 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a buffer.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">twiddles must be N in length N is calculated (2^log2N)</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">twiddles pointer to a complex array of coefficients (int32c)</p>
<p class="p">log2N binary exponent of number of data points (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">see DSP_TransformFFT32 for example.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformFFT32_setup</strong> (int32c * <strong class="ph b">twiddles</strong> , int  <strong class="ph b">log2N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformIFFT16 Function</strong></p>
<p class="p">Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformIFFT16:</p>
<p class="p">void DSP_TransformIFFT16(int16c *dout, int16c *din, int16c *twiddles, int16c *scratch, int log2N);</p>
<p class="p">Performs an complex Inverse FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q15) fractional.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be &gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT16_setup</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">dout pointer to complex output array (int16c)</p>
<p class="p">din pointer to complex input array (int16c)</p>
<p class="p">twiddles pointer to an complex array of factors (int16c)</p>
<p class="p">scratch pointer to a complex scratch pad buffer (int16c)</p>
<p class="p">log2N binary exponent of number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. A very similar function to the FFT is executed for the inverse FFT. This requires twiddle factors set in advance with the same method as used in the FFT. Complex conjugate and scaling are handled within the algorithm. The output is scaled using binary shifting based on log2N. Since the algorithm reduces the output by a scale factor of log2N, the resolution is reduced proportionally to the number of data points.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int ilog2N = 10; <em class="ph i">// log2(64) = 6; log2(256) = 8; log2(1024) = 10;</em></p>
<p class="p">int ifftSamples = pow(2,ilog2N);</p>
<p class="p">int16c *ifftDin;</p>
<p class="p">int16c ifftDout<span class="xref"></span>;</p>
<p class="p">int16c iscratch<span class="xref"></span>;</p>
<p class="p">int16c ifftCoefs<span class="xref"></span>;</p>
<p class="p">int16c ifftTimeOut<span class="xref"></span>;</p>
<p class="p"><em class="ph i">// set up twiddle factors, these are used for both FFT and iFFT</em></p>
<p class="p">int16c *ifftc;</p>
<p class="p">ifftc = &amp;ifftCoefs;</p>
<p class="p">DSP_TransformFFT16_setup( ifftc, ilog2N); <em class="ph i">// call to coef setup</em></p>
<p class="p"><em class="ph i">// in this example, we take an FFT of an original time domain (sine wave)</em></p>
<p class="p"><em class="ph i">// the output of the FFT is used as the input of the iFFT for comparison</em></p>
<p class="p">ifftDin = &amp;fftin_800hz_verylong16;</p>
<p class="p">DSP_TransformFFT16(ifftDout, ifftDin, ifftc, iscratch, ilog2N);</p>
<p class="p"><em class="ph i">// ifftDout = frequency domain output, complex number array</em></p>
<p class="p">DSP_TransformIFFT16(ifftTimeOut, ifftDout, ifftc, iscratch, ilog2N);</p>
<p class="p"><em class="ph i">// do something with the output, fftTimeOut, time domain</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformIFFT16</strong> (int16c * <strong class="ph b">dout</strong> , int16c * <strong class="ph b">din</strong> , int16c * <strong class="ph b">twiddles</strong> , int16c * <strong class="ph b">scratch</strong> , int</p>
<p class="p"><strong class="ph b">log2N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Bart16 Function</strong></p>
<p class="p">Perform a Bartlett window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Bart16:</p>
<p class="p">void DSP_TransformWindow_Bart16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.</p>
<p class="p">Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Bartlett Window follows the equation:</p>
<p class="p">Window(n) = 1 - (abs(2*n - N)/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Bart16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0000, 0x1000, 0x2000, 0x3000, 0x4000, 0x3000, 0x2000, 0x1000</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Bart16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Bart32 Function</strong></p>
<p class="p">Perform a Bartlett window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Bart32:</p>
<p class="p">void DSP_TransformWindow_Bart32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.</p>
<p class="p">Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Bartlett Window follows the equation:</p>
<p class="p">Window(n) = 1 - (abs(2*n - N)/N) where n is the window sample number N is the total number of samples The functional output</p>
<p class="p">computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Bart32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0, 0x10000000, 0x20000000, 0x30000000, 0x40000000,</em></p>
<p class="p"><em class="ph i">// 0x30000000, 0x20000000, 0x10000000</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Bart32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Black16 Function</strong></p>
<p class="p">Perform a Blackman window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Black16:</p>
<p class="p">void DSP_TransformWindow_Black16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Blackman Window follows the equation:</p>
<p class="p">Window(n) = 0.42659 - 0.49656 * COS(2<em class="ph i">Pi</em>n/(N-1)) + 0.076849 * COS(4<em class="ph i">Pi</em>n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Black16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0071, 0x0665, 0x1DF1, 0x3B00, 0x3B00, 0x1DF1, 0x0665, 0x0071</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Black16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Black32 Function</strong></p>
<p class="p">Perform a Blackman window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Black32:</p>
<p class="p">void DSP_TransformWindow_Black32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Blackman Window follows the equation:</p>
<p class="p">Window(n) = 0.42659 - 0.49656 * COS(2<em class="ph i">Pi</em>n/(N-1)) + 0.076849 * COS(4<em class="ph i">Pi</em>n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Black32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0070B490, 0x06649680, 0x1DF13240, 0x3B003D80, 0x3B003D80,</em></p>
<p class="p"><em class="ph i">// 0x1DF13240, 0x06649680, 0x0070B490</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Black32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Cosine16 Function</strong></p>
<p class="p">Perform a Cosine (Sine) window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Cosine16:</p>
<p class="p">void DSP_TransformWindow_Cosine16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.</p>
<p class="p">The Cosine Window follows the equation:</p>
<p class="p">Window(n) = SIN(Pi*n/(N-1)) where n is the window sample number N is the total number of samples The functional output</p>
<p class="p">computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Cosine16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0000, 0x1BC5, 0x320A, 0x3E65, 0x3E65, 0x320A, 0x1BC5, 0x0071</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Cosine16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Cosine32 Function</strong></p>
<p class="p">Perform a Cosine (Sine) window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Cosine32:</p>
<p class="p">void DSP_TransformWindow_Cosine32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.</p>
<p class="p">The Cosine Window follows the equation:</p>
<p class="p">Window(n) = SIN(Pi*n/(N-1)) where n is the window sample number N is the total number of samples The functional output</p>
<p class="p">computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Cosine32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x00000000, 0x1BC4C060, 0x32098700, 0x3E653800, 0x3E653800,</em></p>
<p class="p"><em class="ph i">// 0x32098700, 0x1BC4C060, 0x00000000</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Cosine32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Hamm16 Function</strong></p>
<p class="p">Perform a Hamming window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Hamm16:</p>
<p class="p">void DSP_TransformWindow_Hamm16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Hamming Window follows the equation:</p>
<p class="p">Window(n) = 0.54 - 0.46 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Hamm16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x051F, 0x0DBE, 0x228F, 0x3761, 0x4000, 0x3761, 0x228F, 0x0DBE</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Hamm16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Hamm32 Function</strong></p>
<p class="p">Perform a Hamming window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Hamm32:</p>
<p class="p">void DSP_TransformWindow_Hamm32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Hamming Window follows the equation:</p>
<p class="p">Window(n) = 0.54 - 0.46 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples The functional</p>
<p class="p">output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Hamm32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x051EB860, 0x0DBE26C0, 0x228F5C40, 0x37609200, 0x40000000,</em></p>
<p class="p"><em class="ph i">// 0x37609200, 0x228F5C40, 0x0DBE26C0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Hamm32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Hann16 Function</strong></p>
<p class="p">Perform a Hanning window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Hann16:</p>
<p class="p">void DSP_TransformWindow_Hann16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.</p>
<p class="p">The Hanning Window follows the equation:</p>
<p class="p">Window(n) = 0.5 - 0.5 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Hann16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0000, 0x095F, 0x2000, 0x36A1, 0x4000, 0x36A1, 0x2000, 0x095F</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Hann16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Hann32 Function</strong></p>
<p class="p">Perform a Hanning window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Hann32:</p>
<p class="p">void DSP_TransformWindow_Hann32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.</p>
<p class="p">The Hanning Window follows the equation:</p>
<p class="p">Window(n) = 0.5 - 0.5 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples The functional</p>
<p class="p">output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Hann32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x00000000, 0x095F61C0, 0x20000000, 0x36A09E80, 0x40000000,</em></p>
<p class="p"><em class="ph i">// 0x36A09E80, 0x20000000, 0x095F61C0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Hann32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Kaiser16 Function</strong></p>
<p class="p">Perform a Kaiser window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Kaiser16:</p>
<p class="p">void DSP_TransformWindow_Kaiser16(int16_t *OutVector, int16_t *InVector, int N);</p>
<p class="p">Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.</p>
<p class="p">The Kaiser Window follows the equation:</p>
<p class="p">Window(n) = 0.402 - 0.498 * COS(2<em class="ph i">Pi</em>n/N) + 0.098 * cos(4<em class="ph i">Pi</em>n/N) + 0.001 * cos(6<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t OutVector16<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector16<span class="xref"></span>= 0x4000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Kaiser16(OutVector16, InVector16, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x0031, 0x0325, 0x1375, 0x304F, 0x3FCF, 0x304F, 0x1375, 0x0325</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Kaiser16</strong> (int16_t * <strong class="ph b">OutVector</strong> , int16_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWindow_Kaiser32 Function</strong></p>
<p class="p">Perform a Kaiser window on a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWindow_Kaiser32:</p>
<p class="p">void DSP_TransformWindow_Kaiser32(int32_t *OutVector, int32_t *InVector, int N);</p>
<p class="p">Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.</p>
<p class="p">The Kaiser Window follows the equation:</p>
<p class="p">Window(n) = 0.402 - 0.498 * COS(2<em class="ph i">Pi</em>n/N) + 0.098 * cos(4<em class="ph i">Pi</em>n/N) + 0.001 * cos(6<em class="ph i">Pi</em>n/N) where n is the window sample</p>
<p class="p">number N is the total number of samples The functional output computes WinVector(n) = Window(n) * InVector(n)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t OutVector32<span class="xref"></span>={0};</p>
<p class="p">int WindowN = 8;</p>
<p class="p">for (i=0;i&lt;WindowN;i++)</p>
<p class="p">{</p>
<p class="p">InVector32<span class="xref"></span>= 0x40000000; <em class="ph i">// constant 0.5 for functional testing</em></p>
<p class="p">}</p>
<p class="p">DSP_TransformWindow_Kaiser32(OutVector32, InVector32, WindowN);</p>
<p class="p"><em class="ph i">// OutWindow = 0x003126F6, 0x032555C8, 0x1374BCA0, 0x304F66C0, 0x3FCED900,</em></p>
<p class="p"><em class="ph i">// 0x304F66C0, 0x1374BCA0, 0x032555C8</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWindow_Kaiser32</strong> (int32_t * <strong class="ph b">OutVector</strong> , int32_t * <strong class="ph b">InVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Bart16 Function</strong></p>
<p class="p">Create a Bartlett window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Bart16:</p>
<p class="p">void DSP_TransformWinInit_Bart16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Bartlett Window follows</p>
<p class="p">the equation:</p>
<p class="p">Window(n) = 1 - (abs(2*n - N)/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of</p>
<p class="p">significant processing time the window need only be computed once and the multiply of the (window * input) vector done during</p>
<p class="p">recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Bart16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Bart32 Function</strong></p>
<p class="p">Create a Bartlett window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Bart32:</p>
<p class="p">void DSP_TransformWinInit_Bart32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values Q31 fractional format. The Bartlett Window follows the equation:</p>
<p class="p">Window(n) = 1 - (abs(2*n - N)/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Bart32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Black16 Function</strong></p>
<p class="p">Create a Blackman window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Black16:</p>
<p class="p">void DSP_TransformWinInit_Black16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating</p>
<p class="p">point, and rounded for the most accuracy possible. Output values are Q16 fractional format. The Blackman Window follows the equation:</p>
<p class="p">Window(n) = 0.42659 - 0.49656 * COS(2<em class="ph i">Pi</em>n/(N-1)) + 0.076849 * COS(4<em class="ph i">Pi</em>n/(N-1)) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Black16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Black32 Function</strong></p>
<p class="p">Create a Blackman window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Black32:</p>
<p class="p">void DSP_TransformWinInit_Black32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are Q31 fractional format. The Blackman Window follows the equation:</p>
<p class="p">Window(n) = 0.42659 - 0.49656 * COS(2<em class="ph i">Pi</em>n/(N-1)) + 0.076849 * COS(4<em class="ph i">Pi</em>n/(N-1)) where n is the window sample number N is</p>
<p class="p">the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Black32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Cosine16 Function</strong></p>
<p class="p">Create a Cosine (Sine) window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Cosine16:</p>
<p class="p">void DSP_TransformWinInit_Cosine16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Cosine Window follows the equation:</p>
<p class="p">Window(n) = SIN(Pi*n/(N-1)) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Cosine16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Cosine32 Function</strong></p>
<p class="p">Create a Cosine (Sine) window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Cosine32:</p>
<p class="p">void DSP_TransformWinInit_Cosine32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Cosine Window follows the equation:</p>
<p class="p">Window(n) = SIN(Pi*n/(N-1)) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Cosine32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Hamm16 Function</strong></p>
<p class="p">Create a Hamming window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Hamm16:</p>
<p class="p">void DSP_TransformWinInit_Hamm16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hamming Window follows the equation:</p>
<p class="p">Window(n) = 0.54 - 0.46 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Hamm16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Hamm32 Function</strong></p>
<p class="p">Create a Hamming window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Hamm32:</p>
<p class="p">void DSP_TransformWinInit_Hamm32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hamming Window follows the equation:</p>
<p class="p">Window(n) = 0.54 - 0.46 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Hamm32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Hann16 Function</strong></p>
<p class="p">Create a Hanning window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Hann16:</p>
<p class="p">void DSP_TransformWinInit_Hann16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hanning Window follows the equation:</p>
<p class="p">Window(n) = 0.5 - 0.5 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Hann16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Hann32 Function</strong></p>
<p class="p">Create a Hanning window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Hann32:</p>
<p class="p">void DSP_TransformWinInit_Hann32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hanning Window follows the equation:</p>
<p class="p">Window(n) = 0.5 - 0.5 * COS(2<em class="ph i">Pi</em>n/N) where n is the window sample number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Hann32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Kaiser16 Function</strong></p>
<p class="p">Create a Kaiser window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Kaiser16:</p>
<p class="p">void DSP_TransformWinInit_Kaiser16(int16_t *OutWindow, int N);</p>
<p class="p">Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Kaiser Window follows the equation:</p>
<p class="p">Window(n) = 0.402 - 0.498 * COS(2<em class="ph i">Pi</em>n/N) + 0.098 * cos(4<em class="ph i">Pi</em>n/N) + 0.001 * cos(6<em class="ph i">Pi</em>n/N) where n is the window sample</p>
<p class="p">number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Kaiser16</strong> (int16_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_TransformWinInit_Kaiser32 Function</strong></p>
<p class="p">Create a Kaiser window.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_TransformWinInit_Kaiser32:</p>
<p class="p">void DSP_TransformWinInit_Kaiser32(int32_t *OutWindow, int N);</p>
<p class="p">Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Kaiser Window follows the equation:</p>
<p class="p">Window(n) = 0.402 - 0.498 * COS(2<em class="ph i">Pi</em>n/N) + 0.098 * cos(4<em class="ph i">Pi</em>n/N) + 0.001 * cos(6<em class="ph i">Pi</em>n/N) where n is the window sample</p>
<p class="p">number N is the total number of samples</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a positive number. OutWindow must be declared with N elements or larger.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">OutWindow pointer to output array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.</p>
<p class="p">The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window * input) vector done during recurring loop processing.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_TransformWinInit_Kaiser32</strong> (int32_t * <strong class="ph b">OutWindow</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAbs16 Function</strong></p>
<p class="p">Calculate the absolute value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAbs16:</p>
<p class="p">void DSP_VectorAbs16(int16_t *outdata, int16_t *indata, int N);</p>
<p class="p">Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata<span class="xref"></span> filled with the absolute value of elements of indata
<strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of</p>
<p class="p">eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAbs16(pOutdata, inBufTest, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = {5,2,3,4,1,0,2,8}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAbs16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAbs32 Function</strong></p>
<p class="p">Calculate the absolute value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAbs32:</p>
<p class="p">void DSP_VectorAbs32(int32_t *outdata, int32_t *indata, int N);</p>
<p class="p">Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata<span class="xref"></span> filled with N elements of abs(indata<span class="xref"></span>)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAbs32(pOutdata, inBufTest, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = {5,2,3,4,1,0,2,8}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAbs32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAdd16 Function</strong></p>
<p class="p">Calculate the sum of two vectors.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAdd16:</p>
<p class="p">void DSP_VectorAdd16(int16_t *outdata, int16_t *indata1, int16_t *indata2, int N);</p>
<p class="p">Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> + indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int16_t inBuf2<span class="xref"></span>= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAdd16(pOutdata, inBufTest, inBuf2, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> + inBuf2<span class="xref"></span> = {-4,4,0,8,4,6,5,0}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAdd16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata1</strong> , int16_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAdd32 Function</strong></p>
<p class="p">Calculate the sum of two vectors.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAdd32:</p>
<p class="p">void DSP_VectorAdd32(int32_t *outdata, int32_t *indata1, int32_t *indata2, int N);</p>
<p class="p">Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> + indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">N number of samples</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int32_t inBuf2<span class="xref"></span>= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAdd32(pOutdata, inBufTest, inBuf2, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> + inBuf2<span class="xref"></span> = {-4,4,0,8,4,6,5,0}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAdd32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata1</strong> , int32_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAddc16 Function</strong></p>
<p class="p">Calculate the sum of a vector and a constant.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAddc16:</p>
<p class="p">void DSP_VectorAddc16(int16_t *outdata, int16_t *indata, int16_t c, int N);</p>
<p class="p">Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata<span class="xref"></span> filled with N elements of indata<span class="xref"></span> + c</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">c constant value added to all indata1 elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int16_t constValue = 3;</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAddc16(pOutdata, inBufTest, constValue, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> + constValue = {-2,5,0,7,2,3,1,-5}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAddc16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata</strong> , int16_t <strong class="ph b">c</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAddc32 Function</strong></p>
<p class="p">Calculate the sum of a vector and a constant.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAddc32:</p>
<p class="p">void DSP_VectorAddc32(int32_t *outdata, int32_t *indata, int32_t c, int N);</p>
<p class="p">Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> + c</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">c constant value added to all indata1 elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int32_t constValue = 3;</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorAddc32(pOutdata, inBufTest, constValue, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> + constValue = {-2,5,0,7,2,3,1,-5}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAddc32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int32_t <strong class="ph b">c</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorAutocorr16 Function</strong></p>
<p class="p">Computes the Autocorrelation of a Vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorAutocorr16:</p>
<p class="p">void DSP_VectorAutocorr16(int16_t *outCorr, int16_t *inVector, int N, int K);</p>
<p class="p">Calculates the autocorrelation, with a lag of 1 to K, on the first N elements of inVector and returns the 16-bit scalar result in outCorr. The autocorrelation is calculated from other statistical equations including mean and variance. While in some cases these equations exist inside the DSP library, the functions are executed in a serial fashion within this code to provide enhanced performance. The unbiased function has the form -</p>
<p class="p">mean (M) = sum<span class="xref"></span>(x(n) / N) variance (V) = sum<span class="xref"></span>((x(n) - M)^2) / (N-1) autocovariance (ACV)<span class="xref"></span> = sum<span class="xref"></span>((x(n) -</p>
<p class="p">M) * (x(n+k) - M) / (N-k)) autocorrelation (AC)<span class="xref"></span> = CV<span class="xref"></span> / V where N is the number of vector elements, n is the index of those elements x(n) is a single element in the input vector M is the mean of the N elements of the vector k is the lag or series index</p>
<p class="p">The output of the function will return K elements, and the outCorr array should be sized to accept those 16-bit results. The outputs correspond to k=1, k=2, .., k=K delay states. The function returns a 16-bit value in rounded, saturated Q15 format.</p>
<p class="p">Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. outCorr must be an array with at least K values. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outCorr pointer to output array (int16_t)</p>
<p class="p">inVector pointer to source array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p">K lag value, number of output elements (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the _LIBQ_Q16Div specifically.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int autocvN = 16; <em class="ph i">// N value, number of samples in array</em></p>
<p class="p">int autocvLag = 4; <em class="ph i">// Lag value, output shifts to observe</em></p>
<p class="p">int16_t outAC<span class="xref"></span>={0};</p>
<p class="p">int16_t CVIn16<span class="xref"></span> = {0x1999, 0xD99A, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666,</p>
<p class="p">0x3333, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666, 0x3333, 0x1999, 0x0CCC};</p>
<p class="p"><em class="ph i">// = { .2, -.3, .125, .75, .2, .2, .3, .4, .125, .75, .2, .2, .3, .4, .2, .1};</em></p>
<p class="p">DSP_VectorAutocorr16(outAC, CVIn16, autocvN, autocvLag);</p>
<p class="p"><em class="ph i">// outAC = {0xF406, D46C, 0x098F, 0x191A}</em></p>
<p class="p"><em class="ph i">// = -0.093567, -0.34045, 0.07468, 0.19611</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorAutocorr16</strong> (int16_t * <strong class="ph b">outCorr</strong> , int16_t * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">K</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorBexp16 Function</strong></p>
<p class="p">Computes the maximum binary exponent of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorBexp16:</p>
<p class="p">int DSP_VectorBexp16(int16_t *DataIn, int N);</p>
<p class="p">Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q15 fractional data format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">N must be a multiple of 2 and greater or equal to 2.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">DataIn pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Binary exponent <span class="xref"></span> (int)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int valN = 4;</p>
<p class="p">int16_t dummy16<span class="xref"></span>={0x3004, 0x00CC, 0xFC04, 0xFFF0};</p>
<p class="p"><em class="ph i">// 0.375, 0.0062, -0.0311, -0.00049</em></p>
<p class="p">int answer;</p>
<p class="p">answer = DSP_VectorBexp16(dummy16, valN);</p>
<p class="p"><em class="ph i">// answer = 1, maximum binary gain is 2.</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int  <strong class="ph b">DSP_VectorBexp16</strong> (int16_t * <strong class="ph b">DataIn</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorBexp32 Function</strong></p>
<p class="p">Computes the maximum binary exponent of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorBexp32:</p>
<p class="p">int DSP_VectorBexp32(int32_t *DataIn, int N);</p>
<p class="p">Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q31 fractional data format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">DataIn pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Binary exponent <span class="xref"></span> (int)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int valN=4;</p>
<p class="p">int32_t datInput32<span class="xref"></span>={0xFF000000, 0x07000000,0x000CCCCC, 0x08000000};</p>
<p class="p"><em class="ph i">// -0.007183, 0.054688, 0.0003906, 0.0625</em></p>
<p class="p">int answer32;</p>
<p class="p">answer32 = DSP_VectorBexp32(datInput32, valN);</p>
<p class="p"><em class="ph i">// answer = 3, maximum binary gain is 8.</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int  <strong class="ph b">DSP_VectorBexp32</strong> (int32_t * <strong class="ph b">DataIn</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorChkEqu32 Function</strong></p>
<p class="p">Compares two input vectors, returns an integer 1 if equal, and 0 if not equal.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorChkEqu32:</p>
<p class="p">int DSP_VectorChkEqu32(int32_t *indata1, int32_t *indata2, int N);</p>
<p class="p">Compares the first N values of indata1 to the same elements of indata2. The comparison requires that all numbers be in Q31 fractional data format. Returns the integer value 1 if all numbers are equal, and 0 if they are not equal. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input array 1 of elements (int32_t)</p>
<p class="p">indata2 pointer to input array 2 of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">(int) - 1 if vectors are equal, 0 if vectors are not equal</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int outCheck;</p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufTestB<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x80000000, 0x40000000, 0x7FFFFFFF, 0x20000000};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, -1, 0.5, 1, 0.25</em></p>
<p class="p">outCheck = DSP_VectorChkEqu32(inBufTestA, inBufTestB, Num);</p>
<p class="p"><em class="ph i">// outCheck = 1 // true for first 4 numbers of series</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int  <strong class="ph b">DSP_VectorChkEqu32</strong> (int32_t * <strong class="ph b">indata1</strong> , int32_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorCopy Function</strong></p>
<p class="p">Copies the elements of one vector to another.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorCopy:</p>
<p class="p">void DSP_VectorCopy(int32_t *outdata, int32_t *indata, int N);</p>
<p class="p">Fills the first N values of an input vector outdata with the elements from indata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of values (int32_t)</p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufTestB<span class="xref"></span>={0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,</p>
<p class="p">0x40000000, 0x60000000, 0x80000000, 0x20000000};</p>
<p class="p"><em class="ph i">// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25</em></p>
<p class="p">DSP_VectorCopy(inBufTestA, inBufTestB, Num);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,</em></p>
<p class="p"><em class="ph i">// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values copied</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorCopy</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorCopyReverse32 Function</strong></p>
<p class="p">Reverses the order of elements in one vector and copies them into another.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorCopyReverse32:</p>
<p class="p">void DSP_VectorCopyReverse32(int32_t *outdata, int32_t *indata, int N);</p>
<p class="p">Fills the first N values of an input vector Outdata with the reverse elements from INDATA. N must be a multiple of 4 and greater than 4 or will be truncated to the nearest multiple of 4. The vectors are both Q31 fractional format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of values (int32_t)</p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufTestB<span class="xref"></span>={0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,</p>
<p class="p">0x40000000, 0x60000000, 0x80000000, 0x20000000};</p>
<p class="p"><em class="ph i">// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25</em></p>
<p class="p">DSP_VectorCopyReverse32(inBufTestA, inBufTestB, Num);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x0CCCCCCC, 0x40000000, 0x7FFFFFFF, 0x00000000,</em></p>
<p class="p"><em class="ph i">// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334}</em></p>
<p class="p"><em class="ph i">// first 4 values copied reverse order</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorCopyReverse32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorDivC Function</strong></p>
<p class="p">Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorDivC:</p>
<p class="p">void DSP_VectorDivC(_Q16 *outVector, _Q16 *inVector, _Q16 divisor, int N);</p>
<p class="p">Divides each element of the first N elements of inVector by a constant, divisor. The output is stored to outVector. Both vectors and the scalar are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library.</p>
<p class="p">That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q16)</p>
<p class="p">divisor scalar divisor for the input vector (_Q16)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for _LIBQ_Q16Div.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int divNum = 4;</p>
<p class="p">_Q16 divScalar = 0x00020000; <em class="ph i">// 2.0</em></p>
<p class="p">_Q16 inDivVec<span class="xref"></span> = {0x08000000, 0xfffc0000,0x00024000,0x00100000,0x00038000,</p>
<p class="p">0x00400000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 2048, -4, 2.25, 16, 3.5, 64, -2, 5.5</em></p>
<p class="p">_Q16 outDivVec<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorDivC(outDivVec, inDivVec, divScalar, divNum);</p>
<p class="p"><em class="ph i">// outDivVec = 0x04000000, 0xFFFFE0000, 0x00012000, 0x00080000, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 1024.0, -2.0, 1.125, 16.0, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorDivC</strong> (_Q16 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , _Q16 <strong class="ph b">divisor</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorDotp16 Function</strong></p>
<p class="p">Computes the dot product of two vectors, and scales the output by a binary factor.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorDotp16:</p>
<p class="p">int16_t DSP_VectorDotp16(int16_t *indata1, int16_t *indata2, int N, int scale);</p>
<p class="p">Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in Q15 fractional format.</p>
<p class="p">return = 1/(2^scale) * sum(indata1<span class="xref"></span> * indata2<span class="xref"></span>)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of</p>
<p class="p">eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">scale number of bits to shift return right (int)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - scaled output of calculation, Q15 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t inBufMultA<span class="xref"></span>={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int16_t inBufMultB<span class="xref"></span>={0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD};</p>
<p class="p"><em class="ph i">// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1</em></p>
<p class="p">int Num = 8;</p>
<p class="p">int scaleVal = 2;</p>
<p class="p">int16_t outScalar;</p>
<p class="p">int Num = 8;</p>
<p class="p">outScalar = DSP_VectorDotp16(inBufMultA, inBufMultB, Num, scaleVal);</p>
<p class="p"><em class="ph i">// outScalar = 1/(2^scaleVal)*(inBufMultA<span class="xref"></span> dot inBufMultB<span class="xref"></span>) =</em></p>
<p class="p"><em class="ph i">// (1/4) * (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 * 0.20 = 0.05</em></p>
<p class="p"><em class="ph i">// = (int16_t)0x0666</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_VectorDotp16</strong> (int16_t * <strong class="ph b">indata1</strong> , int16_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorDotp32 Function</strong></p>
<p class="p">Computes the dot product of two vectors, and scales the output by a binary factor</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorDotp32:</p>
<p class="p">int32_t DSP_VectorDotp32(int32_t *indata1, int32_t *indata2, int N, int scale);</p>
<p class="p">Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum</p>
<p class="p">values. Scaling is done by binary shifting, after calculation of the result. All calculations are done in Q31 fractional format. return =</p>
<p class="p">1/(2^scale) * sum(indata1<span class="xref"></span> * indata2<span class="xref"></span>)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata1 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">scale number of bits to shift return right (int)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - scaled output of calculation, Q31 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t inBufMultA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufMultB<span class="xref"></span>={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,</p>
<p class="p">0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};</p>
<p class="p"><em class="ph i">// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1</em></p>
<p class="p">int Num = 8;</p>
<p class="p">int scaleVal = 2;</p>
<p class="p">int32_t outScalar;</p>
<p class="p">int Num = 8;</p>
<p class="p">outScalar = DSP_VectorDotp32(inBufMultA, inBufMultB, Num, scaleVal);</p>
<p class="p"><em class="ph i">// outScalar = 1/(2^scaleVal)*(inBufMultA<span class="xref"></span> dot inBufMultB<span class="xref"></span>) =</em></p>
<p class="p"><em class="ph i">// (1/4) * (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 * 0.20 = 0.05</em></p>
<p class="p"><em class="ph i">// = (int32_t)0x06666666</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorDotp32</strong> (int32_t * <strong class="ph b">indata1</strong> , int32_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorExp Function</strong></p>
<p class="p">Computes the EXP (e^x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorExp:</p>
<p class="p">void DSP_VectorExp(_Q16 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the Exp value, e to the power of X, on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Exp and Div functions from the LibQ library. That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q16)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Inclusion of the LibQ header file and library is mandatory to use this function.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int expNum = 4;</p>
<p class="p">_Q16 inExpVec<span class="xref"></span> = {0x00010000, 0xffff0000,0x00020000,0x00030000,0x00038000,</p>
<p class="p">0x00040000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 1.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5</em></p>
<p class="p">_Q16 outExpVec<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorExp(outExpVec, inExpVec, expNum);</p>
<p class="p"><em class="ph i">// outExpVec = 0x0002B7E1, 0x00005E2D, 0x00076399, 0x001415E6, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 2.71828, 0.26787, 7.3891, 20.0855, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorExp</strong> (_Q16 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorFill Function</strong></p>
<p class="p">Fills an input vector with scalar data.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorFill:</p>
<p class="p">void DSP_VectorFill(int32_t *indata, int32_t data, int N);</p>
<p class="p">Fills the first N values of an input vector indata with the value data. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">data scalar value to fill the array (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t fillValue = 0x3FFFFFFF;</p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">DSP_VectorFill(inBufTestA, fillValue, Num);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF,</em></p>
<p class="p"><em class="ph i">// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values filled</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorFill</strong> (int32_t * <strong class="ph b">indata</strong> , int32_t <strong class="ph b">data</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorLn Function</strong></p>
<p class="p">Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorLn:</p>
<p class="p">void DSP_VectorLn(_Q4_11 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the Ln(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q4.11 format, which is a 16-bit integer format with 11 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Ln function from the LibQ library.</p>
<p class="p">That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q4_11)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the</p>
<p class="p">design in order to operate this function. For more information on the Ln function see the LibQ documentation for _LIBQ_Q4_11_ln_Q16. A negative number input will return a saturated negative value (0x8000).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int lnNum = 4;</p>
<p class="p">_Q16 inLnVal<span class="xref"></span> = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,</p>
<p class="p">0x00400000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5</em></p>
<p class="p">_Q4_11 outLnVal<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorLn(outLnVal, inLnVal, lnNum);</p>
<p class="p"><em class="ph i">// outLnVal = 0x4DA2, 0x8000, 0x058C, 0x162E, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 9.704, sat negative, 0.6934, 2.772, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorLn</strong> (_Q4_11 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorLog10 Function</strong></p>
<p class="p">Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorLog10:</p>
<p class="p">void DSP_VectorLog10(_Q3_12 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the Log10(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q3.12 format, which is a 16-bit integer format with 12 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log10 function from the LibQ library. That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q3_12)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log10 function see the LibQ documentation for _LIBQ_Q3_12_log10_Q16. A negative number input will return a saturated negative value (0x8000).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int logNum = 4;</p>
<p class="p">_Q16 inLogVal<span class="xref"></span> = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,</p>
<p class="p">0x00400000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5</em></p>
<p class="p">_Q3_12 outLogVal<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorLog10(outLogVal, inLogVal, logNum);</p>
<p class="p"><em class="ph i">// outLogVal = 0x436E, 0x8000, 0x04D1, 0x1344, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 4.2144, sat negative, 0.3010, 1.2041, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorLog10</strong> (_Q3_12 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorLog2 Function</strong></p>
<p class="p">Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorLog2:</p>
<p class="p">void DSP_VectorLog2(_Q5_10 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the Log2 value, where log2(x) = ln(x) * log2(e), on the first N elements of inVector. The output is stored to outVector.</p>
<p class="p">Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q5.10 format, which is a 16-bit integer format with 10 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log2 function from the LibQ library.</p>
<p class="p">That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q5_10)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log2 function see the LibQ documentation for _LIBQ_Q5_10_log2_Q16. A negative number input will return a saturated negative value (0x8000).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int log2Num = 4;</p>
<p class="p">_Q16 inLog2Val<span class="xref"></span> = {0x40000000, 0xffff0000,0x00020000,0x00030000,0x00038000,</p>
<p class="p">0x00040000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 16384.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5</em></p>
<p class="p">_Q5_10 outLog2Val<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorLog2(outLog2Val, inLog2Val, log2Num);</p>
<p class="p"><em class="ph i">// outLog2Val = 0x3800, 0x8000, 0x0400, 0x0657, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 14.0, sat negative, 1.0, 1.585, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorLog2</strong> (_Q5_10 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMax32 Function</strong></p>
<p class="p">Returns the maximum value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMax32:</p>
<p class="p">int32_t DSP_VectorMax32(int32_t *indata, int N);</p>
<p class="p">Returns the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">(int32_t) - maximum value within the vector, Q31 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t outCheck;</p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">outCheck = DSP_VectorMax32(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// outCheck = 0x7FFFFFFF // first 4 values</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorMax32</strong> (int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMaxIndex32 Function</strong></p>
<p class="p">Returns the index of the maximum value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMaxIndex32:</p>
<p class="p">int DSP_VectorMaxIndex32(int32_t *indata, int N);</p>
<p class="p">Returns the index of the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int - index of the position of the maximum array element</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Index values range from 0 .. (n-1).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int indexValue;</p>
<p class="p">int Num = 8;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">indexValue = DSP_VectorMaxIndex32(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// returnValue = 6 (position corresponding to 0x7FFFFFFF)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int  <strong class="ph b">DSP_VectorMaxIndex32</strong> (int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMean32 Function</strong></p>
<p class="p">Calculates the mean average of an input vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMean32:</p>
<p class="p">int32_t DSP_VectorMean32(int32_t *indata, int N);</p>
<p class="p">Calculates the mean average of the first N elements of the vector indata. The values of indata1 are in Q31 fractional format. The value N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int32_t - mean average value of the vector</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t returnValue;</p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">returnValue = DSP_VectorMean32(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// returnValue = 0x36666666 = (1-1+0.9+0.8)/4 = 0.425</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorMean32</strong> (int32_t * <strong class="ph b">indata1</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMin32 Function</strong></p>
<p class="p">Returns the minimum value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMin32:</p>
<p class="p">int32_t DSP_VectorMin32(int32_t *indata, int N);</p>
<p class="p">Returns the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">(int32_t) - minimum value within the vector, Q31 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t outCheck;</p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">outCheck = DSP_VectorMin32(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// outCheck = 0x80000000 // first 4 values</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorMin32</strong> (int32_t * <strong class="ph b">input</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMinIndex32 Function</strong></p>
<p class="p">Returns the index of the minimum value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMinIndex32:</p>
<p class="p">int DSP_VectorMinIndex32(int32_t *indata, int N);</p>
<p class="p">Returns the relative position index of the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int32_t - mean average value of the vector</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Index values range from 0 .. (n-1).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int indexValue;</p>
<p class="p">int Num = 8;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">indexValue = DSP_VectorMinIndex32(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// returnValue = 1 (position corresponding to 0x80000000)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int  <strong class="ph b">DSP_VectorMinIndex32</strong> (int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMul16 Function</strong></p>
<p class="p">Multiplication of a series of numbers in one vector to another vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMul16:</p>
<p class="p">void DSP_VectorMul16(int16_t *outdata, int16_t *indata1, int16_t *indata2, int N);</p>
<p class="p">Multiples the value of each element of indata1 * indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> * indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufMultA<span class="xref"></span>={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int16_t inBufMultB<span class="xref"></span>={0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD};</p>
<p class="p"><em class="ph i">// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1</em></p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorMul16(pOutdata, inBufMultA, inBufMultB, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> * inBuf2<span class="xref"></span> =</em></p>
<p class="p"><em class="ph i">// {0x0CCD, 0xF333, 0x399A, 0xCCCD, 0xFAE2, 0x2000, 0x0000, 0xF852}</em></p>
<p class="p"><em class="ph i">// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorMul16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata1</strong> , int16_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMul32 Function</strong></p>
<p class="p">Multiplication of a series of numbers in one vector to another vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMul32:</p>
<p class="p">void DSP_VectorMul32(int32_t *outdata, int32_t *indata1, int32_t *indata2, int N);</p>
<p class="p">Multiples the value of each element of indata1 * indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q31 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> * indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufMultA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufMultB<span class="xref"></span>={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,</p>
<p class="p">0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};</p>
<p class="p"><em class="ph i">// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1</em></p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorMul32(pOutdata, inBufMultA, inBufMultB, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> * inBuf2<span class="xref"></span> =</em></p>
<p class="p"><em class="ph i">// {0x0CCCCCCD, 0xF3333333, 0x3999999A, 0xCCCCCCCD, 0xFAE147AE,</em></p>
<p class="p"><em class="ph i">// 0x20000000, 0x00000000, 0xF851EB86}</em></p>
<p class="p"><em class="ph i">// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorMul32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata1</strong> , int32_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMulc16 Function</strong></p>
<p class="p">Multiplication of a series of numbers in one vector to a scalar value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMulc16:</p>
<p class="p">void DSP_VectorMulc16(int16_t *outdata, int16_t *indata, int16_t c, int N);</p>
<p class="p">Multiples the value of each element of indata1 * c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata<span class="xref"></span> filled with N elements of indata<span class="xref"></span> * c</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">c scalar multiplicand (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufMultA<span class="xref"></span>={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x0000, 0xB334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 0, -0.6</em></p>
<p class="p">int16_t constValue = 0x4000;</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorMulc16(pOutdata, inBufMultA, constValue, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> * constValue =</em></p>
<p class="p"><em class="ph i">// {0x4000, 0xC000, 0x399A, 0x3333, 0x1999, 0x2000, 0x0000, 0xD99A}</em></p>
<p class="p"><em class="ph i">// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorMulc16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata</strong> , int16_t <strong class="ph b">c</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorMulc32 Function</strong></p>
<p class="p">Multiplication of a series of numbers in one vector to a scalar value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorMulc32:</p>
<p class="p">void DSP_VectorMulc32(int32_t *outdata, int32_t *indata, int32_t c, int N);</p>
<p class="p">Multiples the value of each element of indata * c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata<span class="xref"></span> filled with N elements of indata<span class="xref"></span> * c</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">c scalar multiplicand (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufMultA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x00000000, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t constValue = 0x4000;</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorMulc32(pOutdata, inBufMultA, constValue, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> * constValue =</em></p>
<p class="p"><em class="ph i">// {0x40000000, 0xC0000000, 0x3999999A, 0x33333333, 0x19999999,</em></p>
<p class="p"><em class="ph i">// 0x20000000, 0x00000000, 0xD999999A}</em></p>
<p class="p"><em class="ph i">// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorMulc32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int32_t <strong class="ph b">c</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorNegate Function</strong></p>
<p class="p">Inverses the sign (negates) the elements of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorNegate:</p>
<p class="p">void DSP_VectorNegate(int32_t *outdata, int32_t *indata, int N);</p>
<p class="p">Sign inversion of the first N values of an indata are assigned to outdata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (int32_t)</p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t outBufTest<span class="xref"></span>={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,</p>
<p class="p">0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};</p>
<p class="p"><em class="ph i">// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1;</em></p>
<p class="p">DSP_VectorNegate(outBufTest, inBufTestA, Num);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x80000000, 0x7FFFFFFF, 0x8CCCCCCD, 0x9999999A,</em></p>
<p class="p"><em class="ph i">// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values neg</em></p>
<p class="p"><em class="ph i">// -1, 1, -0.9, -0.8, -0.2, 0.5, 0, 0.1</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorNegate</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorRecip Function</strong></p>
<p class="p">Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorRecip:</p>
<p class="p">void DSP_VectorRecip(_Q16 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the reciprocal (1/x) on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library.</p>
<p class="p">That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q16)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for _LIBQ_Q16Div.</p>
<p class="p">A value of zero in the array will not cause an error, but will return 0.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int recNum = 4;</p>
<p class="p">_Q16 inRecVec<span class="xref"></span> = {0x08000000, 0xfffc0000,0x00020000,0x00100000,0x00038000,</p>
<p class="p">0x00400000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 2048.0, -4.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5</em></p>
<p class="p">_Q16 outRecVec<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorRecip(outRecVec, inRecVec, recNum);</p>
<p class="p"><em class="ph i">// outRecVec = 0x00000020, 0xFFFFC0000, 0x00008000, 0x00001000, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 0.000488, -0.25, 0.5, 0.0625, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorRecip</strong> (_Q16 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorRMS16 Function</strong></p>
<p class="p">Computes the root mean square (RMS) value of a vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorRMS16:</p>
<p class="p">int16_t DSP_VectorRMS16(int16_t *inVector, int N);</p>
<p class="p">Computes the root mean square value of the first N values of inVector. Both input and output are Q15 fractional values. The function will saturate if maximum or minimum values are exceeded.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - RMS function output, Q15 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and uses the _LIBQ_Q16Sqrt external function call.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t vecRMSIn<span class="xref"></span>={0x1999, 0xD99A, 0x4000, 0x2666,0x1999,0x1999,0x2666, 0x3333};</p>
<p class="p"><em class="ph i">// 0.2, -0.3, 0.5, 0.3, 0.2, 0.2, 0.3, 0.4</em></p>
<p class="p">int16_t RMSOut=0;</p>
<p class="p">int Nrms = 8;</p>
<p class="p">RMSOut = DSP_VectorRMS16(vecRMSIn, Nrms);</p>
<p class="p"><em class="ph i">// RMSOut = 0x287C (= 0.31628)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_VectorRMS16</strong> (int16_t * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorShift Function</strong></p>
<p class="p">Shifts the data index of an input data vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorShift:</p>
<p class="p">void DSP_VectorShift(int32_t *outdata, int32_t *indata, int N, int shift);</p>
<p class="p">Shifts N data elements of indata to outdata, with an index change of shift. The amount of data shifted includes zero padding for</p>
<p class="p">the first (shift) elements if shift is positive. The vector size of indata and outdata need not be the same, however, N must not exceed either array size.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must not exceed the amount of elements in the source array. shift must not exceed the number of elements in the destination array.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (int32_t)</p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p">shift number of indexes to shift (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Destination array values shift to left (relative to the input vector) when shift is positive (back filled with zeros) and shift to the right when shift is negative. The total amount of values copied to the destination array is the length of N less the shift amount.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int shiftValue = 3;</p>
<p class="p">int Num = 8;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int32_t inBufTestB<span class="xref"></span>={0x80000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,</p>
<p class="p">0x40000000, 0x60000000, 0x80000000, 0x20000000};</p>
<p class="p"><em class="ph i">// -1, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25</em></p>
<p class="p">DSP_VectorShift(inBufTestA, inBufTestB, Num, shiftValue);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x00000000, 0x00000000, 0x00000000, 0x80000000,</em></p>
<p class="p"><em class="ph i">// 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC, 0x40000000} // shifted 3 positive</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorShift</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">shift</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorSqrt Function</strong></p>
<p class="p">Computes the square root of the first N elements of inVector, and stores the result in outVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorSqrt:</p>
<p class="p">void DSP_VectorSqrt(_Q16 *outVector, _Q16 *inVector, int N);</p>
<p class="p">Computes the Sqrt(x) on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Sqrt function from the LibQ library.</p>
<p class="p">That library must be compiled as part of the project.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to destination array of elements (_Q16)</p>
<p class="p">indata pointer to source array of elements (_Q16)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Sqrt function see the LibQ documentation for _LIBQ_Q16Sqrt. A negative number input will return a saturated value (0x00FFFFxx).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int sqrtNum = 4;</p>
<p class="p">_Q16 inSqrtVec<span class="xref"></span> = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,</p>
<p class="p">0x00400000,0xfffe0000,0x00058000};</p>
<p class="p"><em class="ph i">// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5</em></p>
<p class="p">_Q16 outSqrtVec<span class="xref"></span> = {0};</p>
<p class="p">DSP_VectorSqrt(outSqrtVec, inSqrtVec, sqrtNum);</p>
<p class="p"><em class="ph i">// outSqrtVec = 0x00800000, 0x00FFFF80, 0x00016A0A, 0x00040000, 0, 0, 0, 0</em></p>
<p class="p"><em class="ph i">// 128.0, sat negative, 1.41422, 4.0, 0, 0, 0, 0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorSqrt</strong> (_Q16 * <strong class="ph b">outVector</strong> , _Q16 * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorStdDev16 Function</strong></p>
<p class="p">Computes the Standard Deviation of a Vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorStdDev16:</p>
<p class="p">int16_t DSP_VectorStdDev16(int16_t *inVector, int N);</p>
<p class="p">Calculates the standard deviation on the first N elements of inVector and returns the 16-bit scalar result. The standard deviation is the square root of the variance, which is a measure of the delta from mean values. The mean value of the vector is computed in</p>
<p class="p">the process. The function has the form -</p>
<p class="p">StdDev = SQRT(sum<span class="xref"></span>((x(i) - M(N))^2) / (N-1)) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector</p>
<p class="p">Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and ha internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p">Dependent on use of the LibQ library.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">inVector pointer to source array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - Standard Deviation of N selected elements</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the _LIBQ_Q16Sqrt specifically.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t vecStDevIn<span class="xref"></span>={0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333};</p>
<p class="p"><em class="ph i">// .2, -.3, .125, .75, .2, .2, .3, .4</em></p>
<p class="p">int16_t StDevOut, Var16Out;</p>
<p class="p">int Nstdev = 4;</p>
<p class="p">StDevOut = DSP_VectorStdDev16(vecStDevIn, Nstdev);</p>
<p class="p"><em class="ph i">// StDevOut = 0x3A9E (= 0.45797)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_VectorStdDev16</strong> (int16_t * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorSub16 Function</strong></p>
<p class="p">Calculate the difference of two vectors.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorSub16:</p>
<p class="p">void DSP_VectorSub16(int16_t *outdata, int16_t *indata1, int16_t *indata2, int N);</p>
<p class="p">Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> - indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int16_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int16_t outVal<span class="xref"></span>;</p>
<p class="p">int16_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int16_t inBuf2<span class="xref"></span>= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorSub16(pOutdata, inBufTest, inBuf2, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> - inBuf2<span class="xref"></span> = {-6,0,-6,0,-6,-6,-9,-16}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorSub16</strong> (int16_t * <strong class="ph b">outdata</strong> , int16_t * <strong class="ph b">indata1</strong> , int16_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorSub32 Function</strong></p>
<p class="p">Calculate the difference of two vectors.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorSub32:</p>
<p class="p">void DSP_VectorSub32(int32_t *outdata, int32_t *indata1, int32_t *indata2, int N);</p>
<p class="p">Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata<span class="xref"></span> filled with N elements of indata1<span class="xref"></span> - indata2<span class="xref"></span></p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">outdata pointer to output array of 16-bit elements (int32_t)</p>
<p class="p">indata1 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">indata2 pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t *pOutdata;</p>
<p class="p">int32_t outVal<span class="xref"></span>;</p>
<p class="p">int32_t inBufTest<span class="xref"></span> = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};</p>
<p class="p">int32_t inBuf2<span class="xref"></span>= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};</p>
<p class="p">int Num = 8;</p>
<p class="p">pOutdata = &amp;outVal;</p>
<p class="p">DSP_VectorSub32(pOutdata, inBufTest, inBuf2, Num);</p>
<p class="p"><em class="ph i">// outVal<span class="xref"></span> = inBufTest<span class="xref"></span> - inBuf2<span class="xref"></span> = {-6,0,-6,0,-6,-6,-9,-16}</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorSub32</strong> (int32_t * <strong class="ph b">outdata</strong> , int32_t * <strong class="ph b">indata1</strong> , int32_t * <strong class="ph b">indata2</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorSumSquares16 Function</strong></p>
<p class="p">Computes the sum of squares of a vector, and scales the output by a binary factor.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorSumSquares16:</p>
<p class="p">int16_t DSP_VectorSumSquares16(int16_t *indata, int N, int scale);</p>
<p class="p">Calculates the sum of the squares of each element of an input vector, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in</p>
<p class="p">Q15 fractional format. return = 1/(2^scale) * sum(indata<span class="xref"></span>^2)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input array of 16-bit elements (int16_t)</p>
<p class="p">scale number of bits to shift return right (int)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - scaled output of calculation, Q15 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t inBufMultA<span class="xref"></span>={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int Num = 8;</p>
<p class="p">int scaleVal = 3;</p>
<p class="p">int16_t outScalar;</p>
<p class="p">outScalar = DSP_VectorSumSquares16(inBufMultA, Num, scaleVal);</p>
<p class="p"><em class="ph i">// outScalar = 1/(2^scaleVal)* sum(inBufMultA<span class="xref"></span>^2) =</em></p>
<p class="p"><em class="ph i">// (1/8) * (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 * 5.1 = 0.6375</em></p>
<p class="p"><em class="ph i">// = (int16_t)0x5199</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_VectorSumSquares16</strong> (int16_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorSumSquares32 Function</strong></p>
<p class="p">Computes the sum of squares of a vector, and scales the output by a binary factor.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorSumSquares32:</p>
<p class="p">int32_t DSP_VectorSumSquares32(int32_t *indata, int N, int scale);</p>
<p class="p">Calculates the sum of the squares of each element of an input vector, and scales the output. The function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after calculation of the results. All calculations are done in Q31 fractional format. return = 1/(2^scale) * sum(indata<span class="xref"></span>^2)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of</p>
<p class="p">four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to input array of 16-bit elements (int32_t)</p>
<p class="p">scale number of bits to shift return right (int)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int32_t - scaled output of calculation, Q15 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This must be assembled with .set microMIPS.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t inBufMultA<span class="xref"></span>={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x00000000, 0xB3333334};</p>
<p class="p"><em class="ph i">// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">int Num = 8;</p>
<p class="p">int scaleVal = 3;</p>
<p class="p">int32_t outScalar;</p>
<p class="p">outScalar = DSP_VectorSumSquares32(inBufMultA, Num, scaleVal);</p>
<p class="p"><em class="ph i">// outScalar = 1/(2^scaleVal)* sum(inBufMultA<span class="xref"></span>^2) =</em></p>
<p class="p"><em class="ph i">// (1/8) * (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 * 5.1 = 0.6375</em></p>
<p class="p"><em class="ph i">// = (int32_t)0x51999999</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorSumSquares32</strong> (int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> , int  <strong class="ph b">scale</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorVari16 Function</strong></p>
<p class="p">Computes the variance of N elements of a Vector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorVari16:</p>
<p class="p">int16_t DSP_VectorVari16(int16_t *inVector, int N);</p>
<p class="p">Calculates the variance on the first N elements of inVector and returns the 16-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -</p>
<p class="p">var = sum<span class="xref"></span>((x(i) - M(N))^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector</p>
<p class="p">Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">inVector pointer to source array of elements (int16_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t - Variance of N selected elements</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int16_t vecStDevIn<span class="xref"></span>={0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333};</p>
<p class="p"><em class="ph i">// .2, -.3, .125, .75, .2, .2, .3, .4</em></p>
<p class="p">int16_t Var16Out;</p>
<p class="p">int Nvar = 4;</p>
<p class="p">Var16Out= DSP_VectorVari16(vecStDevIn, Nvar); <em class="ph i">// 16-bit variance function</em></p>
<p class="p"><em class="ph i">// Var16Out = 0x1AD8 (= 0.20974)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">DSP_VectorVari16</strong> (int16_t * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorVariance Function</strong></p>
<p class="p">Computes the variance of N elements of inVector.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorVariance:</p>
<p class="p">int32_t DSP_VectorVariance(int32_t *inVector, int N);</p>
<p class="p">Calculates the variance on the first N elements of inVector and returns the 32-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -</p>
<p class="p">var = sum<span class="xref"></span>((x(i) - M(N))^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector</p>
<p class="p">Input values of the vector and output scalar value is Q31 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">inVector pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int32_t - Variance of N selected elements</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int varN = 8;</p>
<p class="p">int32_t inVarVec<span class="xref"></span> = {0xE6666667, 0x40000000,0x40000000,0x0CCCCCCC,</p>
<p class="p">0x00000000,0x59999999,0x20000000,0xC0000000};</p>
<p class="p"><em class="ph i">// -0.2, 0.5, 0.5, 0.1, 0, 0.7, 0.25, -0.5</em></p>
<p class="p">int32_t outVar = 0;</p>
<p class="p">outVar = DSP_VectorVariance(inVarVec, varN);</p>
<p class="p"><em class="ph i">// outVar == 0x1490D2A6, = 0.1606696</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">DSP_VectorVariance</strong> (int32_t * <strong class="ph b">inVector</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">DSP_VectorZeroPad Function</strong></p>
<p class="p">Fills an input vector with zeros.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function DSP_VectorZeroPad:</p>
<p class="p">void DSP_VectorZeroPad(int32_t *indata, int N);</p>
<p class="p">Fills the first N values of an input vector indata with the value zero. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result is in Q31 fractional format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">indata pointer to source array of elements (int32_t)</p>
<p class="p">N number of samples (int)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int Num = 4;</p>
<p class="p">int32_t inBufTestA<span class="xref"></span>={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,</p>
<p class="p">0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</p>
<p class="p"><em class="ph i">// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6</em></p>
<p class="p">DSP_VectorZeroPad(inBufTestA, Num);</p>
<p class="p"><em class="ph i">// inBufTestA = {0x00000000, 0x00000000, 0x00000000, 0x00000000,</em></p>
<p class="p"><em class="ph i">// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};</em></p>
<p class="p"><em class="ph i">// 0, 0, 0, 0, 0.2, 0.5, 1, -0.6</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">DSP_VectorZeroPad</strong> (int32_t * <strong class="ph b">indata</strong> , int  <strong class="ph b">N</strong> );</p>
<p class="p"><strong class="ph b">mul16 Function</strong></p>
<p class="p">multiply and shift integer</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int16_t <strong class="ph b">mul16</strong> (int16_t <strong class="ph b">a</strong> , int16_t <strong class="ph b">b</strong> );</p>
<p class="p"><strong class="ph b">mul16r Function</strong></p>
<p class="p">multiply and shift Q15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int16_t <strong class="ph b">mul16r</strong> (int16_t <strong class="ph b">a</strong> , int16_t <strong class="ph b">b</strong> );</p>
<p class="p"><strong class="ph b">mul32 Function</strong></p>
<p class="p">multiply and shift Q31</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int32_t <strong class="ph b">mul32</strong> (int32_t <strong class="ph b">a</strong> , int32_t <strong class="ph b">b</strong> );</p>
<p class="p"><strong class="ph b">SAT16 Function</strong></p>
<p class="p">saturate both positive and negative Q15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int32_t <strong class="ph b">SAT16</strong> (int32_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">SAT16N Function</strong></p>
<p class="p">saturate negative Q15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int32_t <strong class="ph b">SAT16N</strong> (int32_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">SAT16P Function</strong></p>
<p class="p">saturate positive Q15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">static inline</strong> int32_t <strong class="ph b">SAT16P</strong> (int32_t <strong class="ph b">x</strong> );</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title27" id="libq"><h2 class="title topictitle2" id="ariaid-title27">LibQ</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title28" id="libq-fixed-point-math-library"><h3 class="title topictitle3" id="ariaid-title28">LibQ Fixed-Point Math Library</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title29" id="introduction-3"><h3 class="title topictitle3" id="ariaid-title29">Introduction</h3><div class="body"><p class="p">This topic describes the LibQ Fixed-Point Math Library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title30" id="description-8"><h3 class="title topictitle3" id="ariaid-title30">Description</h3><div class="body"><p class="p">The LibQ Fixed-Point Math Library is available for the PIC32MZ family of microcontrollers. This library was created from optimized assembly routines written specifically for devices with microAptiv™ core features.</p>
<p class="p">The LibQ Fixed-Point Math Library simplifies writing fixed point algorithms, supporting Q15, Q31 and other 16-bit and 32-bit data formats. Using the simple, C callable functions contained in the library, fast fixed point mathematical operations can be easily executed. Fixed-point mathematical calculations may replace some functions implemented in the floating point library (math.h),</p>
<p class="p">depending on performance and resolution requirements.</p>
<p class="p">Functions included in the LibQ library include capabilities for trigonometric, power and logarithms, and data conversion. In many cases the functions are identical other than the precision of their operands and the corresponding value that they return.</p>
<p class="p">These functions are implemented in efficient assembly, and generally tuned to optimize performance over code size. In some cases the library breaks out functions that enable one to be optimized for accuracy, while another version is optimized for speed.</p>
<p class="p">These functions such as</p>
<p class="p">_LIBQ_Q2_29_acos_Q31 and _LIBQ_Q2_29_acos_Q31_Fast are otherwise identical and can be used interchangeably. Each of these functions are typically used in computationally intensive real-time applications where execution time is a critical parameter.</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the LibQ Fixed-Point Math Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p"><strong class="ph b">Interface Header File:</strong>  <strong class="ph b">libq.h</strong></p>
<p class="p">The interface to the LibQ Fixed-Point Math Library is defined in the libq.h header file. Any C language source (.c) file that uses</p>
<p class="p">the LibQ Fixed-Point Library should include libq.h.</p>
<p class="p">Library File:</p>
<p class="p">The LibQ Fixed-Point Math Library archive (.a) file is installed with MPLAB Harmony.</p>
<p class="p"><strong class="ph b">Configuring the Library using MHC</strong></p>
<p class="p">Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries, as shown below</p>
<p class="p">The project configuration should now contain the Math Libraries block.</p>
<p class="p">Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title31" id="library-overview-2"><h3 class="title topictitle3" id="ariaid-title31">Library Overview</h3><div class="body"><p class="p">The LibQ Fixed-Point Math Library contains functions for manipulating Q15, Q31 and other intermediate integer representations of real numbers. The Library Interface section details the operation of the data formats and explains each function in detail.</p>
<p class="p">The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the DSP Fixed-Point Math Library.</p>
<p class="p"><strong class="ph b">Library Interface Section Description</strong></p>
<p class="p"><strong class="ph b">Divide Functions</strong></p>
<p class="p">_Q16 fixed point divide function.</p>
<p class="p"><strong class="ph b">Square Root Functions</strong></p>
<p class="p">Square root of a positive _Q16 fixed point value function.</p>
<p class="p"><strong class="ph b">Log Functions</strong></p>
<p class="p">Log calculation functions.</p>
<p class="p"><strong class="ph b">Power Functions</strong></p>
<p class="p">Power calculation functions.</p>
<p class="p"><strong class="ph b">Exponential Functions</strong> Exponential calculation functions.</p>
<p class="p"><strong class="ph b">Sine Functions</strong></p>
<p class="p">Sine calculation functions.</p>
<p class="p"><strong class="ph b">Cosine Functions</strong></p>
<p class="p">Cosine calculation functions.</p>
<p class="p"><strong class="ph b">Target Functions</strong></p>
<p class="p">Target calculation functions.</p>
<p class="p"><strong class="ph b">Arcsin Functions</strong></p>
<p class="p">Arcsin calculation functions.</p>
<p class="p"><strong class="ph b">Arccos Functions</strong></p>
<p class="p">Arccos calculation functions.</p>
<p class="p"><strong class="ph b">Arctan2 Functions</strong></p>
<p class="p">Arctan2 calculation functions.</p>
<p class="p"><strong class="ph b">Random Number Functions</strong></p>
<p class="p">_Q15 and _Q31 pseudo-random value functions.</p>
<p class="p"><strong class="ph b">Float Functions</strong></p>
<p class="p">Float conversion functions.</p>
<p class="p"><strong class="ph b">String Functions</strong></p>
<p class="p">ASCII to _Q15 conversions.</p>
<p class="p">Signed fixed-point types are defined as follows: Qn_m where:</p>
<p class="p">• n is the number of data bits to the left of the radix point</p>
<p class="p">• m is the number of data bits to the right of the radix point</p>
<p class="p">• a signed bit is implied</p>
<p class="p">For convenience, short names are also defined:</p>
<p class="p"><strong class="ph b">Exact Name Number of Bits Required Short Name</strong></p>
<p class="p">_Q0_15 16 _Q15</p>
<p class="p">_Q15_16 16 _Q16</p>
<p class="p">_Q0_31 32 _Q31</p>
<p class="p">Qn_m numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. The range of the numerical value therefore is:</p>
<p class="p">-2<sup class="ph sup">(n-1)</sup> to <span class="xref"></span>; with a resolution of 2(<sup class="ph sup">-m</sup>).</p>
<p class="p">A _Q16 format number (_Q15_16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259</p>
<p class="p">(or 2<sup class="ph sup">-16</sup>). For example, a numerical representation of the number 3.14159 in _Q2_13 notation would be:</p>
<p class="p">3.14159 * 2<sup class="ph sup">13</sup> = 25735.9 =&gt; 0x6488</p>
<p class="p">And converting from the _Q7_8 format with the value 0x1D89 would be:</p>
<p class="p">0x1D89 / 2<sup class="ph sup">8</sup> = 7561 / 256 =&gt; 29.5316, accurate to 0.00391</p>
<p class="p">Functions in the library are prefixed with the type of the return value. For example, _LIBQ_Q16Sqrt returns a _Q16 value equal to the square root of its argument. Argument types do not always match the return type. Refer to the function prototype for a specification of its arguments.</p>
<p class="p">In cases where the return value is not a fixed-point type, the argument type is appended to the function name. For example, _LIBQ_ToFloatQ31 accepts a type _Q31 argument.</p>
<p class="p">In some cases, both the return type and the argument type are specified within the function name. For example:</p>
<p class="p"><strong class="ph b">Function Name Return Type Argument Type</strong></p>
<p class="p">_LIBQ_Q15_sin_Q2_13 _Q15 Q2_13</p>
<p class="p">_LIBQ_Q31_sin_Q2_29 _Q31 _Q2_29</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title32" id="library-interface-3"><h3 class="title topictitle3" id="ariaid-title32">Library Interface</h3><div class="body"><p class="p"><strong class="ph b">Functions</strong></p>
<p class="p"><strong class="ph b">Name Description</strong></p>
<p class="p">_LIBQ_Q15_cos_Q2_13 Calculates the value of cosine(x).</p>
<p class="p">_LIBQ_Q15_sin_Q2_13 Calculates the value of sine(x).</p>
<p class="p">_LIBQ_Q15FromFloat Converts a float to a _Q15 value.</p>
<p class="p">_LIBQ_Q15FromString ASCII to _Q15 conversion.</p>
<p class="p">_LIBQ_Q15Rand Generate a _Q15 random number.</p>
<p class="p">_LIBQ_Q16_tan_Q2_29 Calculates the value of tan(x).</p>
<p class="p">_LIBQ_Q16Div _Q16 fixed point divide.</p>
<p class="p">_LIBQ_Q16Exp Calculates the exponential function e^x.</p>
<p class="p">_LIBQ_Q16Power Calculates the value of x raised to the y power (x^y).</p>
<p class="p">_LIBQ_Q16Sqrt Square root of a positive _Q16 fixed point value.</p>
<p class="p">_LIBQ_Q2_13_acos_Q15 Calculates the value of acos(x).</p>
<p class="p">_LIBQ_Q2_13_asin_Q15 Calculates the asin value of asin(x).</p>
<p class="p">_LIBQ_Q2_13_atan_Q7_8 Calculates the value of atan(x).</p>
<p class="p">_LIBQ_Q2_13_atan2_Q7_8 Calculates the value of atan2(y, x).</p>
<p class="p">_LIBQ_Q2_29_acos_Q31 Calculates the value of acos(x).</p>
<p class="p">_LIBQ_Q2_29_acos_Q31_Fast Calculates the value of acos(x). This function executes faster than</p>
<p class="p">_LIBQ_Q2_29_acos_Q31 but is less precise.</p>
<p class="p">_LIBQ_Q2_29_asin_Q31 Calculates the value of asin(x).</p>
<p class="p">_LIBQ_Q2_29_asin_Q31_Fast Calculates the value of asin(x). This function executes faster than the</p>
<p class="p">_LIBQ_Q2_29_asin_Q31 function, but is less precise.</p>
<p class="p">_LIBQ_Q2_29_atan_Q16 Calculates the value of atan(x).</p>
<p class="p">_LIBQ_Q2_29_atan2_Q16 Calculates the value of atan2(y, x).</p>
<p class="p">_LIBQ_Q3_12_log10_Q16 Calculates the value of Log10(x).</p>
<p class="p">_LIBQ_Q31_cos_Q2_29 Calculates the value of cosine(x).</p>
<p class="p">_LIBQ_Q31_sin_Q2_29 Calculates the value of sine(x).</p>
<p class="p">_LIBQ_Q31FromFloat Converts a float to a _Q31 value.</p>
<p class="p">_LIBQ_Q31Rand Generate a _Q31 random number.</p>
<p class="p">_LIBQ_Q4_11_ln_Q16 Calculates the natural logarithm ln(x).</p>
<p class="p">_LIBQ_Q5_10_log2_Q16 Calculates the value of log2(x).</p>
<p class="p">_LIBQ_Q7_8_tan_Q2_13 Calculates the value of tan(x).</p>
<p class="p">_LIBQ_ToFloatQ15 Converts a _Q15 value to a float.</p>
<p class="p">_LIBQ_ToFloatQ31 Converts a _Q31 value to a float.</p>
<p class="p">_LIBQ_ToStringQ15 _Q15 to ASCII conversion.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">_ <strong class="ph b">Functions</strong> _</p>
<p class="p"><strong class="ph b">_LIBQ_Q15_cos_Q2_13 Function</strong></p>
<p class="p">Calculates the value of cosine(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q15_cos_Q2_13:</p>
<p class="p">_Q15 _LIBQ_Q15_cos_Q2_13 (_Q2_13 x);</p>
<p class="p">Calculates the cosine(x), where x is of type _Q2_13 radians and the resulting value is of type _Q15.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_13 input value from which to calculate cosine(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q15_cos_Q2_13 returns the _Q15 fixed point result from the calculation cosine(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 102 cycles Program Memory 224 bytes</p>
<p class="p">Error &lt;= 0.00003052 (accurate to least significant _Q15 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q15 resultCos;</p>
<p class="p">resultCos = _LIBQ_Q15_cos_Q2_13 ((_Q2_13)0x2171); _// <em class="ph i">LIBQ_Q15_cos_Q2_13(1.045044) = 0.501862</em></p>
<p class="p"><em class="ph i">(0x403d)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q15 <strong class="ph b">_LIBQ_Q15_cos_Q2_13</strong> (_Q2_13 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q15_sin_Q2_13 Function</strong></p>
<p class="p">Calculates the value of sine(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q15_sin_Q2_13:</p>
<p class="p">_Q15 _LIBQ_Q15_sin_Q2_13 (_Q2_13 x);</p>
<p class="p">Calculates the sine(x), where x is of type _Q2_13 radians and the resulting value is of type _Q15.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_13 input value from which to calculate sine(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q15_sin_Q2_13 returns the _Q15 fixed point result from the calculation sine(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 100 typical (100 to 102) Program Memory 220 bytes</p>
<p class="p">Error &lt;= 0.00003052 (accurate to least significant _Q15 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q15 resultSin;</p>
<p class="p">resultSin = _LIBQ_Q15_sin_Q2_13 ((_Q2_13)0x4093); _// <em class="ph i">LIBQ_Q15_sin_Q2_13(2.017944) = 0.901672</em></p>
<p class="p"><em class="ph i">(0x736a)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q15 <strong class="ph b">_LIBQ_Q15_sin_Q2_13</strong> (_Q2_13 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q15FromFloat Function</strong></p>
<p class="p">Converts a float to a _Q15 value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q15FromFloat:</p>
<p class="p">_Q15 _LIBQ_Q15FromFloat(float x);</p>
<p class="p">Converts a floating point value to a _Q15 fixed point representation. The _Q15 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the _Q15 representation.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The float point value to convert to _Q15 fixed point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q15FromFloat returns the _Q15 fixed point value corresponding to the floating point (float) input value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The C library functions __gesf2, __lesf2, __addsf3, __mulsf3, and __fixsfsi are called by this routine and thus must be linked into</p>
<p class="p">the executable image.</p>
<p class="p">Execution Time (cycles): 213 typical (158 to 224) Program Memory 96 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q15 q15;</p>
<p class="p">q15 = _LIBQ_Q15FromFloat(( <strong class="ph b">float</strong> )0.5); _// q15 now equals (<em class="ph i">Q15)0x4000</em></p>
<p class="p">q15 = _LIBQ_Q15FromFloat(( <strong class="ph b">float</strong> )-1.0); _// q15 now equals (<em class="ph i">Q15)0x8000</em></p>
<p class="p">q15 = _LIBQ_Q15FromFloat(( <strong class="ph b">float</strong> )-0.233828); _// q15 now equals (<em class="ph i">Q15)0xe212</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q15 <strong class="ph b">_LIBQ_Q15FromFloat</strong> ( <strong class="ph b">float</strong>  <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q15FromString Function</strong></p>
<p class="p">ASCII to _Q15 conversion.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q15FromString:</p>
<p class="p">_Q15 _LIBQ_Q15FromString(char *s);</p>
<p class="p">Convert an ASCII string into a _Q15 fixed point value. The ASCII string must be in an -N.NNNNNN format. Leading spaces are ignored. The conversion stops at either the first non-conforming character in the string or the Null string terminator. There must be no spaces within the string value itself.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">s A pointer to the ASCII input string representing the _Q15 fixed point value.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q15FromString returns the _Q15 fixed point value represented by the input string.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 296 typical (28 to 346) Program Memory 172 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q15 x;</p>
<p class="p">x = _LIBQ_Q15FromString("0.125"); <em class="ph i">// x will equal 0.125 using</em></p>
<p class="p"><em class="ph i">// an internal value of 0x1000</em></p>
<p class="p">x = _LIBQ_Q15FromString("-1.0"); <em class="ph i">// x will equal -1.0 using</em></p>
<p class="p"><em class="ph i">// an internal value of 0x8000</em></p>
<p class="p">x = _LIBQ_Q15FromString("0.999969"); <em class="ph i">// x will equal 0.999969 using</em></p>
<p class="p"><em class="ph i">// an internal value of 0x7FFF</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q15 <strong class="ph b">_LIBQ_Q15FromString</strong> ( <strong class="ph b">char</strong> * <strong class="ph b">s</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q15Rand Function</strong></p>
<p class="p">Generate a _Q15 random number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q15Rand:</p>
<p class="p">_Q15 _LIBQ_Q15Rand (int64_t *pSeed);</p>
<p class="p">Generates a _Q15 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.</p>
<p class="p">The function updates the *pSeed value each time it is called. The updated *pSeed value must be passed back to the function with each subsequent call.</p>
<p class="p">Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q15Rand returns a random _Q15 value. _LIBQ_Q15Rand also updates the int64_t *pSeed value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 32 Program Memory 92 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// Initialize seed to a constant or random value</em></p>
<p class="p"><strong class="ph b">static</strong> int64_t randomSeed = 0xA71078BE72D4C1F1;</p>
<p class="p">_Q15 randomValue;</p>
<p class="p">randomValue = _LIBQ_Q15Rand(&amp;randomSeed);</p>
<p class="p">...</p>
<p class="p">randomValue = _LIBQ_Q15Rand(&amp;randomSeed);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q15 <strong class="ph b">_LIBQ_Q15Rand</strong> (int64_t * <strong class="ph b">pSeed</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q16_tan_Q2_29 Function</strong></p>
<p class="p">Calculates the value of tan(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q16_tan_Q2_29:</p>
<p class="p">_Q16 _LIBQ_Q16_tan_Q2_29 (_Q2_29 x);</p>
<p class="p">Calculates the tan(x), where x is of type _Q2_29 radians and the resulting value is of type _Q16.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_29 input value from which to calculate tan(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q16_tan_Q2_29 returns the _Q16 fixed point result from the calculation tan(x). The resulting value is saturated.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The functions _LIBQ_Q31_sin_Q2_29, _LIBQ_Q31_cos_Q2_29, and _LIBQ_Q16Div are called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 703 typical (22 to 796) Program Memory 88 bytes</p>
<p class="p">Error &lt;= 0.000015259 (accurate to least significant _Q16 bit for the input range -1.568 .. 1.568) Error rises from 0.0 to 0.065 for</p>
<p class="p">the input range -1.568 .. -1.570765808 and 1.568 .. 1.570765808)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q16 resultTan;</p>
<p class="p">resultTan = _LIBQ_Q16_tan_Q2_29 ((_Q2_29)0x16720c36); _// <em class="ph i">LIBQ_Q16_tan_Q2_29( 0.701421838) =</em></p>
<p class="p"><em class="ph i">0.844726562 (0x0000d840)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q16 <strong class="ph b">_LIBQ_Q16_tan_Q2_29</strong> (_Q2_29 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q16Div Function</strong></p>
<p class="p">_Q16 fixed point divide.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q16Div:</p>
<p class="p">_Q16 _LIBQ_Q16Div (_Q16 dividend, _Q16 divisor);</p>
<p class="p">Quotient (_Q16) = Dividend (_Q16) / Divisor (_Q16).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Divisor must not equal 0.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">dividend The divide operation dividend (_Q16)</p>
<p class="p">divisor The divide operation divisor (_Q16)</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_Q16 quotient of the divide operation</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The _LIBQ_Q16Div operation saturates its result.</p>
<p class="p">Execution Time (cycles): 143 typical (80 to 244) Program Memory 204 bytes</p>
<p class="p">Error &lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q16 quotient, dividend, divisor;</p>
<p class="p">dividend = (_Q16)0x00010000; <em class="ph i">// 1</em></p>
<p class="p">divisor = (_Q16)0x00008000; <em class="ph i">// 0.5</em></p>
<p class="p">quotient = _LIBQ_Q16Div (dividend, divisor);</p>
<p class="p">_// quotient now equals 2; i.e., (<em class="ph i">Q16)0x00020000;</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q16 <strong class="ph b">_LIBQ_Q16Div</strong> (_Q16 <strong class="ph b">dividend</strong> , _Q16 <strong class="ph b">divisor</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q16Exp Function</strong></p>
<p class="p">Calculates the exponential function e^x.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q16Exp:</p>
<p class="p">_Q16 _LIBQ_Q16Exp(_Q16 x);</p>
<p class="p">Calculates the exponential function e^x. The calculation will saturate if the resulting value is outside the range of the _Q16 representation. For x &gt; 10.3972015380859375, the resulting value will be saturated to 0x7fffffff. For x &lt; -10.3972015380859375 the resulting value will be saturated to 0.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The exponent value</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q16Exp returns the _Q16 fixed point result from the calculation e^x.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q16Div is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 170 typical (18 to 292) Program Memory 446 bytes</p>
<p class="p">Error &lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q16 expResult;</p>
<p class="p">expResult = _LIBQ_Q16Exp((_Q16)0x00010000); _// <em class="ph i">LIBQ_Q16Exp(1.000000) = 2.718277 (0x0002b7e1)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q16 <strong class="ph b">_LIBQ_Q16Exp</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q16Power Function</strong></p>
<p class="p">Calculates the value of x raised to the y power (x^y).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q16Power:</p>
<p class="p">_Q16 _LIBQ_Q16Power (_Q16 x, _Q16 y);</p>
<p class="p">Calculates the x raised to the y power. Both x and y are of type _Q16. x must be positive. The calculation will saturate if the resulting value is outside the range of the _Q16 representation.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">x must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q16 input value x from which to calculate x raised to the y.</p>
<p class="p">y The _Q16 input value y from which to calculate x raised to the y.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q16Power returns the _Q16 fixed point result from the calculation x raised to the y.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 882 typical (586 to 1042) Program Memory 1038 bytes</p>
<p class="p">Error &lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q16 resultPower;</p>
<p class="p">resultPower = _LIBQ_Q16Power ((_Q16)0x00020000, (_Q16)0xffff0000); _// <em class="ph i">LIBQ_Q16Power(2.000000,</em></p>
<p class="p"><em class="ph i">-1.000000) = 0.500000 (0x00008000)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q16 <strong class="ph b">_LIBQ_Q16Power</strong> (_Q16 <strong class="ph b">x</strong> , _Q16 <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q16Sqrt Function</strong></p>
<p class="p">Square root of a positive _Q16 fixed point value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q16Sqrt:</p>
<p class="p">_Q16 _LIBQ_Q16Sqrt(_Q16 x);</p>
<p class="p">Calculate the square root of a positive _Q16 fixed point value, and return the _Q16 result.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The input value must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q16 fixed point value input from which to find the square root.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q16Sqrt returns the _Q16 fixed point value which is the square root of the input parameter.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 240 typical (104 to 258) Program Memory 152 bytes</p>
<p class="p">Error &lt;= 0.000015258789 (accurate to least significant _Q16 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q16 squareRoot;</p>
<p class="p">squareRoot = _LIBQ_Q16Sqrt((_Q16)0x01000000); <em class="ph i">// The square root of 256.0 is 16.0 (0x00100000)</em></p>
<p class="p">squareRoot = _LIBQ_Q16Sqrt((_Q16)0x00004000); <em class="ph i">// The square root of 0.25 is 0.5 (0x00008000)</em></p>
<p class="p">squareRoot = _LIBQ_Q16Sqrt((_Q16)0x5851f42d); <em class="ph i">// The square root of 22609.953125 is 150.366074</em></p>
<p class="p"><em class="ph i">(0x00965db7)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q16 <strong class="ph b">_LIBQ_Q16Sqrt</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_13_acos_Q15 Function</strong></p>
<p class="p">Calculates the value of acos(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_13_acos_Q15:</p>
<p class="p">_Q2_13 _LIBQ_Q2_13_acos_Q15 (_Q15 x);</p>
<p class="p">Calculates the acos(x), where x is of type _Q15 and the resulting value is of type _Q2_13. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q15 input value from which to calculate acos(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_13_acos_Q15 returns the _Q2_13 fixed point result from the calculation acos(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q2_13_asin_Q15 is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 588 typical (32 to 666) Program Memory 24 bytes</p>
<p class="p">Error &lt;= 0.00012207 (accurate to least significant _Q2_13 bit)</p>
<p class="p">A higher precision function with equivalent performance exists, see _LIBQ_Q2_29_acos_Q31_Fast</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_13 resultAcos;</p>
<p class="p">resultAcos = _LIBQ_Q2_13_acos_Q15((_Q15)0x2993); _// <em class="ph i">LIBQ_Q2_13_acos_Q15(0.324799) = 1.239990</em></p>
<p class="p"><em class="ph i">(0x27ae)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_13 <strong class="ph b">_LIBQ_Q2_13_acos_Q15</strong> (_Q15 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_13_asin_Q15 Function</strong></p>
<p class="p">Calculates the asin value of asin(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_13_asin_Q15:</p>
<p class="p">_Q2_13 _LIBQ_Q2_13_asin_Q15 (_Q15 x);</p>
<p class="p">Calculates asin(x), where x is of type _Q15 and the resulting value is of type _Q2_13. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q15 input value from which to calculate asin(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_13_asin_Q15 returns the _Q2_13 fixed point result from the calculation asin(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The functions _LIBQ_Q16Sqrt and _LIBQ_Q16Div are called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 578 typical (22 to 656) Program Memory 336 bytes</p>
<p class="p">Error &lt;= 0.00012207 (accurate to least significant _Q2_13 bit)</p>
<p class="p">A higher resolution version of this function exists with equivalent performance, see _LIBQ_Q2_29_asin_Q31_Fast</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_13 resultAsin;</p>
<p class="p">resultAsin = _LIBQ_Q2_13_asin_Q15 ((_Q15)0x3231); _// <em class="ph i">LIBQ_Q2_13_asin_Q15(0.392120) = 0.402954</em></p>
<p class="p"><em class="ph i">(0x0ce5)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_13 <strong class="ph b">_LIBQ_Q2_13_asin_Q15</strong> (_Q15 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_13_atan_Q7_8 Function</strong></p>
<p class="p">Calculates the value of atan(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_13_atan_Q7_8:</p>
<p class="p">_Q2_13 _LIBQ_Q2_13_atan_Q7_8 (_Q7_8 x);</p>
<p class="p">Calculates the atan(x), where x is of type _Q7_8 and the resulting value is of type _Q2_13. The output value will be radians in the</p>
<p class="p">range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q7_8 input value from which to calculate atan(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_13_atan_Q7_8 returns the _Q2_13 fixed point result from the calculation atan(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q2_13_atan2_Q7_8 is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 240 typical (202 to 256) Program Memory 16 bytes</p>
<p class="p">Error &lt;= 0.00012207 (accurate to least significant _Q2_13 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_13 resultAtan;</p>
<p class="p">resultAtan = _LIBQ_Q2_13_atan_Q7_8 ((_Q7_8)0x0097); _// <em class="ph i">LIBQ_Q2_13_atan_Q7_8(0.589844) =</em></p>
<p class="p"><em class="ph i">0.532959 (0x110e)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_13 <strong class="ph b">_LIBQ_Q2_13_atan_Q7_8</strong> (_Q7_8 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_13_atan2_Q7_8 Function</strong></p>
<p class="p">Calculates the value of atan2(y, x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_13_atan2_Q7_8:</p>
<p class="p">_Q2_13 _LIBQ_Q2_13_atan2_Q7_8 (_Q7_8 y, _Q7_8 x);</p>
<p class="p">Calculates the atan2(y, x), where y and x are of type _Q7_8 and the resulting value is of type _Q2_13. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">y The _Q7_8 input value from which to calculate atan2(y, x).</p>
<p class="p">x The _Q7_8 input value from which to calculate atan2(y, x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_13_atan2_Q7_8 returns the _Q2_13 fixed point result from the calculation atan2(y, x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q16Div is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 220 typical (22 to 250) Program Memory 288 bytes</p>
<p class="p">Error &lt;= 0.00012207 (accurate to least significant _Q2_13 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_13 resultAtan2;</p>
<p class="p">resultAtan2 = _LIBQ_Q2_13_atan2_Q7_8 ((_Q7_8)0x589d, (_Q7_8)0xf878); <em class="ph i">//</em></p>
<p class="p">_<em class="ph i">LIBQ_Q2_13_atan2_Q7_8(88.613281, -7.531250) = 1.655518 (0x34fa)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_13 <strong class="ph b">_LIBQ_Q2_13_atan2_Q7_8</strong> (_Q7_8 <strong class="ph b">y</strong> , _Q7_8 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_acos_Q31 Function</strong></p>
<p class="p">Calculates the value of acos(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_acos_Q31:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_acos_Q31 (_Q31 x);</p>
<p class="p">Calculates the acos(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q31 input value from which to calculate acos(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_acos_Q31 returns the _Q2_29 fixed point result from the calculation acos(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The functions _LIBQ_Q2_29_asin_Q31_Fast and _LIBQ_Q31_cos_Q2_29 are called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 3370 typical (70 to 4824) Program Memory 142 bytes</p>
<p class="p">Error &lt;= 0.0000000019 (accurate to least significant _Q2_29 bit for the range -0.9993..0.9993) Error &lt;= 0.0000000355 (accurate to 5th least significant _Q2_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)</p>
<p class="p">A similar function with higher performance and reduced precision exists, see _LIBQ_Q2_29_acos_Q31_Fast</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAcos;</p>
<p class="p">resultAcos = _LIBQ_Q2_29_acos_Q31 ((_Q31)0xee63708c); _// <em class="ph i">LIBQ_Q2_29_acos_Q31(-0.1375903431)</em></p>
<p class="p"><em class="ph i">= 1.7088244837 (0x36aeb0af)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_acos_Q31</strong> (_Q31 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_acos_Q31_Fast Function</strong></p>
<p class="p">Calculates the value of acos(x). This function executes faster than _LIBQ_Q2_29_acos_Q31 but is less precise.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_acos_Q31_Fast:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_acos_Q31_Fast (_Q31 x);</p>
<p class="p">Calculates the acos(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q31 input value from which to calculate acos(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_acos_Q31_Fast returns the _Q2_29 fixed point result from the calculation acos(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q2_29_asin_Q31_Fast is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 517 typical (32 to 1310) Program Memory 28 bytes</p>
<p class="p">Error &lt;= 0.000000911 (accurate to 9 least significant _Q2_29 bits)</p>
<p class="p">A higher precision function with reduced performance exists, see _LIBQ_Q2_29_acos_Q31</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAcos;</p>
<p class="p">resultAcos = _LIBQ_Q2_29_acos_Q31_Fast ((_Q31)0xee63708c); <em class="ph i">//</em></p>
<p class="p">_<em class="ph i">LIBQ_Q2_29_acos_Q31_Fast(-0.1375903431) = 1.7088244837 (0x36aeb0af)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_acos_Q31_Fast</strong> (_Q31 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_asin_Q31 Function</strong></p>
<p class="p">Calculates the value of asin(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_asin_Q31:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_asin_Q31 (_Q31 x);</p>
<p class="p">Calculates the asin(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be in radians the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q31 input value from which to calculate asin(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_asin_Q31 returns the _Q2_29 fixed point result from the calculation asin(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The functions _LIBQ_Q2_29_asin_Q31_Fast and_LIBQ_Q31_sin_Q2_29 are called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 2525 typical (286 to 4330) Program Memory 138 bytes</p>
<p class="p">Error &lt;= 0.0000000019 (accurate to least significant _Q2_29 bit for the range -0.9993..0.9993) Error &lt;= 0.0000000346 (accurate to 5th least significant _Q2_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)</p>
<p class="p">A faster version of this function exists with modestly reduced accuracy, see _LIBQ_Q2_29_asin_Q31_Fast</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAsin;</p>
<p class="p">resultAsin = _LIBQ_Q2_29_asin_Q31 ((_Q31)0x7fe50658); _// <em class="ph i">LIBQ_Q2_29_asin_Q31( 0.9991767816)</em></p>
<p class="p"><em class="ph i">= 1.5302172359 (0x30f78a23)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_asin_Q31</strong> (_Q31 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_asin_Q31_Fast Function</strong></p>
<p class="p">Calculates the value of asin(x). This function executes faster than the _LIBQ_Q2_29_asin_Q31 function, but is less precise.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_asin_Q31_Fast:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_asin_Q31_Fast (_Q31 x);</p>
<p class="p">Calculates the asin(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be in radians the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q31 input value from which to calculate asin(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_asin_Q31_Fast returns the _Q2_29 fixed point result from the calculation asin(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 507 typical (22 to 1300) Program Memory 638 bytes</p>
<p class="p">Error &lt;= 0.000000911 (accurate to 9 least significant _Q2_29 bits)</p>
<p class="p">A higher resolution version of this function exists with reduced performance, see _LIBQ_Q2_29_asin_Q31</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAsin;</p>
<p class="p">resultAsin = _LIBQ_Q2_29_asin_Q31_Fast ((_Q31)0x7fe50658); _// <em class="ph i">LIBQ_Q2_29_asin_Q31_Fast(</em></p>
<p class="p"><em class="ph i">0.9991767816) = 1.5302172359 (0x30f78a23)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_asin_Q31_Fast</strong> (_Q31 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_atan_Q16 Function</strong></p>
<p class="p">Calculates the value of atan(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_atan_Q16:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_atan_Q16 (_Q16 x);</p>
<p class="p">Calculates the atan(x), where x is of type _Q16 and the resulting value is of type _Q2_29. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q16 input value from which to calculate atan(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_atan_Q16 returns the _Q2_29 fixed point result from the calculation atan(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The function _LIBQ_Q2_29_atan2_Q16 is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 354 typical (178 to 360) Program Memory 16 bytes</p>
<p class="p">Error &lt;= 0.000000003 (accurate within one least significant _Q2_29 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAtan;</p>
<p class="p">resultAtan = _LIBQ_Q2_29_atan_Q16 ((_Q16)0x00098b31); _// <em class="ph i">LIBQ_Q2_29_atan_Q16(9.543716) =</em></p>
<p class="p"><em class="ph i">1.466396 (0x2eecb7ee)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_atan_Q16</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q2_29_atan2_Q16 Function</strong></p>
<p class="p">Calculates the value of atan2(y, x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q2_29_atan2_Q16:</p>
<p class="p">_Q2_29 _LIBQ_Q2_29_atan2_Q16 (_Q16 y, _Q16 x);</p>
<p class="p">Calculates the atan(y, x), where y and x are of type _Q16 and the resulting value is of type _Q2_29. The output value will be radians in the range pi &gt;= result &gt;= -pi.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">y The _Q16 input value from which to calculate atan2(y, x).</p>
<p class="p">x The _Q16 input value from which to calculate atan2(y, x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q2_29_atan2_Q16 returns the _Q2_29 fixed point result from the calculation atan2(y, x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The C function __divdi3 is called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 348 typical (20 to 376) Program Memory 464 bytes</p>
<p class="p">Error &lt;= 0.000000003 (accurate within one least significant _Q2_29 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q2_29 resultAtan2;</p>
<p class="p">resultAtan2 = _LIBQ_Q2_29_atan2_Q16 ((_Q16)0xf6276270, x(_Q16)0x34b4b4c0); <em class="ph i">//</em></p>
<p class="p">_<em class="ph i">LIBQ_Q2_29_atan2_Q16(-2520.615479, 13492.706055) = -0.184684 (0xfa1710c7)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q2_29 <strong class="ph b">_LIBQ_Q2_29_atan2_Q16</strong> (_Q16 <strong class="ph b">y</strong> , _Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q3_12_log10_Q16 Function</strong></p>
<p class="p">Calculates the value of Log10(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q3_12_log10_Q16:</p>
<p class="p">_Q3_12 _LIBQ_Q3_12_log10_Q16 (_Q16 x);</p>
<p class="p">Calculates the log10(x), where log10(x) = ln(x) * log10(e). x is of type _Q16 and must be positive. The resulting value is of type _Q3_12.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The input x must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The input value from which to calculate log10(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q3_12_log10_Q16 returns the _Q3_12 fixed point result from the calculation log10(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes</p>
<p class="p">Error &lt;= 0.000244140625 (accurate to least significant _Q3_12 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q3_12 resultLog10;</p>
<p class="p">resultLog10 = _LIBQ_Q3_12_log10_Q16 ((_Q16)0x12ed7d91); _// <em class="ph i">LIBQ_Q3_12_log10_Q16(4845.490494)</em></p>
<p class="p"><em class="ph i">= 3.685303 (0x3af7)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q3_12 <strong class="ph b">_LIBQ_Q3_12_log10_Q16</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q31_cos_Q2_29 Function</strong></p>
<p class="p">Calculates the value of cosine(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q31_cos_Q2_29:</p>
<p class="p">_Q31 _LIBQ_Q31_cos_Q2_29 (_Q2_29 x);</p>
<p class="p">Calculates the cosine(x), where x is of type _Q2_29 radians and the resulting value is of type _Q31.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_29 input value from which to calculate cosine(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q31_cos_Q2_29 returns the _Q31 fixed point result from the calculation sine(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 265 typical (22 to 288) Program Memory 746 bytes</p>
<p class="p">Error &lt;= 0.00000000047 (accurate to least significant _Q31 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q31 resultCos;</p>
<p class="p">resultCos = _LIBQ_Q31_cos_Q2_29 ((_Q2_29)0x07e2e1c2); _// <em class="ph i">LIBQ_Q31_cos_Q2_29( 0.246445540) =</em></p>
<p class="p"><em class="ph i">0.969785686 (0x7c21eff7)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q31 <strong class="ph b">_LIBQ_Q31_cos_Q2_29</strong> (_Q2_29 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q31_sin_Q2_29 Function</strong></p>
<p class="p">Calculates the value of sine(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q31_sin_Q2_29:</p>
<p class="p">_Q31 _LIBQ_Q31_sin_Q2_29 (_Q2_29 x);</p>
<p class="p">Calculates the sine(x), where x is of type _Q2_29 radians and the resulting value is of type _Q31.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_29 input value from which to calculate sine(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q31_sin_Q2_29 returns the _Q31 fixed point result from the calculation sine(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 246 typical (244 to 266) Program Memory 598 bytes</p>
<p class="p">Error &lt;= 0.00000000047 (accurate to least significant _Q31 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q31 resultSin;</p>
<p class="p">resultSin = _LIBQ_Q31_sin_Q2_29 ((_Q2_29)0x5a637cfe); _// <em class="ph i">LIBQ_Q31_sin_Q2_29( 2.824644562) =</em></p>
<p class="p"><em class="ph i">0.311668121 (0x27e4bdb1)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q31 <strong class="ph b">_LIBQ_Q31_sin_Q2_29</strong> (_Q2_29 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q31FromFloat Function</strong></p>
<p class="p">Converts a float to a _Q31 value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q31FromFloat:</p>
<p class="p">_Q31 _LIBQ_Q31FromFloat(float x);</p>
<p class="p">Converts a floating point value to a _Q31 fixed point representation. The _Q31 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the _Q31 representation.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The floating point value to convert to _Q31 fixed point.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q31FromFloat returns the _Q31 fixed point value corresponding to the floating point (float) input value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The C library functions __gesf2, __lesf2, __addsf3, __mulsf3, and __fixsfsi are called by this routine and thus must be linked into the executable image.</p>
<p class="p">Execution Time (cycles): 210 typical (158 to 214) Program Memory 100 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q31 q31;</p>
<p class="p">q31 = _LIBQ_Q31FromFloat(( <strong class="ph b">float</strong> )0.000008); _// q31 now equals (<em class="ph i">Q31)0x00004000</em></p>
<p class="p">q31 = _LIBQ_Q31FromFloat(( <strong class="ph b">float</strong> )-1.0); _// q31 now equals (<em class="ph i">Q31)0x80000000</em></p>
<p class="p">q31 = _LIBQ_Q31FromFloat(( <strong class="ph b">float</strong> )0.690001); _// q31 now equals (<em class="ph i">Q31)0x5851f400</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q31 <strong class="ph b">_LIBQ_Q31FromFloat</strong> ( <strong class="ph b">float</strong>  <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q31Rand Function</strong></p>
<p class="p">Generate a _Q31 random number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q31Rand:</p>
<p class="p">_Q31 _LIBQ_Q31Rand (int64_t *pSeed);</p>
<p class="p">Generates a _Q31 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.</p>
<p class="p">The function updates the *pSeed value each time it is called. The updated *pSeed value must be passed back to the function with each subsequent call.</p>
<p class="p">Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q31Rand returns a pseudo-random _Q31 value. _LIBQ_Q31Rand also updates the int64_t *pSeed value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 32 Program Memory 88 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// Initialize seed to a constant or random value</em></p>
<p class="p"><strong class="ph b">static</strong> int64_t randomSeed = 0x7F18BA710E72D4C1;</p>
<p class="p">_Q31 randomValue;</p>
<p class="p">randomValue = _LIBQ_Q31Rand(&amp;randomSeed);</p>
<p class="p">...</p>
<p class="p">randomValue = _LIBQ_Q31Rand(&amp;randomSeed);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q31 <strong class="ph b">_LIBQ_Q31Rand</strong> (int64_t * <strong class="ph b">pSeed</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q4_11_ln_Q16 Function</strong></p>
<p class="p">Calculates the natural logarithm ln(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q4_11_ln_Q16:</p>
<p class="p">_Q4_11 _LIBQ_Q4_11_ln_Q16 (_Q16 x);</p>
<p class="p">Calculates the natural logarithm ln(x). x is of type _Q16 and must be positive. The resulting value is of type _Q4_11.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The input x must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The input value from which to calculate ln(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q4_11_ln_Q16 returns the _Q4_11 fixed point result from the calculation ln(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes</p>
<p class="p">Error &lt;= 0.00048828 (accurate to least significant _Q4_11 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q4_11 resultLN;</p>
<p class="p">resultLN = _LIBQ_Q4_11_ln_Q16 ((_Q16)0x00004000); _// <em class="ph i">LIBQ_Q4_11_LN_Q16(0.250000) = -1.386230</em></p>
<p class="p"><em class="ph i">(0xf4e9)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q4_11 <strong class="ph b">_LIBQ_Q4_11_ln_Q16</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q5_10_log2_Q16 Function</strong></p>
<p class="p">Calculates the value of log2(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q5_10_log2_Q16:</p>
<p class="p">_Q5_10 _LIBQ_Q5_10_log2_Q16 (_Q16 x);</p>
<p class="p">Calculates the log2(x), where log2(x) = ln(x) * log2(e). x is of type _Q16 and must be positive. The resulting value is of type _Q5_10.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The input x must be positive.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The input value from which to calculate log2(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q5_10_log2_Q16 returns the _Q5_10 fixed point result from the calculation log2(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 227 typical (14 to 268) Program Memory 164 bytes</p>
<p class="p">Error &lt;= 0.0009765625 (accurate to least significant _Q5_10 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q5_10 resultLog2;</p>
<p class="p">resultLog2 = _LIBQ_Q5_10_log2_Q16 ((_Q16)0x40000000); _// <em class="ph i">LIBQ_Q5_10_log2_Q16(16384.000000) =</em></p>
<p class="p"><em class="ph i">14.000000 (0x3800)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q5_10 <strong class="ph b">_LIBQ_Q5_10_log2_Q16</strong> (_Q16 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_Q7_8_tan_Q2_13 Function</strong></p>
<p class="p">Calculates the value of tan(x).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_Q7_8_tan_Q2_13:</p>
<p class="p">_Q7_8 _LIBQ_Q7_8_tan_Q2_13 (_Q2_13 x);</p>
<p class="p">Calculates the tan(x), where x is of type _Q2_13 radians and the resulting value is of type _Q7_8.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q2_13 input value from which to calculate tan(x).</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_Q7_8_tan_Q2_13 returns the _Q7_8 fixed point result from the calculation tan(x).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 288 typical (18 to 346) Program Memory 980 bytes</p>
<p class="p">Error &lt;= 0.00390625 (accurate to least significant _Q7_8 bit)</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">_Q7_8 resultTan;</p>
<p class="p">resultTan = _LIBQ_Q7_8_tan_Q2_13 ((_Q2_13)0x2e20); _// <em class="ph i">LIBQ_Q7_8_tan_Q2_13(1.441406) =</em></p>
<p class="p"><em class="ph i">7.683594 (0x07af)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">_Q7_8 <strong class="ph b">_LIBQ_Q7_8_tan_Q2_13</strong> (_Q2_13 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_ToFloatQ15 Function</strong></p>
<p class="p">Converts a _Q15 value to a float.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_ToFloatQ15:</p>
<p class="p">float _LIBQ_ToFloatQ15(_Q15 x);</p>
<p class="p">Converts a _Q15 fixed point value to a floating point representation. The floating point value is returned by the function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q15 fixed point value to convert to float</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_ToFloatQ15 returns the floating point (float) value corresponding to the _Q15 input value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The C library functions __floatsisf and __divsf3 are called by this routine and thus must be linked in to the executable image.</p>
<p class="p">Execution Time (cycles): 158 typical (54 to 176) Program Memory 28 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">float</strong> f;</p>
<p class="p">f = _LIBQ_ToFloatQ15((_Q15)0x4000); <em class="ph i">// f now equals 0.5</em></p>
<p class="p">f = _LIBQ_ToFloatQ15((_Q15)0x8000); <em class="ph i">// f now equals -1.0</em></p>
<p class="p">f = _LIBQ_ToFloatQ15((_Q15)0xb7ff); <em class="ph i">// f now equals -0.562531</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">float</strong>  <strong class="ph b">_LIBQ_ToFloatQ15</strong> (_Q15 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_ToFloatQ31 Function</strong></p>
<p class="p">Converts a _Q31 value to a float.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_ToFloatQ31:</p>
<p class="p">float _LIBQ_ToFloatQ31(_Q31 x);</p>
<p class="p">Converts a _Q31 fixed point value to a floating point representation. The floating point value is returned by the function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The _Q31 fixed point value to convert to float</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">_LIBQ_ToFloatQ31 returns the floating point (float) value corresponding to the _Q31 input value.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The C library functions __floatsisf and __divsf3 are called by this routine and thus must be linked in to the executable image.</p>
<p class="p">Execution Time (cycles): 163 typical (54 to 176) Program Memory 28 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">float</strong> f;</p>
<p class="p">f = _LIBQ_ToFloatQ31((_Q31)0x00004000); <em class="ph i">// f now equals 0.000008</em></p>
<p class="p">f = _LIBQ_ToFloatQ31((_Q31)0x80000000); <em class="ph i">// f now equals -1.0</em></p>
<p class="p">f = _LIBQ_ToFloatQ31((_Q31)0x5851f42d); <em class="ph i">// f now equals 0.690001</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">float</strong>  <strong class="ph b">_LIBQ_ToFloatQ31</strong> (_Q31 <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">_LIBQ_ToStringQ15 Function</strong></p>
<p class="p">_Q15 to ASCII conversion.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function _LIBQ_ToStringQ15:</p>
<p class="p">void _LIBQ_ToStringQ15(_Q15 x, char *s);</p>
<p class="p">Convert a _Q15 fixed point value to an ASCII string representation in a -N.NNNNNN format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The character string "s" must be at least 10 characters long, including the Null string terminator.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x The fixed point value to be converted into an ASCII string (_Q15)</p>
<p class="p">s A pointer to the output string of at least 10 characters</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">An ASCII string that represents the _Q15 fixed point value in -N.NNNNNN format. The output string will be terminated by a Null</p>
<p class="p">(0x00) character.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Execution Time (cycles): 118 typical (28 to 132) Program Memory 200 bytes</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">char</strong> s<span class="xref"></span>;</p>
<p class="p">_LIBQ_ToStringQ15((_Q15)0x1000, s); <em class="ph i">// s will equal "0.125000"</em></p>
<p class="p">_LIBQ_ToStringQ15((_Q15)0x8000, s); <em class="ph i">// s will equal "-1.000000"</em></p>
<p class="p">_LIBQ_ToStringQ15((_Q15)0x7FFF, s); <em class="ph i">// s will equal "0.999969"</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong>  <strong class="ph b">_LIBQ_ToStringQ15</strong> (_Q15 <strong class="ph b">x</strong> , <strong class="ph b">char</strong> * <strong class="ph b">s</strong> );</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title33" id="libq-c"><h2 class="title topictitle2" id="ariaid-title33">LibQ_c</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title34" id="libq-fixed-point-c-math-library"><h3 class="title topictitle3" id="ariaid-title34">LibQ Fixed-Point "C" Math Library</h3><div class="body"></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title35" id="introduction-4"><h3 class="title topictitle3" id="ariaid-title35">Introduction</h3><div class="body"><p class="p">This topic describes the LibQ Fixed-Point C Math Library.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title36" id="description-9"><h3 class="title topictitle3" id="ariaid-title36">Description</h3><div class="body"><p class="p">The LibQ Fixed-Point C Math Library is written in C and is available for all processors supported by Harmony 3.</p>
<p class="p">The libq_c Fixed-Point Math Library provides fixed-point math functions written in C for portability between core processors. The</p>
<p class="p">library uses signed fixed point types (fractional Q types specified by Qn.m) which are specifed as follows in the library names:</p>
<p class="p">Qndm where:</p>
<p class="p">• n is the number of data bits to the left of the radix point</p>
<p class="p">• m is the number of data bits to the right of the radix point</p>
<p class="p">• a signed bit is implied (unless stated otherwise)</p>
<p class="p">For convenience, short names are also defined for arbitrary scaled fractional types:</p>
<p class="p">• q15 is signed fractional 16 bit value</p>
<p class="p">• q31 is signed fractional 32 bit value</p>
<p class="p">• i16 is signed integer, i.e. Q16d0</p>
<p class="p">In addition, A pseudo floating point 32 bit format (FxQFloat32) is defined that consists of 16 mantissa and a 16 bit exponent (base</p>
<p class="p">2). Functions in the library are prefixed with the type of the return value and followed by argument types (in order):</p>
<p class="p">libq_&lt;result&gt;<em class="ph i">&lt;name&gt;</em>&lt;args&gt;</p>
<p class="p">For example, libq_q1d15_Sin_q10d6 returns a Q1.15 value equal to the to the sine of an angle specified as a Q10.6 value (in degrees between 0 and 360).</p>
<p class="p">For arbitrary scaled types (q15, q16, q31, and q32) the scaling of the result will depend on the function and the scaling of the</p>
<p class="p">arguments. For instance, libq_q15_Add_q15_q15(a,b) will return a scaled value type that is the two input types (which must have</p>
<p class="p">equivalent scaled value type).</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p"><strong class="ph b">Configuring the Library using MHC</strong></p>
<p class="p">Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries, as shown below</p>
<p class="p">The project configuration should now contain the Math Libraries block.</p>
<p class="p">The configuration window (when the block is selected) looks like the following:</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The libq_c functions do not correspond to the libq fixed-point library optimized for the microaptive core processor and written in</p>
<p class="p">asm.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title37" id="library-overview-3"><h3 class="title topictitle3" id="ariaid-title37">Library Overview</h3><div class="body"><p class="p"><strong class="ph b">Table of LIBQ_C math functions:</strong></p>
<p class="p">Sine: libq_q1d15_Sin_q10d6 libq_q20d12_Sin_q20d12 Abs: libq_q15_Abs_q15 libq_q31_Abs_q31</p>
<p class="p">Negate: libq_q15_Negate_q15 libq_q31_Negate_q31 Round: libq_q15_RoundL_q31</p>
<p class="p">Deposit: libq_q31_DepositH_q15 libq_q31_DepositL_q15 Extract: libq_q15_ExtractH_q31 libq_q15_ExtractL_q31 Add:</p>
<p class="p">libq_q15_Add_q15_q15 libq_q31_Add_q31_q31 Subtract: libq_q15_Sub_q15_q15 libq_q31_Sub_q31_q31</p>
<p class="p">Shift(Scale): libq_q15_ShiftLeft_q15_q15 libq_q31_ShiftLeft_q31_q15 libq_q15_ShiftRight_q15_q15</p>
<p class="p">libq_q31_ShiftRight_q31_q15 libq_q15_ShiftRightRound_q15_q15 libq_q31_ShiftRightRound_q31_q15</p>
<p class="p">Multiply: libq_q15_Mult_q15_q15 libq_q15_MultipyR2_q15_q15 libq_q31_Multi_q15_q31 Divide:</p>
<p class="p">libq_q15_DivisionWithSaturation_q15_q15</p>
<p class="p">Multiply-Accumulate: libq_q31_Mac_q31_q15_q15 libq_q15_MacR_q31_q15_q15 Multiply-Subtract: libq_q31_Msu_q31_q15_q15</p>
<p class="p">libq_q15_MsuR_q31_q15_q15 Exponential-Averaging: libq_q15_ExpAvg_q15_q15_q1d15</p>
<p class="p">Table of LIBQ_C conversion functions: Normalize Q value: Fx16Norm Fx32Norm</p>
<p class="p">Float-to-Q value: Fl2Fract16 Fl2Fract32 Fl2FxPnt16 Fl2FxPnt32 Fl2FxPnt Float-To-Integer: Fl2Int16 Fl2Int32</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title38" id="library-interface-4"><h3 class="title topictitle3" id="ariaid-title38">Library Interface</h3><div class="body"><p class="p"><strong class="ph b">Functions</strong></p>
<p class="p"><strong class="ph b">Name Description</strong></p>
<p class="p">CosInDegs Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in</p>
<p class="p">degrees (Q8.6 fixed point)</p>
<p class="p">Fract_10toX_Q15bfp Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_10toX_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_10toX_Q15d16 Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_2toMinusX_Q15 Calculates pow(2,-x) with fixed point math.</p>
<p class="p">Fract_2toX_Q15bfp Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_2toX_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_2toX_Q15d16 Calculates pow(2,x) with fixed point math.</p>
<p class="p">Fract_Convert_Q15bfpToQ15d16 Convert Q15 block floating point to Q15.16 fixed point.</p>
<p class="p">Fract_Convert_Q15bfpToQ31 Convert Q15 block floating point to Q31 fixed point.</p>
<p class="p">Fract_Convert_Q15d16ToQ15bfp Convert from Q15.16 fixed point to Q15 Block Floating Point</p>
<p class="p">Fract_Convert_Q15ToQ15bfp Convert from Q15 fixed point to Q15 Block Floating Point</p>
<p class="p">Fract_InversePower Computes pow(nBase,-nExponent).</p>
<p class="p">Fract_log10fix Calculates fixed point base 10 logarithm using number of fractional bits</p>
<p class="p">specified by precision argument. Log base 10 is calculated using the log</p>
<p class="p">base 2 function Fract_log2fix.</p>
<p class="p">Fract_log2fix Calculates fixed point base 2 logarithm using number of fractional bits</p>
<p class="p">specified by precision argument.</p>
<p class="p">Fract_Power Computes pow(nBase,nExponent) using for loop.</p>
<p class="p">Fract_sqrtQ15 Fixed point Q15 squareroot.</p>
<p class="p">Fract_XminusY_Q15bfp Subtract two Q15 block floating point numbers.</p>
<p class="p">Fract_XoverY_Q15bfp Division x/y as Q15 block floating point.</p>
<p class="p">Fract_XoverY_Q15bfpFromQ15 Calculate ratio of X/Y as Q15s but return result as Q15 block floating</p>
<p class="p">point.</p>
<p class="p">Fract_XoverY_Q15d16FromQ15 Calculates ratio X/Y for two Q15 fixed points</p>
<p class="p">Fract_XplusY_Q15bfp Add two Q15 block floating point numbers.</p>
<p class="p">Fract_XtimesY_Q15 Calculates product of X*Y for Q15 fixed point</p>
<p class="p">Fract_XtimesY_Q15bfp Multiply X times Y, for Q15 block floating point arguments.</p>
<p class="p">Fract_XtimesY_Q15d16 Calculates product of X*Y for Q15.16 fixed point</p>
<p class="p">Fract_XtimesY_Q31 Calculates product of X*Y for Q31 fixed point</p>
<p class="p">Fx16Norm Normalize the 16-bit fractional value.</p>
<p class="p">Fx32Norm Normalize the 32-bit number.</p>
<p class="p">libq_q15_Abs_q15 Saturated Absolute value.</p>
<p class="p">libq_q15_Add_q15_q15 Add two 16-bit 2s-complement fractional values.</p>
<p class="p">libq_q15_DivisionWithSaturation_q15_q15 Fractional division with saturation.</p>
<p class="p">libq_q15_ExpAvg_q15_q15_q1d15 Exponential averaging</p>
<p class="p">libq_q15_ExtractH_q31 Extracts upper 16 bits of input 32-bit fractional value.</p>
<p class="p">libq_q15_ExtractL_q31 Extracts lower 16-bits of input 32-bit fractional value.</p>
<p class="p">Descriptionf Extracts lower 16-bits of input 32-bit fractional value and</p>
<p class="p">returns them as 16-bit fractional value. This is a bit-for-bit extraction of</p>
<p class="p">the bottom 16-bits of the 32-bit input. This function relates to the ETSI</p>
<p class="p">extract_l function.</p>
<p class="p">libq_q15_MacR_q31_q15_q15 Multiply accumulate with rounding.</p>
<p class="p">libq_q15_MsuR_q31_q15_q15 Multiply-Subtraction with rounding</p>
<p class="p">libq_q15_MultiplyR2_q15_q15 fractional multiplication of two 16-bit fractional values giving a 16 bit</p>
<p class="p">rounded result.</p>
<p class="p">libq_q15_Negate_q15 Negate 16-bit 2s-complement fractional value with saturation.</p>
<p class="p">libq_q15_RoundL_q31 Rounds the lower 16-bits of the 32-bit fractional input.</p>
<p class="p">libq_q15_ShiftLeft_q15_i16 Arithmetic Shift of the 16-bit input argument.</p>
<p class="p">libq_q15_ShiftRight_q15_i16 Arithmetic RIGHT Shift on a 16-bit value.</p>
<p class="p">libq_q15_ShiftRightR_q15_i16 Performs an Arithmetic RIGHT Shift on a 16-bit input.</p>
<p class="p">libq_q15_Sub_q15_q15 Subtract two 16-bit 2s-complement fractional values</p>
<p class="p">libq_q1d15_Sin_q10d6 Approximates the sine of an angle.</p>
<p class="p">libq_q20d12_Sin_q20d12 3rd order Polynomial apprx. of a sine function</p>
<p class="p">libq_q31_Abs_q31 Saturated Absolute value.</p>
<p class="p">libq_q31_Add_q31_q31 Add two 32-bit 2s-complement fractional values.</p>
<p class="p">libq_q31_DepositH_q15 Place 16 bits in the upper half of 32 bit word.</p>
<p class="p">libq_q31_DepositL_q15 Place 16 bits in the lower half of 32 bit word.</p>
<p class="p">libq_q31_Mac_q31_q15_q15 Multiply-Accumulate function WITH saturation</p>
<p class="p">libq_q31_Msu_q31_q15_q15 L_msu(a,b,c)</p>
<p class="p">libq_q31_Mult2_q15_q15 fractional multiplication of two 16-bit fractional values.</p>
<p class="p">libq_q31_Multi_q15_q31 Implement 16 bit by 32 bit multiply.</p>
<p class="p">libq_q31_Negate_q31 Negate 32-bit 2s-complement fractional value with saturation.</p>
<p class="p">libq_q31_ShiftLeft_q31_i16 Arithmetic Shift of the 32-bit value.</p>
<p class="p">libq_q31_ShiftRight_q31_i16 Arithmetic RIGHT Shift on a 32-bit value.</p>
<p class="p">libq_q31_ShiftRightR_q31_i16 Arithmetic RIGHT Shift on a 32-bit value</p>
<p class="p">libq_q31_Sub_q31_q31 Subtract two 32-bit 2s-complement fractional values</p>
<p class="p">LUTwInterpolation_Q15 Calculates calculates y = f(x) based on a lookup table with linear</p>
<p class="p">interpolation between table entries.</p>
<p class="p">SinInDegs Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in</p>
<p class="p">degrees (Q8.6 fixed point)</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">_ <strong class="ph b">Functions</strong> _</p>
<p class="p"><strong class="ph b">CosInDegs Function</strong></p>
<p class="p">fract_q0d15_t CosInDegs( fract_q9d6_t theta );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">theta Q9.6 fixed point angle</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">cos(theta) in Q0.15 fixed point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">CosInDegs uses SinInDegs.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t nTests = 400;</p>
<p class="p"><strong class="ph b">float</strong> theta;</p>
<p class="p"><strong class="ph b">float</strong> delta_theta = 360.0/(nTests-1);</p>
<p class="p"><strong class="ph b">float</strong> theta0 = 0;</p>
<p class="p">int32_t i;</p>
<p class="p">int32_t x;</p>
<p class="p">for ( i = 0; i &lt; nTests; i++ )</p>
<p class="p">{</p>
<p class="p">theta = theta0 + i*delta_theta;</p>
<p class="p">x = theta*(32768/512); <em class="ph i">//Q9.6</em></p>
<p class="p">printf("%d, %d rn",( int )x,CosInDegs(x));</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q0d15_t <strong class="ph b">CosInDegs</strong> (fract_q9d6_t <strong class="ph b">theta</strong> );</p>
<p class="p"><strong class="ph b">Fract_10toX_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_10toX_Q15bfp( fract_q15bfp_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, with x as Q15 block floating point, returning the result in the same format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent, in Q15 block floating point format</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x), in Q15 block floating point format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Fract_10toX(x) is basically Fract_2toX( log2(10)*x ).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15bfp_t X,Y;</p>
<p class="p">X.m = 0x4000; <em class="ph i">// 1/2</em></p>
<p class="p">X.e = 0;</p>
<p class="p">Y = Fract_10toX_Q15bfp(X);</p>
<p class="p"><em class="ph i">// Y.m = 0x6532 = 25906</em></p>
<p class="p"><em class="ph i">// Y.e = 2</em></p>
<p class="p"><em class="ph i">// Y = ( 25906 / 32768 )&lt;&lt;2 = 3.162353 (vs. 3.162277) , rel error = 1/41688</em></p>
<p class="p">X.m = 0x6488; <em class="ph i">// (3.14159/4)</em></p>
<p class="p">X.e = 2;</p>
<p class="p">Y = Fract_10toX_Q15bfp(X);</p>
<p class="p"><em class="ph i">// Y.m = 0x5697 = 22167 / 32768 = 0.676483</em></p>
<p class="p"><em class="ph i">// Y.e = 0x000B = 11</em></p>
<p class="p"><em class="ph i">// Y = (22167 / 32768)&lt;&lt;11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_10toX_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_10toX_Q15bfpFromQ15d16 Function</strong></p>
<p class="p">fract_q15bfp_t Fract_10toX_Q15bfpFromQ15d16( fract_q15d16_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent as Q15.16</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x) as Q15 block floating point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Fract_10toX(x) is basically Fract_2toX( log2(10)*x ).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15bfp_t Y;</p>
<p class="p">x = 0x00008000; <em class="ph i">// 0.5</em></p>
<p class="p">Y = Fract_10toX_Q15bfpFromQ15d16(x);</p>
<p class="p"><em class="ph i">// Y.m = 0x6532 = 25906</em></p>
<p class="p"><em class="ph i">// Y.e = 2</em></p>
<p class="p"><em class="ph i">// Y = ( 25906 / 32768 )&lt;&lt;2 = 3.162353 (vs. 3.162277) , rel error = 1/41688</em></p>
<p class="p">x = 0x0003243F; <em class="ph i">// 205,887 / 65536 = 3.141586 (vs. 3.14159)</em></p>
<p class="p">Y = Fract_10toX_Q15bfpFromQ15d16(x);</p>
<p class="p"><em class="ph i">// Y.m = 0x5696 = 22167 / 32768 = 0.676483</em></p>
<p class="p"><em class="ph i">// Y.e = 0x000B = 11</em></p>
<p class="p"><em class="ph i">// Y = (22167 / 32768)&lt;&lt;11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_10toX_Q15bfpFromQ15d16</strong> (fract_q15d16_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_10toX_Q15d16 Function</strong></p>
<p class="p">fract_q15d16_t Fract_10toX_Q15d16( fract_q15d16_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15.16.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent as Q15.16</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x) as Q15.16</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Fract_10toX(x) is basically Fract_2toX( log2(10)*x ).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x,y;</p>
<p class="p">x = 0x00008000; <em class="ph i">// 0.5</em></p>
<p class="p">y = Fract_10toX_Q15d16(x);</p>
<p class="p"><em class="ph i">// y = 0x0003 2990 = 207,248/65536 = 3.162353 (vs. 3.162277) , rel error = 1/41688</em></p>
<p class="p">x = 0x0003243F; <em class="ph i">// 205,887 / 65536 = 3.141586 (vs. 3.14159)</em></p>
<p class="p">y = Fract_10toX_Q15d16(x);</p>
<p class="p"><em class="ph i">// y = 0x0569 6000 = 90,791,936/65536 = 1385.375 (vs. 1385.435475) , rel error = 1/22909</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15d16_t <strong class="ph b">Fract_10toX_Q15d16</strong> (fract_q15d16_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_2toMinusX_Q15 Function</strong></p>
<p class="p">fract_q15_t Fract_2toMinusX_Q15( fract_q15_t x );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,-x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,-x) with fixed point math, using three term Taylor Series and 256 entry lookup table.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Exponent in calculating 2^-x. If x &lt; 0 then -x is used.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Value of pow(2,-x)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If 0 &lt;= x &lt; 1, then pow(2,-x) is in the range 0.5 &lt; pow(2,-x) &lt;= 1.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x,y;</p>
<p class="p">x = 3277; <em class="ph i">// 0.1</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.1) = 0.933033 = 30574 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x776D = 30573</em></p>
<p class="p">x = 6554; <em class="ph i">// 0.2</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.2) = 0.870551 = 28526 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x6F6E = 28526</em></p>
<p class="p">x = 9830; <em class="ph i">// 0.3</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.3) = 0.812252 = 26616 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x67F9 = 26617</em></p>
<p class="p">x = 13107; <em class="ph i">// 0.4</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.4) = 0.757858 = 24834 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x6102 = 24834</em></p>
<p class="p">x = 16384; <em class="ph i">// 0.5</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.5) = 0.707107 = 23170 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x5A81 = 23169</em></p>
<p class="p">x = 3277 + 16384; <em class="ph i">// 0.1 + 0.5 = 0.6</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,0.6) = 0.659754 = 21619 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x5472 = 21618</em></p>
<p class="p">x = 6554 + 16384; <em class="ph i">// 0.2 + 0.5 = 0.7</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.7) = 0.615572 = 20171 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x4ECA = 20170</em></p>
<p class="p">x = 9830 + 16384; <em class="ph i">// 0.3 + 0.5 = 0.8</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.8) = 0.574349 = 18820 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x4984 = 18820</em></p>
<p class="p">x = 13107 + 16384; <em class="ph i">// 0.4 + 0.5 = 0.9</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-0.9) = 0.535887 = 17560 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x4498 = 17560</em></p>
<p class="p">x = 32767; <em class="ph i">// 0.5 + 0.5 = 1.0</em></p>
<p class="p">y = Fract_2toMinusX_Q15(x);</p>
<p class="p"><em class="ph i">// pow(2,-1.0) = 0.5 = 16384 / 32768</em></p>
<p class="p"><em class="ph i">// y = 0x4001 = 16385</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15_t <strong class="ph b">Fract_2toMinusX_Q15</strong> (fract_q15_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_2toX_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_2toX_Q15bfp( fract_q15bfp_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, from Q15 block floating point x, returning Q15 block floating point result.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">none.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent, in Q15 block floating point format</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x), in Q15 block floating point format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15bfp_t x, y;</p>
<p class="p">x.m = 16384; <em class="ph i">// 0.5</em></p>
<p class="p">x.e = 0;</p>
<p class="p">y = Fract_2toX_Q15bfp(x);</p>
<p class="p"><em class="ph i">// pow(2,0.5) = sqrt(2) = 46341/32768;</em></p>
<p class="p"><em class="ph i">// y.m = 0x5A85 = 23173</em></p>
<p class="p"><em class="ph i">// y.e = 1</em></p>
<p class="p"><em class="ph i">// y = (23173/32768)&lt;&lt;1 = 1.414368 (vs. 1.414214)</em></p>
<p class="p">x.m = 24576; <em class="ph i">// 0.75</em></p>
<p class="p">x.e = 0;</p>
<p class="p">y = Fract_2toX_Q15bfp(x);</p>
<p class="p"><em class="ph i">// pow(2,0.75) = 1.681793 = 55109/32768;</em></p>
<p class="p"><em class="ph i">// y.m = 0x6BA4 = 27556</em></p>
<p class="p"><em class="ph i">// y.e = 1</em></p>
<p class="p"><em class="ph i">// y = (27556/32768)&lt;&lt;1 = 1.681885 (vs. 1.681793)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_2toX_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_2toX_Q15bfpFromQ15d16 Function</strong></p>
<p class="p">fract_q15bfp_t Fract_2toX_Q15bfpFromQ15d16( fract_q15d16_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, based on input in Q15.16 format, returning result in Q15 block floating point format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent, in Q15.16 format</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x), in Q15 block floating point format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x;</p>
<p class="p">fract_q15bfp_t Y;</p>
<p class="p">x = 0x00008000; <em class="ph i">// 0.5 in Q15.16</em></p>
<p class="p">Y = Fract_2toX_Q15bfpFromQ15d16(x);</p>
<p class="p"><em class="ph i">// pow(2,0.5) = sqrt(2) = 1.414213 = 46341 / 32768 = 0x5A82&lt;&lt;1</em></p>
<p class="p"><em class="ph i">// Y.m = 0x5A85 = 23173</em></p>
<p class="p"><em class="ph i">// Y.e = 1</em></p>
<p class="p"><em class="ph i">// Y = ( 23173 / 32768 )&lt;&lt;1 = 1.414367 (vs. 1.414213)</em></p>
<p class="p">x = 0x00014000; <em class="ph i">// 1.25 in Q15.16</em></p>
<p class="p">Y = Fract_2toX_Q15bfpFromQ15d16(x);</p>
<p class="p"><em class="ph i">// pow(2,1.25) = 2.378414 = 77936 / 32768 = 0x4C1C&lt;&lt;2</em></p>
<p class="p"><em class="ph i">// Y.m = 0x4C1 = 19484</em></p>
<p class="p"><em class="ph i">// Y.e = 2</em></p>
<p class="p"><em class="ph i">// Y = ( 19484/32768 ) &lt;&lt; 2 = 2.378418 (vs. 2.378414)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_2toX_Q15bfpFromQ15d16</strong> (fract_q15d16_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_2toX_Q15d16 Function</strong></p>
<p class="p">fract_q15d16_t Fract_2toX_Q15d16( fract_q15d16_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates pow(2,x) with fixed point math.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates pow(2,x) using fixed point math, with Q15.16 x, returning Q15.16 result</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x exponent, in Q15.16 format</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(2,x), in Q15.16 format</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x,y;</p>
<p class="p">x = 0x00008000; <em class="ph i">// 0.5 in Q15.16</em></p>
<p class="p">y = Fract_2toX_Q15d16(x);</p>
<p class="p"><em class="ph i">// pow(2,0.5) = sqrt(2) = 1.414213 = 92682/65536 = 0x0001 6A0A</em></p>
<p class="p"><em class="ph i">// y = 0x0001 6A14 = 92692/65536 = 1.414367 (vs. 1.414213)</em></p>
<p class="p">x = 0x00014000; <em class="ph i">// 1.25 in Q15.16</em></p>
<p class="p">y = Fract_2toX_Q15d16(x);</p>
<p class="p"><em class="ph i">// pow(2,1.25) = 2.378414 = 155,872 / 65536 = 0x0002 60E0</em></p>
<p class="p"><em class="ph i">// y = 0x0002 60E0</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15d16_t <strong class="ph b">Fract_2toX_Q15d16</strong> (fract_q15d16_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_Convert_Q15bfpToQ15d16 Function</strong></p>
<p class="p">fract_q15d16_t Fract_Convert_Q15bfpToQ15d16( fract_q15bfp_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Convert Q15 block floating point to Q15.16 fixed point.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Convert Q15 block floating point to Q15.16 fixed point.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Input converted to Q15.16 fixed point.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">No effort is made to trap overflows of underflows,</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x_Q15d16;</p>
<p class="p">fract_q15bfp_t x_Q15bfp;</p>
<p class="p">x_Q15bfp.m = 0x4000; <em class="ph i">// 1/2</em></p>
<p class="p">x_Q15bfp.e = -1; <em class="ph i">// 1/2&gt;&gt;1 = 1/4</em></p>
<p class="p">x_Q15d16 = Fract_Convert_Q15bfpToQ15d16( x_Q15bfp );</p>
<p class="p"><em class="ph i">// x_Q15d16 = 0x0000 4000</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15d16_t <strong class="ph b">Fract_Convert_Q15bfpToQ15d16</strong> (fract_q15bfp_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_Convert_Q15bfpToQ31 Function</strong></p>
<p class="p">fract_q31_t Fract_Convert_Q15bfpToQ31( fract_q15bfp_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Convert Q15 block floating point to Q31 fixed point.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Convert Q15 block floating point to Q31 fixed point.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Input converted to Q31 fixed point.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">No effort is made to trap overflows of underflows,</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q31_t <strong class="ph b">Fract_Convert_Q15bfpToQ31</strong> (fract_q15bfp_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_Convert_Q15d16ToQ15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_Convert_Q15d16ToQ15bfp( fract_q15d16_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Convert from Q15.16 fixed point to Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Convert from Q15.16 fixed point to Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15.16 fixed point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Input convertd to Q15 Block Floating Point.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Mantissa and exponent are adjusted to remove redundant leading bits.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x_Q15d16;</p>
<p class="p">fract_q15bfp_t x_Q15bfp;</p>
<p class="p">x_Q15d16 = 0xFFFFC000; <em class="ph i">//-1/4</em></p>
<p class="p">x_Q15bfp = Fract_Convert_Q15d16ToQ15bfp(x_Q15d16);</p>
<p class="p"><em class="ph i">//x_Q15bfp.m = 0xC000 // -1/2</em></p>
<p class="p"><em class="ph i">//x_Q15bfp.e = 0xFFFF = -1; // -1/2&gt;&gt;1 = -1/4</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_Convert_Q15d16ToQ15bfp</strong> (fract_q15d16_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_Convert_Q15ToQ15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_Convert_Q15ToQ15bfp( fract_q15_t x )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Convert from Q15 fixed point to Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Convert from Q15 fixed point to Q15 Block Floating Point</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 (aka Q1.15) fixed point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Input convertd to Q15 Block Floating Point.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Mantissa and exponent are adjusted to remove redundant leading bits.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x_Q15;</p>
<p class="p">fract_q15bfp_t x_Q15bfp;</p>
<p class="p">x_Q15 = 0xE000; <em class="ph i">//-1/4</em></p>
<p class="p">x_Q15bfp = Fract_Convert_Q15d16ToQ15bfp(x_Q15d16);</p>
<p class="p"><em class="ph i">//x_Q15bfp.m = 0xC000 // -1/2</em></p>
<p class="p"><em class="ph i">//x_Q15bfp.e = 0xFFFF = -1; // -1/2&gt;&gt;1 = -1/4</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_Convert_Q15ToQ15bfp</strong> (fract_q15_t <strong class="ph b">x</strong> );</p>
<p class="p"><strong class="ph b">Fract_InversePower Function</strong></p>
<p class="p">fract_q15bfp_t Fract_InversePower( uint16_t nBase, uint16_t nExponent )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Computes pow(nBase,-nExponent).</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Computes pow(nBase,-nExponent).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(nBase,-nExponent), as a Q15bfp block floating point number.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">pow(nBase,nExponent) must fit inside a uint32_t variable.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint16_t nBase, nExponent;</p>
<p class="p">fract_q15bfp_t Answer;</p>
<p class="p">nBase = 5;</p>
<p class="p">nExponent = 3;</p>
<p class="p">Answer = Fract_InversePower(nBase,nExponent);</p>
<p class="p"><em class="ph i">// Answer = pow(5,-3) = 1/125</em></p>
<p class="p"><em class="ph i">// Answer.m = 0x4189 = 16777</em></p>
<p class="p"><em class="ph i">// Answer.e = 0xFFFA = -6</em></p>
<p class="p"><em class="ph i">// Answer = (16777/32768)&gt;&gt;6 = 1/(125.001609)</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_InversePower</strong> (uint16_t <strong class="ph b">nBase</strong> , uint16_t <strong class="ph b">nExponent</strong> );</p>
<p class="p"><strong class="ph b">Fract_log10fix Function</strong></p>
<p class="p">int32_t Fract_log10fix (int32_t x, size_t precision)</p>
<p class="p">Calculates fixed point base 10 logarithm using number of fractional bits</p>
<p class="p">specified by precision argument.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates fixed point base 10 logarithm using number of fractional bits specified by precision argument. Log base 10 is calculated using the log base 2 function Fract_log2fix.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Fixed point input, if x == 0, function returns INT32_MIN to represent negative</p>
<p class="p">infinity. If x is input as a negative number it will be cast to be a unsigned 32 bit integer.</p>
<p class="p">precision number of fractional bits in input and output, 1&lt;= precision &lt;= 31. if precision &lt; 1 or precision &gt; 31 function returns INT32_MAX.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Logarithm base 10 of input, in same Q format as input.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.</p>
<p class="p">This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16_t integer.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">See the code example under Fract_log2fix.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">Fract_log10fix</strong> (int32_t <strong class="ph b">x</strong> , size_t <strong class="ph b">precision</strong> );</p>
<p class="p"><strong class="ph b">Fract_log2fix Function</strong></p>
<p class="p">int32_t Fract_log2fix (int32_t X32, size_t precision)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument. This implementation is based on Clay. S. Turners fast binary logarithm algorithm<span class="xref"></span>.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">X32 Fixed point input, if x == 0, function returns INT32_MIN to represent negative</p>
<p class="p">infinity. If x &lt; 0 function returns INT32_MAX as error.</p>
<p class="p">precision number of fractional bits in input and output, 1&lt;= precision &lt;= 31. if precision &lt; 1 or</p>
<p class="p">precision &gt; 31 function returns INT32_MAX as error.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Logarithm base 2 of input, in same Q format as input. The Q format used is based on the value of precision. For example, if</p>
<p class="p">precision == 16 then the Q format used is Q15.16.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.</p>
<p class="p">This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16_t integer.</p>
<p class="p">References: <span class="xref"></span> C. S. Turner, "A Fast Binary Logarithm Algorithm", IEEE Signal Processing Mag., pp. 124,140, Sep. 2010.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// Make log output Q15.16</em></p>
<p class="p"><strong class="ph b">#define</strong> PRECISION 16</p>
<p class="p"><strong class="ph b">#define</strong> STRING_MAX_SIZE 133</p>
<p class="p"><strong class="ph b">char</strong> ioString<span class="xref"></span>;</p>
<p class="p"><strong class="ph b">double</strong> Xdouble;</p>
<p class="p"><strong class="ph b">double</strong> scale = 1U &lt;&lt; PRECISION;</p>
<p class="p"><strong class="ph b">float</strong> Xfloat;</p>
<p class="p">int16_t X16;</p>
<p class="p">int32_t X32;</p>
<p class="p">while ( Xdouble != -1.0 )</p>
<p class="p">{</p>
<p class="p">sprintf(ioString,"rnX: ");</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p">GetDataBuffer(ioString,STRING_MAX_SIZE);</p>
<p class="p">sscanf(ioString,"%f",&amp;Xfloat);</p>
<p class="p">Xdouble = Xfloat;</p>
<p class="p"><strong class="ph b">if</strong> ( Xdouble == -1 )</p>
<p class="p">{</p>
<p class="p">sprintf(ioString,"rnWere done!rn");</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p"><strong class="ph b">return</strong> 0;</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">else if</strong> ( Xdouble &lt; 0 )</p>
<p class="p">{</p>
<p class="p">sprintf(ioString,"%f is Negative!rn",Xdouble);</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p"><strong class="ph b">continue</strong> ;</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">else if</strong> ( Xdouble &gt;= 1 &lt;&lt; (32 - PRECISION) )</p>
<p class="p">{</p>
<p class="p">sprintf(ioString, "%f is too bigrn", Xdouble);</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p"><strong class="ph b">continue</strong> ;</p>
<p class="p">}</p>
<p class="p">sprintf(ioString," log10(%f) = %frn", Xdouble, ( <strong class="ph b">double</strong> )log10(Xdouble));</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p">X32 = Fract_log10fix(Xdouble * scale, PRECISION);</p>
<p class="p">sprintf(ioString,"Fract_log10fix(%f) = %f (0x%08X)rn", Xdouble, X32/scale, X32);</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p">X32 = Fract_log2fix(Xdouble * scale, PRECISION) ;</p>
<p class="p">sprintf(ioString," Fract_log2fix(%f) = %f (0x%08X)rn", Xdouble, X32/scale, X32 );</p>
<p class="p">SendDataBuffer(ioString, strlen(ioString) );</p>
<p class="p">}<em class="ph i">//end while ( Xdouble != -1.0 )</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int32_t <strong class="ph b">Fract_log2fix</strong> (int32_t <strong class="ph b">X32</strong> , size_t <strong class="ph b">precision</strong> );</p>
<p class="p"><strong class="ph b">Fract_Power Function</strong></p>
<p class="p">uint32_t Fract_Power( uint16_t nBase, uint16_t nExponent )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Computes pow(nBase,nExponent) using for loop.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Computes pow(nBase,nExponent) using for loop.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">pow(nBase,nExponent), this must fit into a 32 bit unsigned integer.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">none</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint16_t nBase, nExponent;</p>
<p class="p">uint32_t answer;</p>
<p class="p">nBase = 5;</p>
<p class="p">nExponent = 3;</p>
<p class="p">answer = Fract_Power(nBase,nExponent);</p>
<p class="p"><em class="ph i">// Answer = pow(5,3) = 125 = 0x007D</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">Fract_Power</strong> (uint16_t <strong class="ph b">nBase</strong> , uint16_t <strong class="ph b">nExponent</strong> );</p>
<p class="p"><strong class="ph b">Fract_sqrtQ15 Function</strong></p>
<p class="p">fract_q15_t Fract_sqrtQ15(fract_q15_t X)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Fixed point Q15 squareroot.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Returns square root of Q15 (Q0.15) fraction. Since -1 &lt;= X &lt; 1, we know that the 0&lt;= SquareRoot(||X||) &lt; 1.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">X Q15 input, should be non-negative.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Square root of abs(X).</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Given integer X, solve for Y such that</p>
<p class="p">Y Y X</p>
<p class="p">---- * ---- = ----</p>
<p class="p">2^15 2^15 2^15</p>
<p class="p">This is equivalent to</p>
<p class="p">Y * Y = X * 2^15 = X&lt;&lt;15</p>
<p class="p">So as integers:</p>
<p class="p">Y = integer sqrt(X&lt;&lt;15)</p>
<p class="p">thus</p>
<p class="p">fixed_point_sqrt(X) = integer_sqrt(X&lt;&lt;15)</p>
<p class="p">For X = 0,1,...32767, define</p>
<p class="p">ErrSqrt = (sqrt(X/32768.0) - FixedPointSQRT(X))/sqrt(X/32768.0)</p>
<p class="p">This error ranges from 0 to 0.015259, with an average error of 0.0054096</p>
<p class="p">The fast integer square root function used is based on</p>
<p class="p">http://stackoverflow.com/questions/1100090/looking-for-an-efficient-integer-square-root-algorithm-for-arm-thumb2</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15_t <strong class="ph b">Fract_sqrtQ15</strong> (fract_q15_t <strong class="ph b">X</strong> );</p>
<p class="p"><strong class="ph b">Fract_XminusY_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_XminusY_Q15bfp( fract_q15bfp_t x, fract_q15bfp_t y )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Subtract two Q15 block floating point numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Subtract two Q15 block floating point numbers.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">none.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 block floating point term</p>
<p class="p">y Q15 block floating point term</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">x-y as Q15 block floating point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x, y;</p>
<p class="p">fract_q15bfp_t X, Y, XminusY;</p>
<p class="p">x = 0x00030000; <em class="ph i">// 3</em></p>
<p class="p">y = 0x00070000; <em class="ph i">// 7</em></p>
<p class="p">X = Fract_Convert_Q15d16ToQ15bfp(x);</p>
<p class="p">Y = Fract_Convert_Q15d16ToQ15bfp(y);</p>
<p class="p">XminusY = Fract_XminusY_Q15bfp( X, Y );</p>
<p class="p"><em class="ph i">// XplusY.m = 0xC000 = -16384/32768 = -0.5</em></p>
<p class="p"><em class="ph i">// XPlusY.e = 3</em></p>
<p class="p"><em class="ph i">// XPlusY = -0.5&lt;&lt;3 = -4</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_XminusY_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> , fract_q15bfp_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XoverY_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_XoverY_Q15bfp(fract_q15bfp_t x, fract_q15bfp_t y )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Division x/y as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Division x/y as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Numerator as Q15 block floating point</p>
<p class="p">y Denominator as Q15 block floating point</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Ratio x/y as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x,y;</p>
<p class="p">fract_q15bfp_t X, Y, XoverY;</p>
<p class="p">x = 0x1234; <em class="ph i">// 4660/32768 = 0.142219</em></p>
<p class="p">y = 0x5678; <em class="ph i">// 22136/32768 = 0.675537</em></p>
<p class="p">X = Fract_Convert_Q15d16ToQ15bfp((fract_q15d16_t)x);</p>
<p class="p">Y = Fract_Convert_Q15d16ToQ15bfp((fract_q15d16_t)y);</p>
<p class="p">XoverY = Fract_XoverY_Q15bfp(X,Y);</p>
<p class="p"><em class="ph i">// x/y = 4660/22136 = 6898/32768 = 0.210516</em></p>
<p class="p"><em class="ph i">// XoverY.m = 0x6BC8 = 27592</em></p>
<p class="p"><em class="ph i">// XoverY.e = 0xFFFE = -2</em></p>
<p class="p"><em class="ph i">// XoverY = (27592/32768)&gt;&gt;2 = 0.210510</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_XoverY_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> , fract_q15bfp_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XoverY_Q15bfpFromQ15 Function</strong></p>
<p class="p">fract_q15bfp_t Fract_XoverY_Q15bfpFromQ15(fract_q15_t x, fract_q15_t y )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculate ratio of X/Y as Q15s but return result as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculate ratio of X/Y as Q15s but return result as Q15 block floating point.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 numerator</p>
<p class="p">y Q15 denominator</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Ratio x/y as Q15 block floating point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x,y;</p>
<p class="p">fract_q15bfp_t XoverY;</p>
<p class="p">x = 0x1234; <em class="ph i">// 4660/32768 = 0.142219</em></p>
<p class="p">y = 0x5678; <em class="ph i">// 22136/32768 = 0.675537</em></p>
<p class="p">XoverY = Fract_XoverY_Q15bfpFromQ15(x,y);</p>
<p class="p"><em class="ph i">// x/y = 4660/22136 = 6898/32768 = 0.210516</em></p>
<p class="p"><em class="ph i">// XoverY.m = 0x6BC8 = 27592</em></p>
<p class="p"><em class="ph i">// XoverY.e = 0xFFFE = -2</em></p>
<p class="p"><em class="ph i">// XoverY = (27592/32768)&gt;&gt;2 = 0.210510</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_XoverY_Q15bfpFromQ15</strong> (fract_q15_t <strong class="ph b">x</strong> , fract_q15_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XoverY_Q15d16FromQ15 Function</strong></p>
<p class="p">fract_q15d16_t Fract_XoverY_Q15d16FromQ15( fract_q15_t x, fract_q15_t y );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates ratio X/Y for two Q15 fixed points</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates ratio X/Y for two Q15 fixed points</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 numerator</p>
<p class="p">y Q15 denominator</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Ratio x/y as Q15.16 fixed point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Since ratio x/y can be bigger than unity, result must be Q15.16.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x,y;</p>
<p class="p">fract_q15d16_t xovery;</p>
<p class="p">x = 0xDEAD; <em class="ph i">// -8531/32768 = -0.260345</em></p>
<p class="p">y = 0xBEEF; <em class="ph i">// -16657/32768 = -0.508331</em></p>
<p class="p">xovery = Fract_XoverY_Q15d16FromQ15(x,y);</p>
<p class="p"><em class="ph i">// x/y = -8531/-16657 = 33564/65536 = 0.512157</em></p>
<p class="p"><em class="ph i">// xovery = 0x0000 831C = 33564</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15d16_t <strong class="ph b">Fract_XoverY_Q15d16FromQ15</strong> (fract_q15_t <strong class="ph b">x</strong> , fract_q15_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XplusY_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_XplusY_Q15bfp( fract_q15bfp_t x, fract_q15bfp_t y )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Add two Q15 block floating point numbers.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Add two Q15 block floating point numbers.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">none.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 block floating point term</p>
<p class="p">y Q15 block floating point term</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">x+y as Q15 block floating point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15d16_t x, y;</p>
<p class="p">fract_q15bfp_t X, Y, XplusY;</p>
<p class="p">x = 0x00030000; <em class="ph i">// 3</em></p>
<p class="p">y = 0x00070000; <em class="ph i">// 7</em></p>
<p class="p">X = Fract_Convert_Q15d16ToQ15bfp(x);</p>
<p class="p">Y = Fract_Convert_Q15d16ToQ15bfp(y);</p>
<p class="p">XplusY = Fract_XplusY_Q15bfp( X, Y );</p>
<p class="p"><em class="ph i">// XplusY.m = 0x5000 = 20480/32768 = 0.625</em></p>
<p class="p"><em class="ph i">// XPlusY.e = 4</em></p>
<p class="p"><em class="ph i">// XPlusY = 0.625&lt;&lt;4 = 10</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_XplusY_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> , fract_q15bfp_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XtimesY_Q15 Function</strong></p>
<p class="p">fract_q15_t Fract_XtimesY_Q15(fract_q15_t x, fract_q15_t y );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates product of X*Y for Q15 fixed point</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates product of X*Y for Q15 fixed point</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 multiplicand</p>
<p class="p">y Q15 multiplicand</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Q15 product x*y</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Since both x and y are Q15 fixed point numbers the product x*y is also Q15.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15_t x, y, xtimesy;</p>
<p class="p">x = 0x1234; <em class="ph i">// 4660/32768 = 0.142219</em></p>
<p class="p">y = 0x5678; <em class="ph i">// 22136/32768 = 0.675537</em></p>
<p class="p">xtimesy = Fract_XtimesY_Q15(x,y);</p>
<p class="p"><em class="ph i">// x*y = 0.142219 * 0.675537 = 0.096069</em></p>
<p class="p"><em class="ph i">// xtimesy = 0x0C4C = 3148/32768 = 0.096069</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15_t <strong class="ph b">Fract_XtimesY_Q15</strong> (fract_q15_t <strong class="ph b">x</strong> , fract_q15_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XtimesY_Q15bfp Function</strong></p>
<p class="p">fract_q15bfp_t Fract_XtimesY_Q15bfp(fract_q15bfp_t x, fract_q15bfp_t y )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Multiply X times Y, for Q15 block floating point arguments.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Multiply X times Y, for Q15 block floating point arguments.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 block floating point multiplicand</p>
<p class="p">y Q15 block floating point multiplicand</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Product x*y as Q15 block floating point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">fract_q15bfp_t X,Y,XtimesY;</p>
<p class="p">X.m = 0x1234;</p>
<p class="p">X.e = 0; <em class="ph i">// 4660/32768 = 0.142219</em></p>
<p class="p">Y.m = 0x5678;</p>
<p class="p">Y.e = 0; <em class="ph i">// 22136/32768 = 0.675537</em></p>
<p class="p">XtimesY = Fract_XtimesY_Q15bfp(X,Y);</p>
<p class="p"><em class="ph i">// XtimesY.m = 0x6260 = 25184/32768 = 0.768554</em></p>
<p class="p"><em class="ph i">// XtimesY.e = 0xFFFD = -3</em></p>
<p class="p"><em class="ph i">// XtimesY = 0.768554&gt;&gt;3 = 0.096069</em></p>
<p class="p"><em class="ph i">// X*Y = 0.142219 * 0.675537 = 0.096069</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15bfp_t <strong class="ph b">Fract_XtimesY_Q15bfp</strong> (fract_q15bfp_t <strong class="ph b">x</strong> , fract_q15bfp_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XtimesY_Q15d16 Function</strong></p>
<p class="p">fract_q15d16_t Fract_XtimesY_Q15d16(fract_q15d16_t x, fract_q15d16_t y );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates product of X*Y for Q15.16 fixed point</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates product of X*Y for Q15.16 fixed point</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15.16 multiplicand</p>
<p class="p">y Q15.16 multiplicand</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Q15.16 product x*y</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Since both x and y are Q15.16 fixed point numbers the product x*y is also Q15.16.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15d16_t <strong class="ph b">Fract_XtimesY_Q15d16</strong> (fract_q15d16_t <strong class="ph b">x</strong> , fract_q15d16_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fract_XtimesY_Q31 Function</strong></p>
<p class="p">fract_q31_t Fract_XtimesY_Q31(fract_q31_t x, fract_q31_t y );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates product of X*Y for Q31 fixed point</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates product of X*Y for Q31 fixed point</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q31 multiplicand</p>
<p class="p">y Q31 multiplicand</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Q31 product x*y</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Since both x and y are Q31 fixed point numbers the product x*y is also Q31.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q31_t <strong class="ph b">Fract_XtimesY_Q31</strong> (fract_q31_t <strong class="ph b">x</strong> , fract_q31_t <strong class="ph b">y</strong> );</p>
<p class="p"><strong class="ph b">Fx16Norm Function</strong></p>
<p class="p">Normalize the 16-bit fractional value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function Fx16Norm:</p>
<p class="p">Produces then number of left shifts needed to Normalize the 16-bit fully fractional input. If the input a is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of <span class="xref"></span> to a maximum of <span class="xref"></span>. If the input a is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of <span class="xref"></span> to a maximum of <span class="xref"></span>. This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left shift function should be used with the value returned From this function.</p>
<p class="p">the 16-bit input on range: 0 =&gt; result &lt; 16 (i.e. NUMBITSFRACT16) If a&gt;0: 0x4000 &gt; Normalized Value &lt;= 0x7fff i.e. (MAXFRACT16+1)/2 &gt; aNorm &lt;= MAXFRACT16 If a&lt;0: 0x8000 &gt;= Normalilzed Value &lt; 0xC000 i.e. MINFRACT16&gt;= aNorm &lt;</p>
<p class="p">MINFRACT16/2</p>
<p class="p">This function relates to the ETSI norm_s function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a in Q1.15</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">i16 result - The number of left shifts required to normalize</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">Fx16Norm</strong> (q15);</p>
<p class="p"><strong class="ph b">Fx32Norm Function</strong></p>
<p class="p">Normalize the 32-bit number.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function Fx32Norm:</p>
<p class="p">Produces then number of left shifts needed to Normalize the 32-bit fractional input. If the input a is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of <span class="xref"></span> to a maximum of <span class="xref"></span>. If the input a is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of <span class="xref"></span> to a maximum of <span class="xref"></span>. This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left-shift function should be used with the value returned From this function.</p>
<p class="p">32-bit input on range: 0 =&gt; result &lt; 32 (i.e. NUMBITSFRACT32) If a&gt;0: 0x40000000 &gt; Normalized Value &lt;= 0x7fffffff i.e.</p>
<p class="p">(MAXFRACT32+1)/2 &gt; aNorm &lt;= MAXFRACT32 If a&lt;0: 0x80000000 &gt;= Normalized Value &lt; 0xC0000000 i.e. MINFRACT32&gt;=</p>
<p class="p">aNorm &lt; MINFRACT32/2</p>
<p class="p">This function relates to the ETSI norm_l function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit Q1.d31 to be normalized</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">int16_t result - The number of left shifts required to normalize the</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int16_t <strong class="ph b">Fx32Norm</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q15_Abs_q15 Function</strong></p>
<p class="p">Saturated Absolute value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_Abs_q15:</p>
<p class="p">Creates a saturated Absolute value. It takes the absolute value of the 16-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT16 is greater than MAXFRACT16, or the allowable range of 16-bit values. This function relates to the ETSI abs function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a input argument</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - abs(input) &lt;= MAXFRACT16</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_Abs_q15</strong> (q15);</p>
<p class="p"><strong class="ph b">libq_q15_Add_q15_q15 Function</strong></p>
<p class="p">Add two 16-bit 2s-complement fractional values.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_Add_q15_q15: f</p>
<p class="p">Add two 16-bit 2s-complement fractional (op1 + op2) to produce a 16-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 - a+b on Range: MINFRACT16 &lt;= result &lt;= MAXFRACT16</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_Add_q15_q15</strong> (q15, q15);</p>
<p class="p"><strong class="ph b">libq_q15_DivisionWithSaturation_q15_q15 Function</strong></p>
<p class="p">Fractional division with saturation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_DivisionWithSaturation_q15_q15():</p>
<p class="p">Performs fractional division with saturation. There are three restrictions that the calling code must satisfy.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p">Both the numerator and denominator must be positive.</p>
</li>
<li class="li"><span class="indent-level-default">2.</span><p class="p">In order to obtain a non-saturated result, the numerator must be LESS than or equal to the denominator.</p>
</li>
<li class="li"><span class="indent-level-default">3.</span><p class="p">The denominator must not equal zero.</p>
</li>
</ol>
<p class="p">If num equals den, then the result equals MAXINT16.</p>
<p class="p">This function relates to the ETSI div_s function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 num 16-bit fractional numerator</p>
<p class="p">q15 den 16-bit fractional denumerator</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - ratio a/b in 16-bit fractional format</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_DivisionWithSaturation_q15_q15</strong> (q15, q15);</p>
<p class="p"><strong class="ph b">libq_q15_ExpAvg_q15_q15_q1d15 Function</strong></p>
<p class="p">Exponential averaging</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ExpAvg_q15_q15_q1d15()</p>
<p class="p">Exponential averaging implements a smoothing function based on the form: avg<span class="xref"></span> = avg<span class="xref"></span> * lamda + new * (1-lamda) In this implementation, is has been optimized as follows. avg<span class="xref"></span> = (avg<span class="xref"></span> - new) * lamda + new</p>
<p class="p">The optimization precludes accurate processing of new numbers that differ from the current average by more than unity. If the difference is greater than unity or less than negative unity, the difference is saturated.</p>
<p class="p">The effect is akin to a smaller lambda, e.g., the new value will have a greater weight than expected. If the smoothing is of data that is entirely positive or entirely negative, then the saturation will not be an issue.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 S(k) Previous exponential average</p>
<p class="p">q15 X(k) New value to be averaged in</p>
<p class="p">q15 L exponential averaging constant in Q1.15</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - S(k+1) = S(k)<em class="ph i">L + X(k)</em>(1-L)</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ExpAvg_q15_q15_q1d15</strong> (q15 <strong class="ph b">prevAvgQ15</strong> , q15 <strong class="ph b">newMeasQ15</strong> , q15 <strong class="ph b">lamdaQ1d15</strong> );</p>
<p class="p"><strong class="ph b">libq_q15_ExtractH_q31 Function</strong></p>
<p class="p">Extracts upper 16 bits of input 32-bit fractional value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ExtractH_q31:</p>
<p class="p">Extracts upper 16 bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the top 16-bits of the 32-bit input. This function relates to the ETSI extract_h function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - Upper 16 bits of 32-bit argument a</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ExtractH_q31</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q15_ExtractL_q31 Function</strong></p>
<p class="p">Extracts lower 16-bits of input 32-bit fractional value.</p>
<p class="p">Descriptionf Extracts lower 16-bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the bottom 16-bits of the 32-bit input. This function relates to the ETSI extract_l function.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ExtractL_q31:</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 - Lower 16 bits of 32-bit argument a</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ExtractL_q31</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q15_MacR_q31_q15_q15 Function</strong></p>
<p class="p">Multiply accumulate with rounding.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_MacR_q31_q15_q15:</p>
<p class="p">This function is multiply-accumulate WITH Rounding applied to the accumulator result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a 0 in the Lsb. The shifted multiplier output is then added to the 32-bit fractional input a. Then the 32-bits of the accumulator output are rounded by adding 2^15. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output. This function is for fractional Qtype format data only and it therefore will not give the correct results for true integers.</p>
<p class="p">This function relates to the ETSI L_mac_r function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit accumulator operand</p>
<p class="p">q15 b 16-bit multiplication operand</p>
<p class="p">q15 c 16-bit multiplication operand</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - a+b*c rounded</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_MacR_q31_q15_q15</strong> (q31, q15, q15);</p>
<p class="p"><strong class="ph b">libq_q15_MsuR_q31_q15_q15 Function</strong></p>
<p class="p">Multiply-Subtraction with rounding</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_MsuR_q31_q15_q15:</p>
<p class="p">This function is like Multiply-Subtract but WITH Rounding applied to the subtractor result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a 0 in the Lsb. The shifted multiplier output is then SUBTRACTED From the 32-bit fractional input a. Then the 32-bits output From this subtraction are rounded by adding 2^15. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output.</p>
<p class="p">This function is for fractional Q-type format data only and it therefore will not give the correct results for true integers.</p>
<p class="p">This function relates to the ETSI msu_r function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a Value which is subtracted from</p>
<p class="p">q15 b multiplication operand 1</p>
<p class="p">q15 c multiplication operand 2</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - a-b*c rounded to Q1.15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_MsuR_q31_q15_q15</strong> (q31, q15, q15);</p>
<p class="p"><strong class="ph b">libq_q15_MultiplyR2_q15_q15 Function</strong></p>
<p class="p">fractional multiplication of two 16-bit fractional values giving a 16 bit rounded result.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_MultiplyR2_q15_q15:</p>
<p class="p">Performs fractional multiplication of two 16-bit fractional values and returns a ROUNDED 16-bit fractional result. The function performs a Q15xQ15-&gt;Q30 bit multiply with a left shift by 1 to give a Q31 result. This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any 32-bit result that overflows. Rounding is applied to the 32-bit SHIFTED result by adding in a weight factor of 2^15, again any overflows are saturated. The TOP 16-bits are extracted and returned. This function is for fractional Qtype data only and it therefore will not give the correct results for true integers (because left shift by 1). This function assumes that the binary point in the 32-bit shifted multiplier output is between bit_16 and bit_15 when the rounding factor is added. For the special case where both inputs equal the MINFACT16, the function returns a value equal to MAXFACT16, i.e. 0x7fff = libq_q15_Mult2_q15_q15(0x8000,0x8000). This function internally calls the libq_q15_mult_q15_q31() routine to perform the actual multiplication and the rounding routine to perform the actual rounding.</p>
<p class="p">This function relates to the ETSI mult_r function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a value in Q1.15</p>
<p class="p">q15 b value in Q1.15</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - a*b rounded 16-bit signed integer (Q1.15) output value</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_MultiplyR2_q15_q15</strong> (q15, q15);</p>
<p class="p"><strong class="ph b">libq_q15_Negate_q15 Function</strong></p>
<p class="p">Negate 16-bit 2s-complement fractional value with saturation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_Negate_q15:</p>
<p class="p">Negate 16-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT16 is greater than MAXFRACT16, or the allowable range of values. This function relates to the ETSI negate function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result on range: MINFRACT16 &lt;= result &lt;= MAXFRACT16</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_Negate_q15</strong> (q15);</p>
<p class="p"><strong class="ph b">libq_q15_RoundL_q31 Function</strong></p>
<p class="p">Rounds the lower 16-bits of the 32-bit fractional input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_RoundL_q31:</p>
<p class="p">Rounds the lower 16-bits of the 32-bit fractional input into a 16-bit fractional value with saturation. This converts the 32-bit fractional value to 16-bit fractional value with rounding. This function calls the Add function to perform the 32-bit rounding of the input value and ExtractH function to extract to top 16-bits. This has the effect of rounding positive fractional values up and more positive, and has the effect of rounding negative fractional values up and more positive. This function relates to the ETSI round function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_RoundL_q31</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q15_ShiftLeft_q15_i16 Function</strong></p>
<p class="p">Arithmetic Shift of the 16-bit input argument.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ShiftLeft_q15_i16:</p>
<p class="p">Performs an Arithmetic Shift of the 16-bit input argument a left by the input argument b bit positions. If b is a positive number, a 16-bit left shift is performed with zeros inserted to the right of the shifted bits. If b is a negative number, a right shift by abs(b) positions with sign extention Saturation is applied if shifting causes an overflow or an underflow.</p>
<p class="p">positive value: # of bits to left shift (zeros inserted at LSBs) {To not always saturate: if a=0, then max b=15, else max b=14}</p>
<p class="p">negative value: # of bits to right shift (sign extend)</p>
<p class="p">This function relates to the ETSI shl function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a 16-bit signed integer value to be shifted.</p>
<p class="p">i16 b 16-bit signed integer shift value</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - arithmetically shifted 16-bit signed integer output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ShiftLeft_q15_i16</strong> (q15, i16);</p>
<p class="p"><strong class="ph b">libq_q15_ShiftRight_q15_i16 Function</strong></p>
<p class="p">Arithmetic RIGHT Shift on a 16-bit value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ShiftRight_q15_q15:</p>
<p class="p">Performs an Arithmetic RIGHT Shift on a 16-bit input by b bit positions. For positive shift directions (b&gt;0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b&lt;0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 16-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.</p>
<p class="p">positive value: # of bits to right shift (sign extend) { To get all sign bits, b&gt;=15 } negative value: # of bits to left shift (zeros inserted</p>
<p class="p">at LSBs)</p>
<p class="p">This function relates to the ETSI shr function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a 16-bit signed input value to shift</p>
<p class="p">i16 b 16-bit signed integer shift index</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - 16-bit signed shifted output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ShiftRight_q15_i16</strong> (q15, i16);</p>
<p class="p"><strong class="ph b">libq_q15_ShiftRightR_q15_i16 Function</strong></p>
<p class="p">Performs an Arithmetic RIGHT Shift on a 16-bit input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_ShiftRightR_q15_q15:</p>
<p class="p">Performs an Arithmetic RIGHT Shift on a 16-bit input by b bits with Rounding applied. The rounding occurs by adding a bit weight of "1/2 Lsb", where the "Lsb" is the Ending (shifted) Lsb. For example: The initial Bit#(b) is after the right shift Bit#(0), so the rounding bit weight is Bit#(b-1). Rounding does not occur on either left shifts or on no shift needed cases. For positive shift directions (b&gt;0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b&lt;0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 16-bit left shift. This function does not provide any status-type information to indicate when overflows occur.</p>
<p class="p">positive value: # of bits to right shift (sign extend) {b &gt; 15, results in all sign bits} negative value: # of bits to left shift (zeros</p>
<p class="p">inserted at LSBs)</p>
<p class="p">This function relates to the ETSI shr_r function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a 16-bit signed integer value to be shifted</p>
<p class="p">i16 b 16-bit signed integer shift index</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result - Arithmetically shifted 16-bit signed integer output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_ShiftRightR_q15_i16</strong> (q15, i16);</p>
<p class="p"><strong class="ph b">libq_q15_Sub_q15_q15 Function</strong></p>
<p class="p">Subtract two 16-bit 2s-complement fractional values</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q15_Sub_q15_q15:</p>
<p class="p">Subtract two 16-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 result a+b on range: MINFRACT16 &lt;= result &lt;= MAXFRACT16</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q15_Sub_q15_q15</strong> (q15, q15);</p>
<p class="p"><strong class="ph b">libq_q1d15_Sin_q10d6 Function</strong></p>
<p class="p">Approximates the sine of an angle.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q1d15_Sin_q10d6:</p>
<p class="p">This function approximates the sine of an angle using the following algorithm: sin(x) = 3.140625x + 0.02026367x^2 - 5.325196x^3</p>
<ul class="ul"><li class="li"><p class="p">0.5446778x^4 + 1.800293x^5. The approximation is accurate for any value of x from 0 degrees to 90 degrees. Because sin(-x) =</p>
</li>
</ul>
<ul class="ul"><li class="li"><p class="p">sin(x) and sin(x) = sin(180 - x), the sine of any angle can be inferred from an angle in the first quadrant. Therefore, any angle &gt;</p>
</li>
</ul>
<p class="p">90 is converted to an angle between 0 &amp; 90. The coefficients of the algorithm have been scaled by 1/8 to fit a Q1d15 format. So the result is scaled up by 8 to obtain the proper magnitudes. The algorithm expects the angle to be in degrees and represented in Q10.6 format. The computed sine value is returned in Q1.15 format.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">none.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 angle The angle in degrees for which the sine is computed in Q10.6</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q15 sine(angle) value in Q1.15</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q15 <strong class="ph b">libq_q1d15_Sin_q10d6</strong> (q15 <strong class="ph b">angleQ10d6</strong> );</p>
<p class="p"><strong class="ph b">libq_q20d12_Sin_q20d12 Function</strong></p>
<p class="p">3rd order Polynomial apprx. of a sine function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q20d12_Sin_q20d12:</p>
<p class="p">3rd order Polynomial apprx. of a sine function</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">none.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 angle The angle in radians for which the sine is computed in Q20.12</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 Sine(angle) value in Q20.12</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q20d12_Sin_q20d12</strong> (q31 <strong class="ph b">angQ20d12</strong> );</p>
<p class="p"><strong class="ph b">libq_q31_Abs_q31 Function</strong></p>
<p class="p">Saturated Absolute value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Abs_q31:</p>
<p class="p">Creates a saturated Absolute value. It takes the absolute value of the 32-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT32 is greater than MAXFRACT32, or the allowable range of 32-bit values.</p>
<p class="p">This function relates to the ETSI L_abs function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - abs(a) &lt;= MAXFRACT32</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Abs_q31</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q31_Add_q31_q31 Function</strong></p>
<p class="p">Add two 32-bit 2s-complement fractional values.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Add_q31_q31:</p>
<p class="p">Add two 32-bit 2s-complement fractional (op1 + op2) to produce a 32-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 32-bit inputs and the resulting 32-bit</p>
<p class="p">output. This function relates to the ETSI L_add function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result a+b on range: MINFRACT32 &lt;= result &lt;= MAXFRACT32</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Add_q31_q31</strong> (q31, q31);</p>
<p class="p"><strong class="ph b">libq_q31_DepositH_q15 Function</strong></p>
<p class="p">Place 16 bits in the upper half of 32 bit word.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_DepositH_q15:</p>
<p class="p">Composes a 32-bit fractional value by placing the input 16-bit fractional value in the composite MSBs and zeros the composite 16-bit LSBs This is a bit-for-bit placement of input 16-bits into the upper part of 32-bit result.</p>
<p class="p">This function relates to the ETSI L_deposit_H function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result 16-bits of a in upper MSBs and zeros in the lower LSBs</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_DepositH_q15</strong> (q15);</p>
<p class="p"><strong class="ph b">libq_q31_DepositL_q15 Function</strong></p>
<p class="p">Place 16 bits in the lower half of 32 bit word.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_DepositL_q15:</p>
<p class="p">Composes a 32-bit fractional value by placing the 16-bit Fraction input value into the lower 16-bits of the 32-bit composite value.</p>
<p class="p">The 16-bit MSBs of the composite output are sign extended. This is a bit-for-bit placement of input 16-bits into the bottom portion of the composite 32-bit result with sign extention. This function relates to the ETSI L_deposit_l function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - SignExtended 16-bit MSBs and a Value in lower 16-bit LSBs</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_DepositL_q15</strong> (q15);</p>
<p class="p"><strong class="ph b">libq_q31_Mac_q31_q15_q15 Function</strong></p>
<p class="p">Multiply-Accumulate function WITH saturation</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Mac_q31_q15_q15():</p>
<p class="p">Performs a Multiply-Accumulate function WITH saturation. This routine returns the fully fractional 32-bit result From the accumulator output SAT(addOut_Q1d31)=outQ1d15 where multOut_Q1d31 + a_Q1d31 = addOut_Q1d31, and b_Q1d15 x c_Q1d15 = multOut_Q1d31. The multiply is performed on the two 16-bit fully fully fractional input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fully fully fractional-type multiply. The shifted number represents a Q1d31 number with the lsb set to 0. This Q1d31 number is added with the 32-bit fully fully fractional input argument a. Saturation is applied on the output of the accumulator to keep the value within the 32-bit fully fractional range and then this value is returned. This function is for fully fractional Q-type format data only and it therefore will not give the correct results for true integers.</p>
<p class="p">This function relates to the ETSI L_mac function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit accumulator operand 1 in Q1d31</p>
<p class="p">q15 b 16-bit multiplication operand 1 in Q1d15</p>
<p class="p">q15 c 16-bit multiplication operand 2 in Q1d15</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result, a+b*c saturated</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Mac_q31_q15_q15</strong> (q31, q15, q15);</p>
<p class="p"><strong class="ph b">libq_q31_Msu_q31_q15_q15 Function</strong></p>
<p class="p">L_msu(a,b,c)</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Msu_q31_q15_q15</strong> (q31, q15, q15);</p>
<p class="p"><strong class="ph b">libq_q31_Mult2_q15_q15 Function</strong></p>
<p class="p">fractional multiplication of two 16-bit fractional values.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Mult2_q15_q15:</p>
<p class="p">Performs fractional multiplication of two 16-bit fractional values and returns the 32-bit fractional scaled result. The function performs the Q15xQ15-&gt;Q30 fractional bit multiply. It then shifts the result left by 1, to give a Q31 type result, (the lsb is zero-filled). This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any results that overflow, and then the function returns the 32-bit fractional q31 result. This function is for fractional Q data only and it therefore will not give correct results for true integers (because left shift by 1). For the special case where both inputs equal the MINFRACT16, the function returns a value equal to MAXFACT32, i.e. 0x7fffffff = libq_q15_mult_q15_q31(0x8000,0x8000).</p>
<p class="p">This function relates to the ETSI L_mult function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q15 a multiplicand a</p>
<p class="p">q15 b multiplicand b</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31, a*b</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Mult2_q15_q15</strong> (q15, q15);</p>
<p class="p"><strong class="ph b">libq_q31_Multi_q15_q31 Function</strong></p>
<p class="p">Implement 16 bit by 32 bit multiply.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Multi_q15_q31():</p>
<p class="p">Implement 16 bit by 32 bit multiply as shown below The s and u notation shows the processing of signed and unsigned numbers.</p>
<p class="p">-B1- -B0- s u 2nd argument is 32 bits -A0- s 1st argument is 16 bits</p>
<p class="p"><strong class="ph b">------------</strong></p>
<p class="p">A0B0 A0B0 s=s<em class="ph i">u 1st 32-bit product is A0</em>B0 A0B1 A0B1 s=s<em class="ph i">s 2nd 32-bit product is A0</em>B1</p>
<p class="p"><strong class="ph b">------------</strong></p>
<p class="p">-S2- -S1- -S0- s=s+s 48-bit result is the sum of products -P1- -P0- 32-bit return is the most significant bits of sum</p>
<p class="p">The algorithm is implemented entirely with the fractional arithmetic library. The unsigned by signed multiply is implemented by shifting bits 15:1 to bits 14:0 of a 16-bit positive fractional number, which throws away bit 0 of the 32-bit number. Since that affects result bits that are used for rounding, rounding processing is included. Saturation processing is handled implicitly in the fractional arithmetic library, except for the case of maximum negative numbers.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - a*b rounded</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Multi_q15_q31</strong> (q15 <strong class="ph b">argAQ1d15</strong> , q31 <strong class="ph b">argBQ1d31</strong> );</p>
<p class="p"><strong class="ph b">libq_q31_Negate_q31 Function</strong></p>
<p class="p">Negate 32-bit 2s-complement fractional value with saturation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Negate_q31:</p>
<p class="p">Negate 32-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT32 is greater than MAXFRACT32, or the allowable range of values. This function relates to the ETSI L_negate function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result on range: MINFRACT32 &lt;= result &lt;= MAXFRACT32</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Negate_q31</strong> (q31);</p>
<p class="p"><strong class="ph b">libq_q31_ShiftLeft_q31_i16 Function</strong></p>
<p class="p">Arithmetic Shift of the 32-bit value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_ShiftLeft_q31_i16:</p>
<p class="p">Performs an Arithmetic Shift of the 32-bit input argument a left by the input argument b bit positions. If b is a positive number, a 32-bit left shift is performed with zeros inserted to the right of the shifted bits. If b is a negative number, a 32-bit right shift by b bit positions with sign extention:</p>
<p class="p">positive value: # of bits to left shift (zeros inserted at LSBs) negative value: # of bits to right shift (sign extend)</p>
<p class="p">Saturation is applied if shifting causes an overflow or an underflow.</p>
<p class="p">This function relates to the ETSI L_shl function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit signed integer value to be shifted</p>
<p class="p">i16 16-bit signed integer shift index</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - arithmetically shifted 32-bit signed integer output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_ShiftLeft_q31_i16</strong> (q31, i16);</p>
<p class="p"><strong class="ph b">libq_q31_ShiftRight_q31_i16 Function</strong></p>
<p class="p">Arithmetic RIGHT Shift on a 32-bit value.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_ShiftRight_q31_q15:</p>
<p class="p">Performs an Arithmetic RIGHT Shift on a 32-bit input by b bit positions. For positive shift directions (b&gt;0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b&lt;0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 32-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.</p>
<p class="p">positive value: # of bits to right shift (sign extend) negative value: # of bits to left shift (zeros inserted at LSBs)</p>
<p class="p">This function relates to the ETSI L_shr function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit signed integer value to be shifted</p>
<p class="p">i16 b 16-bit signed integer shift index</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - Arithmetically shifted 32-bit signed integer output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_ShiftRight_q31_i16</strong> (q31, i16);</p>
<p class="p"><strong class="ph b">libq_q31_ShiftRightR_q31_i16 Function</strong></p>
<p class="p">Arithmetic RIGHT Shift on a 32-bit value</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_ShiftRightR_q31_q15:</p>
<p class="p">Performs an Arithmetic RIGHT Shift on a 32-bit input by b bits with Rounding applied. The rounding occurs before any shift by adding a bit weight of "1/2 Lsb", where the "Lsb" is the Ending (shifted) Lsb. For example: The initial Bit#(i+b) is after the right shift Bit#(i), so the rounding bit weight is Bit#(i+b-1). Rounding does not occur on left shifts, when b is negative. After rounding, this function calls the right-shift function to perform the actual 32-bit right shift. For positive shift directions (b&gt;0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b&lt;0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 32-bit left shift. This function does not provide any status-type flag to indicate occurence of overflow.</p>
<p class="p">positive value: # of bits to right shift (sign extend) negative value: # of bits to left shift (zeros inserted at LSBs)</p>
<p class="p">This function relates to the ETSI L_shr_r function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">q31 a 32-bit signed integer value to be shifted</p>
<p class="p">i16 b 16-bit signed integer shift index</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result - Arithmetically shifted 32-bit signed integer output</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_ShiftRightR_q31_i16</strong> (q31, i16);</p>
<p class="p"><strong class="ph b">libq_q31_Sub_q31_q31 Function</strong></p>
<p class="p">Subtract two 32-bit 2s-complement fractional values</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Function libq_q31_Sub_q31_q31:</p>
<p class="p">Subtract two 32-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">q31 result a-b on range: MINFRACT31 &lt;= result &lt;= MAXFRACT31</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">q31 <strong class="ph b">libq_q31_Sub_q31_q31</strong> (q31, q31);</p>
<p class="p"><strong class="ph b">LUTwInterpolation_Q15 Function</strong></p>
<p class="p">fract_q15_t LUTwInterpolation_Q15( fract_q15_t x,</p>
<p class="p">const fract_q15_t * pX_LUT_Vector,</p>
<p class="p">const fract_q15_t * pY_LUT_Vector,</p>
<p class="p">const uint16_t nLUTSize );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">x Q15 value, independent variable</p>
<p class="p">pX_LUT_Vector X column of LUT in Q15</p>
<p class="p">pY_LUT_Vector Y column of LUT in Q15</p>
<p class="p">nLutSize number of rows (entries) in the LUT</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">y = f(x) based on the LUT using linear interpolation between table entries.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">It is assumed that X LUT vector is in strictly monotonically increasing order. That is: pX_LUT_Vector<span class="xref"></span> &lt; pX_LUT_Vector<span class="xref"></span> for i = 0,1,...nLUTSize-2</p>
<p class="p">Internal math is done in signed 32 integers and truncated to Q15.</p>
<p class="p">If x &lt;= pX_LUT_Vector<span class="xref"></span> then pY_LUT_Vector<span class="xref"></span> is returned.</p>
<p class="p">if pX_LUT_Vector<span class="xref"></span> &lt;= x then pY_LUT_Vector<span class="xref"></span> is returned.</p>
<p class="p">WARNING: It is strongly recommended that you test out the LUT and compare actual vs. desired values in Matlab/Octave or Excel! You may need to add additional rows where the interpolation does not produce the needed accuracy.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q15_t <strong class="ph b">LUTwInterpolation_Q15</strong> (fract_q15_t <strong class="ph b">x</strong> , <strong class="ph b">const</strong> fract_q15_t * <strong class="ph b">pX_LUT_Vector</strong> , <strong class="ph b">const</strong></p>
<p class="p">fract_q15_t * <strong class="ph b">pY_LUT_Vector</strong> , <strong class="ph b">const</strong> uint16_t <strong class="ph b">nLUTSize</strong> );</p>
<p class="p"><strong class="ph b">SinInDegs Function</strong></p>
<p class="p">fract_q0d15_t SinInDegs( fract_q9d6_t theta );</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Parameters</strong></p>
<p class="p"><strong class="ph b">Parameters Description</strong></p>
<p class="p">theta Q9.6 fixed point angle</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">sin(theta) in Q0.15 fixed point</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int32_t nTests = 400;</p>
<p class="p"><strong class="ph b">float</strong> theta;</p>
<p class="p"><strong class="ph b">float</strong> delta_theta = 360.0/(nTests-1);</p>
<p class="p"><strong class="ph b">float</strong> theta0 = 0;</p>
<p class="p">int32_t i;</p>
<p class="p">int32_t x;</p>
<p class="p">for ( i = 0; i &lt; nTests; i++ )</p>
<p class="p">{</p>
<p class="p">theta = theta0 + i*delta_theta;</p>
<p class="p">x = theta*(32768/512); <em class="ph i">//Q9.6</em></p>
<p class="p">printf("%d, %d rn",( int )x,SinInDegs(x)));</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">fract_q0d15_t <strong class="ph b">SinInDegs</strong> (fract_q9d6_t <strong class="ph b">theta</strong> );</p>
</div>
</div>
</div>
</body>
</html>