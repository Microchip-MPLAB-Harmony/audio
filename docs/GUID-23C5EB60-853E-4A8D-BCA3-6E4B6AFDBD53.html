<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="MPLAB Harmony Audio Driver and Peripherals Help" />
<meta name="DC.relation" scheme="URI" content="GUID-546D2D8B-EC03-4BF5-B23F-D618F41955FB.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="mplab-harmony-audio-driver-and-peripherals-help" />
<link rel="stylesheet" type="text/css" href="stylesheets/commonltr.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<link rel="stylesheet" type="text/css" href="./stylesheets/common-extended.css" /><title>MPLAB Harmony Audio Driver and Peripherals Help</title>
<meta name="Microsoft.Help.Id" content="GUID-9A1A39D4-F5A9-4AB5-89CC-20C51E2EECD5-mplab-harmony-audio-driver-and-peripherals-help" />
<meta name="Microsoft.Help.TocParent" content="GUID-9A1A39D4-F5A9-4AB5-89CC-20C51E2EECD5" />
<meta name="Microsoft.Help.TocOrder" content="0" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB® Harmony Audio Help Reference A 05/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
        function cpy(id, button) {
        
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                    button.textContent = "Copy";
                    button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
              console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
        }
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-23C5EB60-853E-4A8D-BCA3-6E4B6AFDBD53"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style></head>
<body id="mplab-harmony-audio-driver-and-peripherals-help">
<h1 class="title topictitle1" id="ariaid-title1">MPLAB Harmony Audio Driver and Peripherals Help</h1><div class="body"><p class="p"><img class="image" src="GUID-C743039C-0895-4E95-811A-FC2F250F7168-low.png" /><br />
MPLAB Harmony Integrated Software Framework</p>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-546D2D8B-EC03-4BF5-B23F-D618F41955FB.html">MPLAB® Harmony 3 Audio, Support Package</a></div>
</div>
</div><div class="topic nested1" aria-labelledby="ariaid-title2" id="driver-libraries-help"><h2 class="title topictitle2" id="ariaid-title2">Driver Libraries Help</h2><div class="body"><p class="p">This section provides descriptions of the Driver libraries that are available in audio repo.</p>
<p class="p">For additional information on Harmony 3 driver architecture, refer to the documentation in the core repository.</p>
<p class="p"><strong class="ph b">Codec Libraries Help</strong></p>
<p class="p"><strong class="ph b">AK4953 CODEC Driver Library Help</strong></p>
<p class="p">This topic describes the AK4953 Codec Driver Library.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title3" id="introduction"><h2 class="title topictitle2" id="ariaid-title3"><em class="ph i">Introduction</em></h2><div class="body"><p class="p">This topic describes the basic architecture of the AK4953 Codec Driver Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title4" id="interface-header-file-drv-ak4953h"><h3 class="title topictitle3" id="ariaid-title4">Interface Header File: drv_AK4953.h</h3><div class="body"><p class="p">The interface to the AK4953 Codec Driver library is defined in the audio/driver/codec/AK4953/drv_AK4953.h header file. Any C language source (.c) file that uses the AK4953 Codec Driver library should include this header.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The AK4953 Codec Driver library source files are provided in the audio/driver/codec/AK4953/src directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features and to <strong class="ph b">Building the Library</strong> for instructions on how to build the library.</p>
<p class="p"><strong class="ph b"><em class="ph i">Using the Library</em></strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title5" id="abstraction-model"><h2 class="title topictitle2" id="ariaid-title5">Abstraction Model</h2><div class="body"><p class="p">This library provides a low-level abstraction of the AK4954 Codec Driver Library on the Microchip family microcontrollers with a convenient C language interface. This topic describes how that abstraction is modeled in software and introduces the library's interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The abstraction model shown in the following diagram depicts how the AK4953 Codec Driver is positioned in the MPLAB Harmony framework. The AK4953 Codec Driver uses the I2C and I2S drivers for control and audio data transfers to the AK4953 module.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title6" id="ak4953-driver-abstraction-model"><h3 class="title topictitle3" id="ariaid-title6">AK4953 Driver Abstraction Model</h3><div class="body"><br /><img class="image" src="GUID-A1402B4E-C779-4E72-B06A-3076BD3B42F4-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title7" id="library-overview"><h2 class="title topictitle2" id="ariaid-title7">Library Overview</h2><div class="body"><p class="p">Refer to the Driver Library Overview section for information on how the driver operates in a system.</p>
<p class="p">The AK4953 Codec Driver Library provides an API interface to transfer control commands and digital audio data to the serially interfaced AK4953 Codec module. The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the AK4953 Codec Driver Library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e97"><span><strong class="ph b">Library Interface Section</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e100"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>System Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>Provides system module interfaces, device initialization, deinitialization, reinitialization, tasks and status functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>Client Setup Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>Provides open and close functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>Data Transfer Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>Provides data transfer functions, such as Buffer Read and Write.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>Settings Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>Provides driver specific functions for settings, such as volume control and sampling rate.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>Other Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>Miscellaneous functions, such as getting the driver’s version number and syncing to the LRCLK signal.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e97 "><span>Data Types and Constants</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e100 "><span>These data types and constants are required while interacting and setting up the AK4953 Codec Driver Library.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> All functions and constants in this section are named with the format DRV_ AK4953_xxx, where 'xxx' is a function name or constant. These names are redefined in the appropriate configuration’s configuration.h file to the format DRV_CODEC_xxx using #defines so that code in the application that references the library can be written as generically as possible (e.g., by writing DRV_CODEC_Open instead of DRV_ AK4953_Open etc.). This allows the codec type to be changed in the MHC without having to modify the application’s source code.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title8" id="how-the-library-works"><h2 class="title topictitle2" id="ariaid-title8">How the Library Works</h2><div class="body"><p class="p">How the Library Works</p>
<p class="p">The library provides interfaces to support:</p>
<ul class="ul"><li class="li"><p class="p">System Functionality</p>
</li>
<li class="li"><p class="p">Client Functionality</p>
</li>
</ul>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title9" id="setup-initialization"><h3 class="title topictitle3" id="ariaid-title9">Setup (Initialization)</h3><div class="body"><p class="p">This topic describes system initialization, implementations, and includes a system access code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The system performs the initialization of the device driver with settings that affect only the instance of the device that is being initialized. During system initialization in the system_init.c file, each instance of the AK4953 module would be initialized with the following configuration settings (either passed dynamically at run time using DRV_AK4953_INIT or by using Initialization Overrides) that are supported by the specific AK4953 device hardware:</p>
<ul class="ul"><li class="li"><p class="p">Device requested power state: one of the System Module Power States. For specific details please refer to Data Types and Constants in the Library Interface section.</p>
</li>
<li class="li"><p class="p">I2C driver module index. The module index should be same as the one used in initializing the I2C Driver</p>
</li>
<li class="li"><p class="p">I2S driver module index. The module index should be same as the one used in initializing the I2S Driver</p>
</li>
<li class="li"><p class="p">Sampling rate</p>
</li>
<li class="li"><p class="p">Volume</p>
</li>
<li class="li"><p class="p">Audio data format. The audio data format should match with the audio data format settings done in I2S driver initialization</p>
</li>
<li class="li"><p class="p">Determines whether or not the microphone input is enabled</p>
</li>
</ul>
<p class="p">The DRV_AK4953_Initialize API returns an object handle of the type SYS_MODULE_OBJ. The object handle returned by the</p>
<p class="p">Initialize interface would be used by the other system interfaces such as DRV_ AK4953_Deinitialize, DRV_ AK4953_Status and</p>
<p class="p">DRV_I2S_Tasks</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title10" id="client-access"><h3 class="title topictitle3" id="ariaid-title10">Client Access</h3><div class="body"><p class="p">This topic describes driver initialization and provides a code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">For the application to start using an instance of the module, it must call the DRV_AK4953_Open function. The</p>
<p class="p">DRV_AK4953_Open function provides a driver handle to the AK4953 Codec Driver instance for operations. If the driver is deinitialized using the function DRV_AK4953_Deinitialize, the application must call the DRV_AK4953_Open function again to set up the instance of the driver.</p>
<p class="p">For the various options available for IO_INTENT, please refer to Data Types and Constants in the Library Interface section.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is necessary to check the status of driver initialization before opening a driver instance. The status of the AK4953 Codec Driver can be known by calling DRV_ AK4953_Status.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_HANDLE handle; SYS_STATUS ak4953Status;</p>
<p class="p">ak4953Status Status = DRV_AK4953_Status(sysObjects.ak4953Status DevObject); if (SYS_STATUS_READY == ak4953Status)</p>
<p class="p">{</p>
<p class="p">// The driver can now be opened.</p>
<p class="p">appData.ak4953Client.handle = DRV_AK4953_Open</p>
<p class="p">(DRV_AK4953_INDEX_0, DRV_IO_INTENT_WRITE | DRV_IO_INTENT_EXCLUSIVE); if(appData.ak4953Client.handle != DRV_HANDLE_INVALID)</p>
<p class="p">{</p>
<p class="p">appData.state = APP_STATE_AK4953_SET_BUFFER_HANDLER;</p>
<p class="p">}</p>
<p class="p">else</p>
<p class="p">{</p>
<p class="p">SYS_DEBUG(0, "Find out what's wrong \r\n");</p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p">else</p>
<p class="p">{</p>
<p class="p">/* AK4953 Driver Is not ready */</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title11" id="client-operations"><h3 class="title topictitle3" id="ariaid-title11">Client Operations</h3><div class="body"><p class="p">This topic provides information on client operations.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Client operations provide the API interface for control command and audio data transfer to the AK4953 Codec.</p>
<p class="p">The following AK4953 Codec specific control command functions are provided:</p>
<ul class="ul"><li class="li"><p class="p">DRV_AK4953_SamplingRateSet</p>
</li>
<li class="li"><p class="p">DRV_AK4953_SamplingRateGet</p>
</li>
<li class="li"><p class="p">DRV_AK4953_VolumeSet</p>
</li>
<li class="li"><p class="p">DRV_AK4953_VolumeGet</p>
</li>
<li class="li"><p class="p">DRV_AK4953_MuteOn</p>
</li>
<li class="li"><p class="p">DRV_AK4953_MuteOff</p>
</li>
</ul>
<p class="p">These functions schedule a non-blocking control command transfer operation. These functions submit the control command request to the AK4953 Codec. These functions submit the control command request to I2C Driver transmit queue, the request is processed immediately if it is the first request, or processed when the previous request is complete.</p>
<p class="p">DRV_AK4953_BufferAddWrite, DRV_AK4953_BufferAddRead, and DRV_AK4953_BufferAddWriteRead are buffered data operation functions. These functions schedule non-blocking audio data transfer operations. These functions add the request to I2S Driver transmit or receive buffer queue depends on the request type, and are executed immediately if it is the first buffer, or executed later when the previous buffer is complete. The driver notifies the client with</p>
<p class="p">DRV_AK4953_BUFFER_EVENT_COMPLETE, DRV_AK4953_BUFFER_EVENT_ERROR, or DRV_AK4953_BUFFER_EVENT_ABORT events.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is not necessary to close and reopen the client between multiple transfers.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title12" id="configuring-the-library"><h3 class="title topictitle3" id="ariaid-title12">Configuring the Library</h3><div class="body"><p class="p">The configuration of the I2S Driver Library is based on the file configurations.h, as generated by the MHC.</p>
<p class="p">This header file contains the configuration selection for the I2S Driver Library. Based on the selections made, the I2S Driver Library may support the selected features. These configuration settings will apply to all instances of the I2S Driver Library.</p>
<p class="p">This header can be placed anywhere; however, the path of this header needs to be present in the include search path for a successful build. Refer to the Applications Help section for more details.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title13" id="system-configuration"><h2 class="title topictitle2" id="ariaid-title13">System Configuration</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title14" id="configuring-mhc"><h3 class="title topictitle3" id="ariaid-title14">Configuring MHC</h3><div class="body"><p class="p">Provides examples on how to configure the MPLAB Harmony Configurator (MHC) for a specific driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When building a new application, start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <em class="ph i">File &gt; New Project</em>. Chose the Configuration name the based on the BSP, and select the appropriate processor.</p>
<p class="p">In the MHC, under Available Components select the appropriate BSP. Under <em class="ph i">Audio&gt;Templates</em>, double-click on a codec template such as AK4953. Answer Yes to all questions.</p>
<p class="p">You should end up with a project graph that looks like this, after rearranging the boxes:
<img class="image" src="GUID-C3554075-908C-444B-BDDF-6DB178E075E1-low.png" /><br /></p>
<p class="p">Click on the AK4953 Driver component (not AK4953 Codec) and the following menu will be displayed in the Configurations Options:
<img class="image" src="GUID-E61F7652-A17E-450F-9462-6E561EC13E19-low.png" /><br /></p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">I2C Driver Used</strong> will display the driver instance used for the I2C interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">I2S Driver Used</strong> will display the driver instance used for the I2S interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Usage Mode</strong> indicates whether the AK4953 is a Master (supplies I2S clocks) or a Slave (MCU supplies I2S clocks).</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Number of AK4953 Clients</strong> indicates the maximum number of clients that can be connected to the AK4953 Driver.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Sampling Rate</strong> indicates the number of samples per second per channel, 8000 to 96,000.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Volume</strong> indicates the volume in a linear scale from 0-255.</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title15" id="-audio-data-format-is-either"><h4 class="title topictitle4" id="ariaid-title15">• Audio Data Format is either</h4><div class="body"><ul class="ul"><li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 16-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Left-justified(DAC)</p>
</li>
<li class="li"><p class="p">24/16-bit I2S</p>
</li>
</ul>
<p class="p">It must match the audio protocol and data length set up in either the SSC or I2S PLIB.</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">Microphone/Line Input</strong> selects which microphone or line input is selected, either:</p>
</li>
<li class="li"><p class="p">Internal Mic (mounted on the AK4953 daughterboard)</p>
</li>
<li class="li"><p class="p">External Mic Input</p>
</li>
<li class="li"><p class="p">Line Input</p>
</li>
</ul>
<p class="p">If External Mic input or Line Input is selected, then the following option is provided:</p>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title16" id="-ext-mic-gain-in-db-range-0min-to-31max"><h4 class="title topictitle4" id="ariaid-title16">• Ext Mic Gain in dB range 0(min) to 31(max)</h4><div class="body"><p class="p">If External Mic input is selected, then the following option is provided:</p>
<p class="p">• <strong class="ph b">Enable Microphone Bias</strong> should be checked if using an electret microphone.</p>
<p class="p">You can also bring in the AK4953 Driver by itself, by double clicking AK4953 under Audio_-&gt;Driver-&gt;Codec_ in the Available Components list. You will then need to add any additional needed components manually and connect them together.</p>
<p class="p">Note that the AK4953 requires the TCx Peripheral Library and TIME System Service in order to perform some of its internal timing sequences.</p>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title17" id="bulding-the-library"><h3 class="title topictitle3" id="ariaid-title17">Bulding the Library</h3><div class="body"><p class="p">This section lists the files that are available in the AK4953 Codec Driver Library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section lists the files that are available in the src folder of the AK4953 Codec Driver. It lists which files need to be included in the build based on either a hardware feature present on the board or configuration option selected by the system.</p>
<p class="p">The following three tables list and describe the header (.h) and source (.c) files that implement this library. The parent folder for these files is audio/driver/codec/AK4953\. <strong class="ph b">Interface File(s)</strong></p>
<p class="p">This table lists and describes the header files that must be included (i.e., using #include) by any code that uses this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e445"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e448"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e445 "><span>drv_ak4953.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e448 "><span>Header file that exports the driver API.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title18" id="required-files"><h4 class="title topictitle4" id="ariaid-title18">Required File(s)</h4><div class="body"><p class="p"><img class="image" src="GUID-B924D07A-0D74-453B-BCDE-8190A195C55D-low.png" /><br /> <strong class="ph b"><em class="ph i">All of the required files listed in the following table are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use.</em></strong></p>
<p class="p">This table lists and describes the source and header files that must <em class="ph i">always</em> be included in the MPLAB X IDE project to build this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e478"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e481"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e478 "><span>/src/drv_ak4953.c</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e481 "><span>This file contains implementation of the AK4953 Codec Driver.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title19" id="optional-files"><h4 class="title topictitle4" id="ariaid-title19">Optional File(s)</h4><div class="body"><p class="p">This table lists and describes the source and header files that may optionally be included if required for the desired implementation.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e502"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e505"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e502 "><span>N/A</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e505 "><span>No optional files are available for this library.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title20" id="module-dependencies"><h4 class="title topictitle4" id="ariaid-title20">Module Dependencies</h4><div class="body"><p class="p">The AK4953 Codec Driver Library depends on the following modules:</p>
<ul class="ul"><li class="li"><p class="p">I2S Driver Library</p>
</li>
<li class="li"><p class="p">I2C Driver Library</p>
</li>
</ul>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title21" id="library-interface"><h3 class="title topictitle3" id="ariaid-title21">Library Interface</h3><div class="body"><p class="p"><strong class="ph b">Client Setup Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e541"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e543"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e546"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e541 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e543 "><span>DRV_AK4953_Close</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e546 "><span>Closes an opened-instance of the AK4953 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e541 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e543 "><span>DRV_AK4953_CommandEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e546 "><span>This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e541 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e543 "><span>DRV_AK4953_Open</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e546 "><span>Opens the specified AK4953 driver instance and returns a handle to it.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e541 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e543 "><span>DRV_AK4953_BufferEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e546 "><span>This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Transfer Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e588"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e590"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e593"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e588 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e590 "><span>DRV_AK4953_BufferAddRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e593 "><span>Schedule a non-blocking driver read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e588 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e590 "><span>DRV_AK4953_BufferAddWrite</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e593 "><span>Schedule a non-blocking driver write operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e588 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e590 "><span>DRV_AK4953_BufferAddWriteRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e593 "><span>Schedule a non-blocking driver write-read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e588 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e590 "><span>DRV_AK4953_ReadQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e593 "><span>Removes all buffer requests from the read queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e588 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e590 "><span>DRV_AK4953_WriteQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e593 "><span>Removes all buffer requests from the write queue.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Types and Constants</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e642"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e644"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e647"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_AUDIO_DATA_FORMAT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies the Serial Audio data interface format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_BUFFER_EVENT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies the possible events that can result from a buffer add request.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_BUFFER_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Pointer to a AK4953 Driver Buffer Event handler function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_BUFFER_HANDLE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Handle identifying a write buffer passed to the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_CHANNEL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies Left/Right Audio channel</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_COMMAND_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Pointer to a AK4953 Driver Command Event Handler Function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_DIGITAL_BLOCK_CONTROL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies Bass-Boost Control function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_INIT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Defines the data required to initialize or reinitialize the AK4953 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_INT_EXT_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies the Mic input source.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>This is type DRV_AK4953_MIC.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e642 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e644 "><span>DRV_AK4953_MONO_STEREO_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e647 "><span>Identifies the Mic input as Mono / Stereo.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Other Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e738"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e740"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e743"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e738 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e740 "><span>DRV_AK4953_GetI2SDriver</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e743 "><span>Get the handle to the I2S driver for this codec instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e738 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e740 "><span>DRV_AK4953_LRCLK_Sync</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e743 "><span>Synchronize to the start of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e738 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e740 "><span>DRV_AK4953_VersionGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e743 "><span>This function returns the version of AK4953 driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e738 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e740 "><span>DRV_AK4953_VersionStrGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e743 "><span>This function returns the version of AK4953 driver in string format.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Settings Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e785"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e787"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e790"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_IntExtMicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets up the codec for the X32 DB internal or the external microphone use.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MicGainGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function gets the microphone gain for the AK4953 Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MicGainSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets the microphone gain for the AK4953 CODEC.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MicMuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>Umutes th AK4953's microphone input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MicMuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>Mutes the AK4953's microphone input</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets up the codec for the internal or the AK4953 Mic1 or Mic2 input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MonoStereoMicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets up the codec for the Mono or Stereo microphone mode.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function disables AK4953 output for soft mute.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_MuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function allows AK4953 output for soft mute on.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_SamplingRateGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function gets the sampling rate set on the DAC AK4953.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_SamplingRateSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets the sampling rate of the media stream.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_VolumeGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function gets the volume for AK4953 Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e785 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e787 "><span>DRV_AK4953_VolumeSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e790 "><span>This function sets the volume for AK4953 Codec.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">System Interaction Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e897"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e899"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e902"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_Deinitialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Deinitializes the specified instance of the AK4953 driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_EnableInitialization</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Enable delayed initialization of the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Initializes hardware and data for the instance of the AK4953 Codec module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_IsInitializationDelayed</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Checks if delayed initialization of the driver has been requested.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_Status</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Gets the current status of the AK4953 driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e897 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e899 "><span>DRV_AK4953_Tasks</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e902 "><span>Maintains the driver's control and data interface state machine.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title22" id="system-interaction-functions"><h2 class="title topictitle2" id="ariaid-title22">System Interaction Functions</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title23" id="drv-ak4953-deinitialize-function"><h3 class="title topictitle3" id="ariaid-title23">DRV_AK4953_Deinitialize Function</h3><div class="body"><p class="p">void DRV_AK4953_Deinitialize( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Deinitializes the specified instance of the AK4953 driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Deinitializes the specified instance of the AK4953 driver module, disabling its operation (and any hardware). Invalidates all the internal data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4953_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e985"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e988"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e985 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e988 "><span>Driver object handle, returned from the DRV_AK4953_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Once the Initialize operation has been called, the De-initialize operation must be called before the Initialize operation can be called again. This routine will NEVER block waiting for hardware.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4953_Initialize</em></p>
<p class="p">SYS_STATUS status;</p>
<p class="p">DRV_AK4953_Deinitialize(object); status = DRV_AK4953_Status(object); <strong class="ph b">if</strong> (SYS_MODULE_DEINITIALIZED != status) {</p>
<p class="p"><em class="ph i">// Check again later if you need to know</em> <em class="ph i">// when the driver is deinitialized.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_Deinitialize</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title24" id="drv-ak4953-enableinitialization-function"><h3 class="title topictitle3" id="ariaid-title24">DRV_AK4953_EnableInitialization Function</h3><div class="body"><p class="p">void DRV_AK4953_EnableInitialization(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Enable delayed initialization of the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">If the AK4953 codec is sharing a RESET line with another peripheral, such as a Bluetooth module with its own driver, then the codec driver initialization has to be delayed until after the Bluetooth module has toggled its RESET pin. Once this has been accomplished, this function should be called to kick-start the codec driver initialization.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1073"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1076"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1073 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1076 "><span>Object handle for the specified driver instance (returned from DRV_AK4953_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This is not needed for audio-only applications without a Bluetooth module.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_EnableInitialization</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title25" id="drv-ak4953-initialize-function"><h3 class="title topictitle3" id="ariaid-title25">DRV_AK4953_Initialize Function</h3><div class="body"><p class="p">SYS_MODULE_OBJ DRV_AK4953_Initialize</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const SYS_MODULE_INIT *const init</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes hardware and data for the instance of the AK4953 Codec module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine initializes the AK4953 driver instance for the specified driver index, making it ready for clients to open and use it. The initialization data is specified by the init parameter. The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Initialize must be called before calling this function to initialize the data interface of this Codec driver. DRV_I2C_Initialize must be called if SPI driver is used for handling the control interface of this Codec driver.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1146"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1149"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1146 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1149 "><span>Identifier for the driver instance to be initialized</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1146 "><span>init</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1149 "><span>Pointer to the data structure containing any data necessary to initialize the hardware. This pointer may be null if no data is required and default initialization is to be used.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, returns a valid handle to a driver instance object. Otherwise, it returns SYS_MODULE_OBJ_INVALID.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine must be called before any other AK4953 routine is called.</p>
<p class="p">This routine should only be called once during system initialization unless DRV_AK4953_Deinitialize is called to deinitialize the driver instance. This routine will NEVER block for hardware access.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_AK4953_INIT init;</p>
<p class="p">SYS_MODULE_OBJ objectHandle; init-&gt;inUse = <strong class="ph b">true</strong>; init-&gt;status = SYS_STATUS_BUSY; init-&gt;numClients = 0; init-&gt;i2sDriverModuleIndex = ak4953Init-&gt;i2sDriverModuleIndex; init-&gt;i2cDriverModuleIndex = ak4953Init-&gt;i2cDriverModuleIndex; init-&gt;samplingRate = DRV_AK4953_AUDIO_SAMPLING_RATE; init-&gt;audioDataFormat = DRV_AK4953_AUDIO_DATA_FORMAT_MACRO; <strong class="ph b">for</strong>(index=0; index &lt; DRV_AK4953_NUMBER_OF_CHANNELS; index++) {</p>
<p class="p">init-&gt;volume<span class="xref"></span> = ak4953Init-&gt;volume; } init-&gt;isInInterruptContext = <strong class="ph b">false</strong>; init-&gt;commandCompleteCallback = (DRV_AK4953_COMMAND_EVENT_HANDLER)0; init-&gt;commandContextData = 0; init-&gt;mclk_multiplier = DRV_AK4953_MCLK_SAMPLE_FREQ_MULTPLIER; objectHandle = DRV_AK4953_Initialize(DRV_AK4953_0, (SYS_MODULE_INIT*)init); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == objectHandle) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_MODULE_OBJ <strong class="ph b">DRV_AK4953_Initialize</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">drvIndex</strong>, <strong class="ph b">const</strong> SYS_MODULE_INIT * <strong class="ph b">const</strong> <strong class="ph b">init</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title26" id="drv-ak4953-isinitializationdelayed-function"><h3 class="title topictitle3" id="ariaid-title26">DRV_AK4953_IsInitializationDelayed Function</h3><div class="body"><p class="p">bool DRV_AK4953_IsInitializationDelayed(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Checks if delayed initialization of the driver has been requested.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">If the AK4953 codec is sharing a RESET line with another peripheral, such as a Bluetooth module with its own driver, then the codec driver initialization has to be delayed until after the Bluetooth module has toggled its RESET pin. This function returns true if that option has been selected in MHC in the checkbox: "Delay driver initialization (due to shared RESET pin)"</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1259"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1262"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1259 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1262 "><span>Object handle for the specified driver instance (returned from DRV_AK4953_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the delayed initialization option has been enabled</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This is not needed for audio-only applications without a Bluetooth module.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4953_IsInitializationDelayed</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title27" id="drv-ak4953-status-function"><h3 class="title topictitle3" id="ariaid-title27">DRV_AK4953_Status Function</h3><div class="body"><p class="p">SYS_STATUS DRV_AK4953_Status( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the current status of the AK4953 driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine provides the current status of the AK4953 driver module.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4953_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1325"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1328"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1325 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1328 "><span>Driver object handle, returned from the DRV_AK4953_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized</p>
<p class="p">SYS_STATUS_READY - Indicates that any previous module operation for the specified module has completed</p>
<p class="p">SYS_STATUS_BUSY - Indicates that a previous module operation for the specified module has not yet completed</p>
<p class="p">SYS_STATUS_ERROR - Indicates that the specified module is in an error state</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">A driver can opened only when its status is SYS_STATUS_READY.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4953_Initialize</em></p>
<p class="p">SYS_STATUS AK4953Status;</p>
<p class="p">AK4953Status = DRV_AK4953_Status(object); <strong class="ph b">if</strong> (SYS_STATUS_READY == AK4953Status) {</p>
<p class="p"><em class="ph i">// This means the driver can be opened using the</em> <em class="ph i">// DRV_AK4953_Open() function.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_STATUS <strong class="ph b">DRV_AK4953_Status</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title28" id="drv-ak4953-tasks-function"><h3 class="title topictitle3" id="ariaid-title28">DRV_AK4953_Tasks Function</h3><div class="body"><p class="p">void DRV_AK4953_Tasks(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Maintains the driver's control and data interface state machine.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine is used to maintain the driver's internal control and data interface state machine and implement its control and data interface implementations. This function should be called from the SYS_Tasks() function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1418"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1421"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1418 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1421 "><span>Object handle for the specified driver instance (returned from DRV_AK4953_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine is normally not called directly by an application. It is called by the system's Tasks routine (SYS_Tasks).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4953_Initialize</em> <strong class="ph b">while</strong> (<strong class="ph b">true</strong>) {</p>
<p class="p">DRV_AK4953_Tasks (object);</p>
<p class="p"><em class="ph i">// Do other tasks</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_Tasks</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title29" id="client-setup-functions"><h2 class="title topictitle2" id="ariaid-title29">Client Setup Functions</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title30" id="drv-ak4953-close-function"><h3 class="title topictitle3" id="ariaid-title30">DRV_AK4953_Close Function</h3><div class="body"><p class="p">void DRV_AK4953_Close( DRV_Handle handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Closes an opened-instance of the AK4953 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine closes an opened-instance of the AK4953 driver, invalidating the handle. Any buffers in the driver queue that were submitted by this client will be removed. After calling this routine, the handle passed in "handle" must not be used with any of the remaining driver routines. A new handle must be obtained by calling DRV_AK4953_Open before the caller may use the driver again</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1511"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1514"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1511 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1514 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Usually there is no need for the driver client to verify that the Close operation has completed. The driver will abort any ongoing operations when this routine is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; <em class="ph i">// Returned from DRV_AK4953_Open</em></p>
<p class="p">DRV_AK4953_Close(handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_Close</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title31" id="drv-ak4953-commandeventhandlerset-function"><h3 class="title topictitle3" id="ariaid-title31">DRV_AK4953_CommandEventHandlerSet Function</h3><div class="body"><p class="p">void DRV_AK4953_CommandEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_AK4953_COMMAND_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p">When a client calls DRV_AK4953_BufferAddWrite function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "AK4953 CODEC Specific Client Routines" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1604"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1607"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1604 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1607 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1604 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1607 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1604 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1607 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the command has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4953_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4953_CommandEventHandlerSet(myAK4953Handle,</p>
<p class="p">APP_AK4953CommandEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4953_DeEmphasisFilterSet(myAK4953Handle, DRV_AK4953_DEEMPHASIS_FILTER_44_1KHZ)</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em> <strong class="ph b">void</strong> APP_AK4953CommandEventHandler(uintptr_t contextHandle) { <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <em class="ph i">// Last Submitted command is completed.</em></p>
<p class="p"><em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_CommandEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_AK4953_COMMAND_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title32" id="drv-ak4953-open-function"><h3 class="title topictitle3" id="ariaid-title32">DRV_AK4953_Open Function</h3><div class="body"><p class="p">DRV_HANDLE DRV_AK4953_Open</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT ioIntent</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Opens the specified AK4953 driver instance and returns a handle to it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine opens the specified AK4953 driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver. The ioIntent parameter defines how the client interacts with this driver instance.</p>
<p class="p">The DRV_IO_INTENT_BLOCKING and DRV_IO_INTENT_NONBLOCKING ioIntent options are not relevant to this driver. All the data transfer functions of this driver are non blocking.</p>
<p class="p">AK4953 can be opened with DRV_IO_INTENT_WRITE, or DRV_IO_INTENT_READ or DRV_IO_INTENT_WRITEREAD io_intent option. This decides whether the driver is used for headphone output, or microphone input or both modes simultaneously.</p>
<p class="p">Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client. The driver cannot be opened by any other client.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4953_Initialize must have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1751"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1754"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1751 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1754 "><span>Identifier for the object instance to be opened</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1751 "><span>ioIntent</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1754 "><span>Zero or more of the values from the enumeration DRV_IO_INTENT "ORed" together to indicate the intended use of the driver. See function description for details.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, the routine returns a valid open-instance handle (a number identifying both the caller and the module instance).</p>
<p class="p">If an error occurs, the return value is DRV_HANDLE_INVALID. Error can occur</p>
<ul class="ul"><li class="li"><p class="p">if the number of client objects allocated via DRV_AK4953_CLIENTS_NUMBER is insufficient.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver but driver has been opened exclusively by another client.</p>
</li>
<li class="li"><p class="p">if the driver hardware instance being opened is not initialized or is invalid.</p>
</li>
<li class="li"><p class="p">if the ioIntent options passed are not relevant to this driver.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The handle returned is valid until the DRV_AK4953_Close routine is called. This routine will NEVER block waiting for hardware.If the requested intent flags are not supported, the routine will return DRV_HANDLE_INVALID. This function is thread safe in a RTOS application. It should not be called in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; handle = DRV_AK4953_Open(DRV_AK4953_INDEX_0, DRV_IO_INTENT_WRITEREAD | DRV_IO_INTENT_EXCLUSIVE); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em></p>
<p class="p"><em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_AK4953_Open</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">iDriver</strong>, <strong class="ph b">const</strong> DRV_IO_INTENT <strong class="ph b">ioIntent</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title33" id="drv-ak4953-buffereventhandlerset-function"><h3 class="title topictitle3" id="ariaid-title33">DRV_AK4953_BufferEventHandlerSet Function</h3><div class="body"><p class="p">void DRV_AK4953_BufferEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_AK4953_BUFFER_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished. When a client calls DRV_AK4953_BufferAddRead function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "buffer add" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1876"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e1879"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1876 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1879 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1876 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1879 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1876 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e1879 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the queued buffer transfer has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4953_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4953_BufferEventHandlerSet(myAK4953Handle,</p>
<p class="p">APP_AK4953BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4953_BufferAddRead(myAK4953handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_AK4953_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4953BufferEventHandler(DRV_AK4953_BUFFER_EVENT event, DRV_AK4953_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_BufferEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_AK4953_BUFFER_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title34" id="data-transfer-functions"><h2 class="title topictitle2" id="ariaid-title34">Data Transfer Functions</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title35" id="drv-ak4953-bufferaddread-function"><h3 class="title topictitle3" id="ariaid-title35">DRV_AK4953_BufferAddRead Function</h3><div class="body"><p class="p">void DRV_AK4953_BufferAddRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4953_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking read operation. The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully. The function adds the request to the hardware instance receive queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4953_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4953_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4953_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 device instance and the DRV_AK4953_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle. DRV_IO_INTENT_READ must have been specified in the DRV_AK4953_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2071"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2074"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2071 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2074 "><span>Handle of the AK4953 instance as return by the DRV_AK4953_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2071 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2074 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2071 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2074 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2071 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2074 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4953_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4953 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4953 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_BufferAddRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title36" id="drv-ak4953-bufferaddwrite-function"><h3 class="title topictitle3" id="ariaid-title36">DRV_AK4953_BufferAddWrite Function</h3><div class="body"><p class="p">void DRV_AK4953_BufferAddWrite</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4953_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write operation. The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully. The function adds the request to the hardware instance transmit queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4953_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4953_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4953_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 device instance and the DRV_AK4953_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_WRITE must have been specified in the DRV_AK4953_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2198"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2201"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2198 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2201 "><span>Handle of the AK4953 instance as return by the DRV_AK4953_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2198 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2201 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2198 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2201 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2198 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2201 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4953_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4953 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4953 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4953_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4953_BufferEventHandlerSet(myAK4953Handle,</p>
<p class="p">APP_AK4953BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4953_BufferAddWrite(myAK4953handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_AK4953_BUFFER_HANDLE_INVALID == bufferHandle) { <em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4953BufferEventHandler(DRV_AK4953_BUFFER_EVENT event, DRV_AK4953_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_BufferAddWrite</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title37" id="drv-ak4953-bufferaddwriteread-function"><h3 class="title topictitle3" id="ariaid-title37">DRV_AK4953_BufferAddWriteRead Function</h3><div class="body"><p class="p">void DRV_AK4953_BufferAddWriteRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4953_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *transmitBuffer, void *receiveBuffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write-read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write-read operation. The function returns with a valid buffer handle in the bufferHandle argument if the write-read request was scheduled successfully. The function adds the request to the hardware instance queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4953_BUFFER_EVENT_COMPLETE:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only or write only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4953_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4953_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 device instance and the DRV_AK4953_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_READWRITE must have been specified in the DRV_AK4953_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2399"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2402"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2399 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2402 "><span>Handle of the AK4953 instance as returned by the DRV_AK4953_Open function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2399 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2402 "><span>Pointer to an argument that will contain the return buffer handle</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2399 "><span>transmitBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2402 "><span>The buffer where the transmit data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2399 "><span>receiveBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2402 "><span>The buffer where the received data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2399 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2402 "><span>Buffer size in bytes</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4953_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4953 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4953 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p">This function is useful when there is valid read expected for every AK4953 write. The transmit and receive size must be same.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj; uint8_t mybufferTx<span class="xref"></span>; uint8_t mybufferRx<span class="xref"></span>; DRV_AK4953_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myak4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4953_BufferEventHandlerSet(myak4953Handle,</p>
<p class="p">APP_AK4953BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4953_BufferAddWriteRead(myak4953handle, &amp;bufferHandle, mybufferTx,mybufferRx,MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_AK4953_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4953BufferEventHandler(DRV_AK4953_BUFFER_EVENT event, DRV_AK4953_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_BufferAddWriteRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">transmitBuffer</strong>, <strong class="ph b">void</strong> * <strong class="ph b">receiveBuffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title38" id="drv-ak4953-readqueuepurge-function"><h3 class="title topictitle3" id="ariaid-title38">DRV_AK4953_ReadQueuePurge Function</h3><div class="body"><p class="p">bool DRV_AK4953_ReadQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the read queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the read queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2582"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2585"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2582 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2585 "><span>Handle of the communication channel as returned by the DRV_AK4953_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Read queue purge is successful. False - Read queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_AK4953_BufferAddRead to queue read requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_AK4953_ReadQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the read queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4953_ReadQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title39" id="drv-ak4953-writequeuepurge-function"><h3 class="title topictitle3" id="ariaid-title39">DRV_AK4953_WriteQueuePurge Function</h3><div class="body"><p class="p">bool DRV_AK4953_WriteQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the write queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the write queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2689"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2692"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2689 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2692 "><span>Handle of the communication channel as returned by the DRV_AK4953_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Write queue purge is successful. False - Write queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_AK4953_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_AK4953_BufferAddWrite to queue write requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_AK4953_WriteQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the write queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4953_WriteQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title40" id="settings-functions"><h2 class="title topictitle2" id="ariaid-title40">Settings Functions</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title41" id="drv-ak4953-intextmicset-function"><h3 class="title topictitle3" id="ariaid-title41">DRV_AK4953_IntExtMicSet Function</h3><div class="body"><p class="p">void DRV_AK4953_IntExtMicSet</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the X32 DB internal or the external microphone use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec for the internal or the external microphone use.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2802"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2805"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2802 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2805 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2802 "><span>micInput</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2805 "><span>Internal vs External mic input</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_IntExtMicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_INT_EXT_MIC <strong class="ph b">micInput</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title42" id="drv-ak4953-micgainget-function"><h3 class="title topictitle3" id="ariaid-title42">DRV_AK4953_MicGainGet Function</h3><div class="body"><p class="p">uint8_t DRV_AK4953_MicGainGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the microphone gain for the AK4953 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current microphone gain programmed to the Codec AK4953.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2878"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2881"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2878 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2881 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Microphone gain, in range 0-31.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t gain;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">gain = DRV_AK4953_MicGainGet(myAK4953Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_AK4953_MicGainGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title43" id="drv-ak4953-micgainset-function"><h3 class="title topictitle3" id="ariaid-title43">DRV_AK4953_MicGainSet Function</h3><div class="body"><p class="p">void DRV_AK4953_MicGainSet(DRV_HANDLE handle, uint8_t gain)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the microphone gain for the AK4953 CODEC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the microphone gain value from 0-31 which can range from -1.5 to 28.3 dB</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2956"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e2959"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2956 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2959 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2956 "><span>gain</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e2959 "><span>Gain value, in range 0-31</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_MicGainSet(myAK4953Handle, 15); <em class="ph i">//AK4953 mic gain set to 15</em></p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MicGainSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint8_t <strong class="ph b">gain</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title44" id="drv-ak4953-micmuteoff-function"><h3 class="title topictitle3" id="ariaid-title44">DRV_AK4953_MicMuteOff Function</h3><div class="body"><p class="p">void DRV_AK4953_MicMuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Umutes th AK4953's microphone input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function unmutes the AK4953's microphone input.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3044"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3047"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3044 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3047 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_MicMuteOff(myAK4953Handle); <em class="ph i">//AK4953 microphone unmuted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MicMuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title45" id="drv-ak4953-micmuteon-function"><h3 class="title topictitle3" id="ariaid-title45">DRV_AK4953_MicMuteOn Function</h3><div class="body"><p class="p">void DRV_AK4953_MicMuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Mutes the AK4953's microphone input</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function mutes the AK4953's microphone input</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3127"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3130"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3127 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3130 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_MicMuteOn(myAK4953Handle); <em class="ph i">//AK4953 microphone muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MicMuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title46" id="drv-ak4953-micset-function"><h3 class="title topictitle3" id="ariaid-title46">DRV_AK4953_MicSet Function</h3><div class="body"><p class="p">void DRV_AK4953_IntMic12Set</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the internal or the AK4953 Mic1 or Mic2 input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3210"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3213"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3210 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3213 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3210 "><span>micInput</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3213 "><span>Internal vs External mic input</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_MIC <strong class="ph b">micInput</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title47" id="drv-ak4953-monostereomicset-function"><h3 class="title topictitle3" id="ariaid-title47">DRV_AK4953_MonoStereoMicSet Function</h3><div class="body"><p class="p">void DRV_AK4953_MonoStereoMicSet(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the Mono or Stereo microphone mode.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec for the Mono or Stereo microphone mode.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3286"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3289"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3286 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3289 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MonoStereoMicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_MONO_STEREO_MIC <strong class="ph b">mono_stereo_mic</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title48" id="drv-ak4953-muteoff-function"><h3 class="title topictitle3" id="ariaid-title48">DRV_AK4953_MuteOff Function</h3><div class="body"><p class="p">void DRV_AK4953_MuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function disables AK4953 output for soft mute.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function disables AK4953 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3357"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3360"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3357 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3360 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_MuteOff(myAK4953Handle); <em class="ph i">//AK4953 output soft mute disabled</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title49" id="drv-ak4953-muteon-function"><h3 class="title topictitle3" id="ariaid-title49">DRV_AK4953_MuteOn Function</h3><div class="body"><p class="p">void DRV_AK4953_MuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows AK4953 output for soft mute on.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function Enables AK4953 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3445"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3448"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3445 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3448 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_MuteOn(myAK4953Handle); <em class="ph i">//AK4953 output soft muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_MuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title50" id="drv-ak4953-samplingrateget-function"><h3 class="title topictitle3" id="ariaid-title50">DRV_AK4953_SamplingRateGet Function</h3><div class="body"><p class="p">uint32_t DRV_AK4953_SamplingRateGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the sampling rate set on the DAC AK4953.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function gets the sampling rate set on the DAC AK4953.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3534"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3537"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3534 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3537 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint32_t baudRate;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">baudRate = DRV_AK4953_SamplingRateGet(myAK4953Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_AK4953_SamplingRateGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title51" id="drv-ak4953-samplingrateset-function"><h3 class="title topictitle3" id="ariaid-title51">DRV_AK4953_SamplingRateSet Function</h3><div class="body"><p class="p">void DRV_AK4953_SamplingRateSet(DRV_HANDLE handle, uint32_t samplingRate)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the sampling rate of the media stream.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the media sampling rate for the client handle.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3610"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3613"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3610 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3613 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_SamplingRateSet(myAK4953Handle, 48000); <em class="ph i">//Sets 48000 media sampling rate</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_SamplingRateSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint32_t <strong class="ph b">samplingRate</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title52" id="drv-ak4953-volumeget-function"><h3 class="title topictitle3" id="ariaid-title52">DRV_AK4953_VolumeGet Function</h3><div class="body"><p class="p">uint8_t DRV_AK4953_VolumeGet(DRV_HANDLE handle, DRV_AK4953_CHANNEL chan)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the volume for AK4953 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current volume programmed to the CODEC AK4953.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3691"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3694"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3691 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3694 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3691 "><span>chan</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3694 "><span>Audio channel volume to be set</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t volume;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">volume = DRV_AK4953_VolumeGet(myAK4953Handle,DRV_AK4953_CHANNEL_LEFT);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_AK4953_VolumeGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_CHANNEL <strong class="ph b">chan</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title53" id="drv-ak4953-volumeset-function"><h3 class="title topictitle3" id="ariaid-title53">DRV_AK4953_VolumeSet Function</h3><div class="body"><p class="p">void DRV_AK4953_VolumeSet(DRV_HANDLE handle, DRV_AK4953_CHANNEL channel, uint8_t volume);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the volume for AK4953 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the volume value from 0-255. The codec has DAC value to volume range mapping as :- 00 H : +12dB FF H : -115dB In order to make the volume value to dB mapping monotonically increasing from 00 to FF, re-mapping is introduced which reverses the volume value to dB mapping as well as normalizes the volume range to a more audible dB range. The current driver implementation assumes that all dB values under -60 dB are inaudible to the human ear. Re-Mapped values 00 H : -60 dB FF H : +12 dB</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3777"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3780"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3777 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3780 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3777 "><span>chan</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3780 "><span>Audio channel volume to be set</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3777 "><span>volume</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3780 "><span>volume value specified in the range 0-255 (0x00 to 0xFF)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned // by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_VolumeSet(myAK4953Handle, DRV_AK4953_CHANNEL_LEFT, 120);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4953_VolumeSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4953_CHANNEL <strong class="ph b">channel</strong>, uint8_t <strong class="ph b">volume</strong>);</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title54" id="other-functions"><h2 class="title topictitle2" id="ariaid-title54">Other Functions</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title55" id="drv-ak4953-geti2sdriver-function"><h3 class="title topictitle3" id="ariaid-title55">DRV_AK4953_GetI2SDriver Function</h3><div class="body"><p class="p">DRV_HANDLE DRV_AK4953_GetI2SDriver(DRV_HANDLE codecHandle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the handle to the I2S driver for this codec instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Returns the appropriate handle to the I2S based on the ioIent member of the codec object.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4953_Initialize routine must have been called for the specified AK4953 driver instance.</p>
<p class="p">DRV_AK4953_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3883"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3886"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3883 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3886 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<ul class="ul"><li class="li"><p class="p">A handle to the I2S driver for this codec instance</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This allows the caller to directly access portions of the I2S driver that might not be available via the codec API.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_AK4953_GetI2SDriver</strong>(DRV_HANDLE <strong class="ph b">codecHandle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title56" id="drv-ak4953-lrclk-sync-function"><h3 class="title topictitle3" id="ariaid-title56">DRV_AK4953_LRCLK_Sync Function</h3><div class="body"><p class="p">uint32_t DRV_AK4953_LRCLK_Sync (const DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Synchronize to the start of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function waits until low-to high transition of the I2S LRCLK (left/right clock) signal (high-low if Left-Justified format, this is determined by the PLIB). In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize calls to the DMA with the LRCLK signal so the left/right channel association is valid.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3949"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e3952"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3949 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e3952 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAK4953Handle is the handle returned</em> <em class="ph i">// by the DRV_AK4953_Open function.</em></p>
<p class="p">DRV_AK4953_LRCLK_Sync(myAK4953Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4953_LRCLK_Sync</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title57" id="drv-ak4953-versionget-function"><h3 class="title topictitle3" id="ariaid-title57">DRV_AK4953_VersionGet Function</h3><div class="body"><p class="p">uint32_t DRV_AK4953_VersionGet( void )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of AK4953 driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The version number returned from the DRV_AK4953_VersionGet function is an unsigned integer in the following decimal format. * 10000 + * 100 + Where the numbers are represented in decimal and the meaning is the same as above. Note that there is no numerical representation of release type.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns the version of AK4953 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">For version "0.03a", return: 0 * 10000 + 3 * 100 + 0 For version "1.00", return: 1 * 100000 + 0 * 100 + 0</p>
<p class="p"><strong class="ph b">Example 2</strong></p>
<p class="p">uint32_t AK4953version; AK4953version = DRV_AK4953_VersionGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_AK4953_VersionGet</strong>();</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title58" id="drv-ak4953-versionstrget-function"><h3 class="title topictitle3" id="ariaid-title58">DRV_AK4953_VersionStrGet Function</h3><div class="body"><p class="p">int8_t* DRV_AK4953_VersionStrGet(void)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of AK4953 driver in string format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The DRV_AK4953_VersionStrGet function returns a string in the format: ".<span class="xref"></span>" Where: is the AK4953 driver's version number. is the AK4953 driver's version number. is an optional "patch" or "dot" release number (which is not included in the string if it equals "00"). is an optional release type ("a" for alpha, "b" for beta ? not the entire word spelled out) that is not included if the release is a production version (I.e. Not an alpha or beta).</p>
<p class="p">The String does not contain any spaces.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns a string containing the version of AK4953 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">"0.03a" "1.00"</p>
<p class="p"><strong class="ph b">Example 2</strong></p>
<p class="p">int8_t *AK4953string; AK4953string = DRV_AK4953_VersionStrGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int8_t* <strong class="ph b">DRV_AK4953_VersionStrGet</strong>();</p>
<p class="p"><strong class="ph b">Data Types and Constants</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title59" id="drv-ak4953-audio-data-format-type"><h2 class="title topictitle2" id="ariaid-title59"><em class="ph i">DRV_AK4953_AUDIO_DATA_FORMAT Type</em></h2><div class="body"><p class="p">Identifies the Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Audio data format</p>
<p class="p">This enumeration identifies Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_AUDIO_DATA_FORMAT@1 <strong class="ph b">DRV_AK4953_AUDIO_DATA_FORMAT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title60" id="drv-ak4953-buffer-event-type"><h2 class="title topictitle2" id="ariaid-title60"><em class="ph i">DRV_AK4953_BUFFER_EVENT Type</em></h2><div class="body"><p class="p">Identifies the possible events that can result from a buffer add request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Driver Events</p>
<p class="p">This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_AK4953_BufferAddWrite() or the DRV_AK4953_BufferAddRead() function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">One of these values is passed in the "event" parameter of the event handling callback function that the client registered with the driver by calling the DRV_AK4953_BufferEventHandlerSet function when a buffer transfer request is completed.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_BUFFER_EVENT@1 <strong class="ph b">DRV_AK4953_BUFFER_EVENT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title61" id="drv-ak4953-buffer-event-handler-type"><h2 class="title topictitle2" id="ariaid-title61"><em class="ph i">DRV_AK4953_BUFFER_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a AK4953 Driver Buffer Event handler function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Driver Buffer Event Handler Function</p>
<p class="p">This data type defines the required function signature for the AK4953 driver buffer event handling callback function. A client must register a pointer to a buffer event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4191"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4194"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4191 "><span>event</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4194 "><span>Identifies the type of event</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4191 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4194 "><span>Handle identifying the buffer to which the event relates</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4191 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4194 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the event is DRV_AK4953_BUFFER_EVENT_COMPLETE, this means that the data was transferred successfully.</p>
<p class="p">If the event is DRV_AK4953_BUFFER_EVENT_ERROR, this means that the data was not transferred successfully. The bufferHandle parameter contains the buffer handle of the buffer that failed. The DRV_AK4953_BufferProcessedSizeGet() function can be called to find out how many bytes were processed.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that associated with the event.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_AK4953_BufferEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The buffer handle in bufferHandle expires after this event handler exits. In that the buffer object that was allocated is deallocated by the driver after the event handler exits.</p>
<p class="p">The event handler function executes in the data driver(i2S) peripheral's interrupt context when the driver is configured for interrupt mode operation. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p">DRV_AK4953_BufferAddWrite function can be called in the event handler to add a buffer to the driver queue.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_MyBufferEventHandler( DRV_AK4953_BUFFER_EVENT event, DRV_AK4953_BUFFER_HANDLE bufferHandle, uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_COMPLETE: <em class="ph i">// Handle the completed buffer.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4953_BUFFER_EVENT_ERROR:</p>
<p class="p"><strong class="ph b">default</strong>: <em class="ph i">// Handle error.</em></p>
<p class="p"><strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_AK4953_BUFFER_EVENT_HANDLER</strong>)(DRV_AK4953_BUFFER_EVENT event, DRV_AK4953_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title62" id="drv-ak4953-buffer-handle-type"><h2 class="title topictitle2" id="ariaid-title62"><em class="ph i">DRV_AK4953_BUFFER_HANDLE Type</em></h2><div class="body"><p class="p">Handle identifying a write buffer passed to the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Driver Buffer Handle</p>
<p class="p">A buffer handle value is returned by a call to the DRV_AK4953_BufferAddWrite() or DRV_AK4953_BufferAddRead() function. This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer.</p>
<p class="p">The buffer handle value returned from the "buffer add" function is returned back to the client by the "event handler callback" function registered with the driver.</p>
<p class="p">The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> uintptr_t <strong class="ph b">DRV_AK4953_BUFFER_HANDLE</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title63" id="drv-ak4953-channel-type"><h2 class="title topictitle2" id="ariaid-title63"><em class="ph i">DRV_AK4953_CHANNEL Type</em></h2><div class="body"><p class="p">Identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Audio Channel</p>
<p class="p">This enumeration identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_CHANNEL@1 <strong class="ph b">DRV_AK4953_CHANNEL</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title64" id="drv-ak4953-command-event-handler-type"><h2 class="title topictitle2" id="ariaid-title64"><em class="ph i">DRV_AK4953_COMMAND_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a AK4953 Driver Command Event Handler Function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Driver Command Event Handler Function</p>
<p class="p">This data type defines the required function signature for the AK4953 driver command event handling callback function.</p>
<p class="p">A command is a control instruction to the AK4953 Codec. Example Mute ON/OFF, Zero Detect Enable/Disable etc.</p>
<p class="p">A client must register a pointer to a command event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive command related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4380"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4383"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4380 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4383 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The occurrence of this call back means that the last control command was transferred successfully.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_AK4953_CommandEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The event handler function executes in the control data driver interrupt context. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4953CommandEventHandler( uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context;</p>
<p class="p"><em class="ph i">// Last Submitted command is completed.</em></p>
<p class="p"><em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_AK4953_COMMAND_EVENT_HANDLER</strong>)(uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title65" id="drv-ak4953-digital-block-control-type"><h2 class="title topictitle2" id="ariaid-title65"><em class="ph i">DRV_AK4953_DIGITAL_BLOCK_CONTROL Type</em></h2><div class="body"><p class="p">Identifies Bass-Boost Control function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Bass-Boost Control</p>
<p class="p">This enumeration identifies the settings for Bass-Boost Control function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_DIGITAL_BLOCK_CONTROL@1 <strong class="ph b">DRV_AK4953_DIGITAL_BLOCK_CONTROL</strong>;</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title66" id="drv-ak4953-init-type"><h3 class="title topictitle3" id="ariaid-title66">DRV_AK4953_INIT Type</h3><div class="body"><p class="p">Defines the data required to initialize or reinitialize the AK4953 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Driver Initialization Data</p>
<p class="p">This data type defines the data required to initialize or reinitialize the AK4953 Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">struct</strong> DRV_AK4953_INIT@1 <strong class="ph b">DRV_AK4953_INIT</strong>;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title67" id="drv-ak4953-int-ext-mic-type"><h2 class="title topictitle2" id="ariaid-title67"><em class="ph i">DRV_AK4953_INT_EXT_MIC Type</em></h2><div class="body"><p class="p">Identifies the Mic input source.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Mic Internal / External Input</p>
<p class="p">This enumeration identifies the Mic input source.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_INT_EXT_MIC@1 <strong class="ph b">DRV_AK4953_INT_EXT_MIC</strong>;</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title68" id="drv-ak4953-mic-type"><h3 class="title topictitle3" id="ariaid-title68">DRV_AK4953_MIC Type</h3><div class="body"><p class="p">This is type DRV_AK4953_MIC.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_MIC@1 <strong class="ph b">DRV_AK4953_MIC</strong>;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title69" id="drv-ak4953-mono-stereo-mic-type"><h2 class="title topictitle2" id="ariaid-title69"><em class="ph i">DRV_AK4953_MONO_STEREO_MIC Type</em></h2><div class="body"><p class="p">Identifies the Mic input as Mono / Stereo.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4953 Mic Mono / Stereo Input</p>
<p class="p">This enumeration identifies the Mic input as Mono / Stereo.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4953_MONO_STEREO_MIC@1 <strong class="ph b">DRV_AK4953_MONO_STEREO_MIC</strong>;</p>
<p class="p"><strong class="ph b"><em class="ph i">Files</em></strong></p>
<p class="p"><strong class="ph b">AK4954 CODEC Driver Library Help</strong></p>
<p class="p">This topic describes the AK4954 Codec Driver Library.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title70" id="introduction-1"><h2 class="title topictitle2" id="ariaid-title70"><em class="ph i">Introduction</em></h2><div class="body"><p class="p">This topic describes the basic architecture of the AK4954 Codec Driver Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title71" id="interface-header-file-drv-ak4954h"><h3 class="title topictitle3" id="ariaid-title71">Interface Header File: drv_AK4954.h</h3><div class="body"><p class="p">The interface to the AK4954 Codec Driver library is defined in the audio/driver/codec/AK4954/drv_AK4954.h header file.</p>
<p class="p">Any C language source (.c) file that uses the AK4954 Codec Driver library should include this header.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The AK4954 Codec Driver library source files are provided in the audio/driver/codec/AK4954/src directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features and to <strong class="ph b">Building the Library</strong> for instructions on how to build the library.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
<p class="p"><strong class="ph b"><em class="ph i">Using the Library</em></strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title72" id="abstration-model"><h2 class="title topictitle2" id="ariaid-title72">Abstration Model</h2><div class="body"><p class="p">This library provides a low-level abstraction of the AK4954 Codec Driver Library on the Microchip family microcontrollers with a convenient C language interface. This topic describes how that abstraction is modeled in software and introduces the library's interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The abstraction model shown in the following diagram depicts how the AK4954 Codec Driver is positioned in the MPLAB Harmony framework. The AK4954 Codec Driver uses the I2C and I2S drivers for control and audio data transfers to the AK4954 module. <strong class="ph b">AK4954 Driver Abstraction Model</strong>
<img class="image" src="GUID-A1402B4E-C779-4E72-B06A-3076BD3B42F4-low.png" /><br /></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title73" id="library-overview-1"><h2 class="title topictitle2" id="ariaid-title73">Library Overview</h2><div class="body"><p class="p">Refer to the Driver Library Overview section for information on how the driver operates in a system.</p>
<p class="p">The AK4954 Codec Driver Library provides an API interface to transfer control commands and digital audio data to the serially interfaced AK4954 Codec module. The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the AK4954 Codec Driver Library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4658"><span><strong class="ph b">Library Interface Section</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4661"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>System Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>Provides system module interfaces, device initialization, deinitialization, reinitialization, tasks and status functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>Client Setup Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>Provides open and close functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>Data Transfer Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>Provides data transfer functions, such as Buffer Read and Write.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>Settings Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>Provides driver specific functions for settings, such as volume control and sampling rate.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>Other Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>Miscellaneous functions, such as getting the driver’s version number and syncing to the LRCLK signal.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4658 "><span>Data Types and Constants</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4661 "><span>These data types and constants are required while interacting and setting up the AK4954 Codec Driver Library.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> All functions and constants in this section are named with the format DRV_ AK4954_xxx, where 'xxx' is a function name or constant. These names are redefined in the appropriate configuration’s configuration.h file to the format DRV_CODEC_xxx using #defines so that code in the application that references the library can be written as generically as possible (e.g., by writing DRV_CODEC_Open instead of DRV_ AK4954_Open etc.). This allows the codec type to be changed in the MHC without having to modify the application’s source code.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title74" id="how-the-library-works-1"><h2 class="title topictitle2" id="ariaid-title74">How the Library Works</h2><div class="body"><p class="p">How the Library Works</p>
<p class="p">The library provides interfaces to support:</p>
<ul class="ul"><li class="li"><p class="p">System Functionality</p>
</li>
<li class="li"><p class="p">Client Functionality</p>
</li>
</ul>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title75" id="setup-initialization-1"><h3 class="title topictitle3" id="ariaid-title75">Setup (Initialization)</h3><div class="body"><p class="p">This topic describes system initialization, implementations, and includes a system access code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title76" id="system-initialization"><h2 class="title topictitle2" id="ariaid-title76">System Initialization</h2><div class="body"><p class="p">The system performs the initialization of the device driver with settings that affect only the instance of the device that is being initialized. During system initialization in the system_init.c file, each instance of the AK4954 module would be initialized with the following configuration settings (either passed dynamically at run time using DRV_AK4954_INIT or by using Initialization Overrides) that are supported by the specific AK4954 device hardware:</p>
<ul class="ul"><li class="li"><p class="p">Device requested power state: one of the System Module Power States. For specific details please refer to Data Types and Constants in the Library Interface section.</p>
</li>
<li class="li"><p class="p">I2C driver module index. The module index should be same as the one used in initializing the I2C Driver</p>
</li>
<li class="li"><p class="p">I2S driver module index. The module index should be same as the one used in initializing the I2S Driver</p>
</li>
<li class="li"><p class="p">Sampling rate</p>
</li>
<li class="li"><p class="p">Volume</p>
</li>
<li class="li"><p class="p">Audio data format. The audio data format should match with the audio data format settings done in I2S driver initialization</p>
</li>
<li class="li"><p class="p">Determines whether or not the microphone input is enabled</p>
</li>
</ul>
<p class="p">The DRV_AK4954_Initialize API returns an object handle of the type SYS_MODULE_OBJ. The object handle returned by the</p>
<p class="p">Initialize interface would be used by the other system interfaces such as DRV_ AK4954_Deinitialize, DRV_ AK4954_Status and</p>
<p class="p">DRV_I2S_Tasks</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title77" id="client-access-1"><h3 class="title topictitle3" id="ariaid-title77">Client Access</h3><div class="body"><p class="p">This topic describes driver initialization and provides a code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">For the application to start using an instance of the module, it must call the DRV_AK4954_Open function. The</p>
<p class="p">DRV_AK4954_Open function provides a driver handle to the AK4954 Codec Driver instance for operations. If the driver is deinitialized using the function DRV_AK4954_Deinitialize, the application must call the DRV_AK4954_Open function again to set up the instance of the driver.</p>
<p class="p">For the various options available for IO_INTENT, please refer to Data Types and Constants in the Library Interface section.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is necessary to check the status of driver initialization before opening a driver instance. The status of the AK4954 Codec Driver can be known by calling DRV_ AK4954_Status.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_HANDLE handle; SYS_STATUS ak4954Status;</p>
<p class="p">ak4954Status Status = DRV_AK4954_Status(sysObjects.ak4954Status DevObject); if (SYS_STATUS_READY == ak4954Status) { // The driver can now be opened. appData.ak4954Client.handle = DRV_AK4954_Open</p>
<p class="p">( DRV_AK4954_INDEX_0, DRV_IO_INTENT_WRITE | DRV_IO_INTENT_EXCLUSIVE); if(appData.ak4954Client.handle != DRV_HANDLE_INVALID) {</p>
<p class="p">appData.state = APP_STATE_AK4954_SET_BUFFER_HANDLER; } else { SYS_DEBUG(0, "Find out what's wrong \r\n");</p>
<p class="p">} } else { /* AK4954 Driver Is not ready */</p>
<p class="p">}</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title78" id="client-operations-1"><h3 class="title topictitle3" id="ariaid-title78">Client Operations</h3><div class="body"><p class="p">This topic provides information on client operations.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Client operations provide the API interface for control command and audio data transfer to the AK4954 Codec.</p>
<p class="p">The following AK4954 Codec specific control command functions are provided:</p>
<ul class="ul"><li class="li"><p class="p">DRV_AK4954_SamplingRateSet</p>
</li>
<li class="li"><p class="p">DRV_AK4954_SamplingRateGet</p>
</li>
<li class="li"><p class="p">DRV_AK4954_VolumeSet</p>
</li>
<li class="li"><p class="p">DRV_AK4954_VolumeGet</p>
</li>
<li class="li"><p class="p">DRV_AK4954_MuteOn</p>
</li>
<li class="li"><p class="p">DRV_AK4954_MuteOff</p>
</li>
</ul>
<p class="p">These functions schedule a non-blocking control command transfer operation. These functions submit the control command request to the AK4954 Codec. These functions submit the control command request to I2C Driver transmit queue, the request is processed immediately if it is the first request, or processed when the previous request is complete.</p>
<p class="p">DRV_AK4954_BufferAddWrite, DRV_AK4954_BufferAddRead, and DRV_AK4954_BufferAddWriteRead are buffered data operation functions. These functions schedule non-blocking audio data transfer operations. These functions add the request to I2S Driver transmit or receive buffer queue depends on the request type, and are executed immediately if it is the first buffer, or executed later when the previous buffer is complete. The driver notifies the client with</p>
<p class="p">DRV_AK4954_BUFFER_EVENT_COMPLETE, DRV_AK4954_BUFFER_EVENT_ERROR, or DRV_AK4954_BUFFER_EVENT_ABORT events.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is not necessary to close and reopen the client between multiple transfers.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title79" id="configuring-the-library-1"><h3 class="title topictitle3" id="ariaid-title79">Configuring the Library</h3><div class="body"><p class="p">The configuration of the I2S Driver Library is based on the file configurations.h, as generated by the MHC.</p>
<p class="p">This header file contains the configuration selection for the I2S Driver Library. Based on the selections made, the I2S Driver Library may support the selected features. These configuration settings will apply to all instances of the I2S Driver Library.</p>
<p class="p">This header can be placed anywhere; however, the path of this header needs to be present in the include search path for a successful build. Refer to the Applications Help section for more details.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title80" id="system-configuration-1"><h3 class="title topictitle3" id="ariaid-title80">System Configuration</h3><div class="body"><p class="p"><strong class="ph b">Macros</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4864"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4866"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e4869"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_AUDIO_DATA_FORMAT_MACRO</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the audio data format for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_AUDIO_SAMPLING_RATE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the initial baud rate for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_CLIENTS_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Sets up the maximum number of clients that can be connected to any hardware instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_ENABLE_MIC_BIAS</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies whether to enable the microphone bias.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_I2C_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the instance number of the I2C interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_I2S_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the instance number of the I2S interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_INSTANCES_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Sets up the maximum number of hardware instances that can be supported</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_MASTER_MODE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies if codec is in Master or Slave mode.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_MIC_GAIN</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the gain of the microphone (external or line input only)</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_VOLUME</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies the initial volume level.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4864 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4866 "><span>DRV_AK4954_WHICH_MIC_INPUT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e4869 "><span>Specifies whether to enable the microphone input.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title81" id="drv-ak4954-audio-data-format-macro-macro"><h2 class="title topictitle2" id="ariaid-title81"><em class="ph i">DRV_AK4954_AUDIO_DATA_FORMAT_MACRO Macro</em></h2><div class="body"><p class="p">Specifies the audio data format for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Audio Data Format</p>
<p class="p">Sets up the length of each sample plus the format (I2S or left-justified) for the audio.</p>
<p class="p">Valid choices are: "DRV_AK4954_AUDIO_DATA_FORMAT_24BIT_MSB_SDTO_24BIT_LSB_SDTI"</p>
<p class="p">"DRV_AK4954_AUDIO_DATA_FORMAT_24BIT_MSB_SDTO_16BIT_LSB_SDTI"</p>
<p class="p">"DRV_AK4954_AUDIO_DATA_FORMAT_24BIT_MSB_SDTO_24BIT_MSB_SDTI" "DRV_AK4954_AUDIO_DATA_FORMAT_I2S_16BIT_24BIT"</p>
<p class="p">"DRV_AK4954_AUDIO_DATA_FORMAT_32BIT_MSB_SDTO_32BIT_MSB_SDTI"</p>
<p class="p">"DRV_AK4954_AUDIO_DATA_FORMAT_I2S_32BIT" where SDTO is input line (ADC) and STDI is output line (DAC)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If 24-bit audio is needed, it should be sent, left-justified, in a 32-bit format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_AUDIO_DATA_FORMAT_MACRO</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title82" id="drv-ak4954-audio-sampling-rate-macro"><h2 class="title topictitle2" id="ariaid-title82"><em class="ph i">DRV_AK4954_AUDIO_SAMPLING_RATE Macro</em></h2><div class="body"><p class="p">Specifies the initial baud rate for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Baud Rate</p>
<p class="p">Sets the initial baud rate (sampling rate) for the codec. Typical values are 8000, 16000, 44100, 48000, 88200 and 96000.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_AUDIO_SAMPLING_RATE</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title83" id="drv-ak4954-clients-number-macro"><h2 class="title topictitle2" id="ariaid-title83"><em class="ph i">DRV_AK4954_CLIENTS_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of clients that can be connected to any hardware instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Client Count Configuration</p>
<p class="p">Sets up the maximum number of clients that can be connected to any hardware instance. Typically only one client could be connected to one hardware instance. This value represents the total number of clients to be supported across all hardware instances.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_CLIENTS_NUMBER</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title84" id="drv-ak4954-enable-mic-bias-macro"><h2 class="title topictitle2" id="ariaid-title84"><em class="ph i">DRV_AK4954_ENABLE_MIC_BIAS Macro</em></h2><div class="body"><p class="p">Specifies whether to enable the microphone bias.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Microphone Enable</p>
<p class="p">Indicates whether the bias voltage needed for electret microphones should be enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_ENABLE_MIC_BIAS</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title85" id="drv-ak4954-i2c-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title85"><em class="ph i">DRV_AK4954_I2C_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2C interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 I2C instance number</p>
<p class="p">Specifies the instance number of the I2C interface being used by the MCU to send commands and receive status to and from the AK4954. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_I2C_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title86" id="drv-ak4954-i2s-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title86"><em class="ph i">DRV_AK4954_I2S_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2S interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 I2S instance number</p>
<p class="p">Specifies the instance number of the I2S interface being used by the MCU to send and receive audio data to and from the AK4954. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_I2S_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title87" id="drv-ak4954-instances-number-macro"><h2 class="title topictitle2" id="ariaid-title87"><em class="ph i">DRV_AK4954_INSTANCES_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of hardware instances that can be supported</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 driver objects configuration</p>
<p class="p">Sets up the maximum number of hardware instances that can be supported. It is recommended that this number be set exactly equal to the number of AK4954 Codec modules that are needed by an application, namely one.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INSTANCES_NUMBER</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title88" id="drv-ak4954-master-mode-macro"><h3 class="title topictitle3" id="ariaid-title88">DRV_AK4954_MASTER_MODE Macro</h3><div class="body"><p class="p">Specifies if codec is in Master or Slave mode.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Codec Master/Slave Mode</p>
<p class="p">Indicates whether the codec is to be operating in a Master mode (generating word and bit clock as outputs) or Slave mode receiving word and bit clock as inputs).</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_MASTER_MODE</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title89" id="drv-ak4954-mic-gain-macro"><h3 class="title topictitle3" id="ariaid-title89">DRV_AK4954_MIC_GAIN Macro</h3><div class="body"><p class="p">Specifies the gain of the microphone (external or line input only)</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Microphone Gain</p>
<p class="p">Specifies the gain of the microphone (external or line input only), on a scale of 0-31</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_MIC_GAIN</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title90" id="drv-ak4954-volume-macro"><h3 class="title topictitle3" id="ariaid-title90">DRV_AK4954_VOLUME Macro</h3><div class="body"><p class="p">Specifies the initial volume level.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Volume</p>
<p class="p">Sets the initial volume level, in the range 0-255.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The value is mapped to an internal AK4954 volume level in the range 0-192 using a logarithmic table so the input scale appears linear (128 is half volume).</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_VOLUME</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title91" id="drv-ak4954-which-mic-input-macro"><h2 class="title topictitle2" id="ariaid-title91"><em class="ph i">DRV_AK4954_WHICH_MIC_INPUT Macro</em></h2><div class="body"><p class="p">Specifies whether to enable the microphone input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Which Microphone</p>
<p class="p">Indicates which microphone (or line input) is chosen</p>
<p class="p">Valid choices are: "MIC1" (Internal Mic on board) "MIC2" (External Mic Input) "MIC3" (Line Input)</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_WHICH_MIC_INPUT</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title92" id="configuring-mhc-1"><h3 class="title topictitle3" id="ariaid-title92">Configuring MHC</h3><div class="body"><p class="p">Provides examples on how to configure the MPLAB Harmony Configurator (MHC) for a specific driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When building a new application, start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <em class="ph i">File &gt; New Project</em>. Chose the Configuration name the based on the BSP, and select the appropriate processor (such as ATSAME70Q21B).</p>
<p class="p">In the MHC, under Available Components select the appropriate BSP, such as SAM E70 Xplained Ultra. Under <em class="ph i">Audio&gt;Templates</em>, double-click on a codec template such as AK4954. Answer Yes to all questions.</p>
<p class="p">You should end up with a project graph that looks like this, after rearranging the boxes:
<img class="image" src="GUID-6E925773-504F-4F0F-B05D-449BCACE0494-low.png" /><br /></p>
<p class="p">Click on the AK4954 Driver component (not AK4954 Codec) and the following menu will be displayed in the Configurations Options:
<img class="image" src="GUID-4AF50211-0514-4851-A9DE-E0E042250333-low.png" /><br /></p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">I2C Driver Used</strong> will display the driver instance used for the I2C interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">I2S Driver Used</strong> will display the driver instance used for the I2S interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Usage Mode</strong> indicates whether the AK4954 is a Master (supplies I2S clocks) or a Slave (MCU supplies I2S clocks).</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Number of AK4954 Clients</strong> indicates the maximum number of clients that can be connected to the AK4954 Driver.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Sampling Rate</strong> indicates the number of samples per second per channel, 8000 to 96,000.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Volume</strong> indicates the volume in a linear scale from 0-255.</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title93" id="-audio-data-format-is-either-1"><h4 class="title topictitle4" id="ariaid-title93">• Audio Data Format is either</h4><div class="body"><ul class="ul"><li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 16-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Left-justified(DAC)</p>
</li>
<li class="li"><p class="p">24/16-bit I2S</p>
</li>
<li class="li"><p class="p">32-bit Left Justified (ADC), 32-bit Left-justified(DAC)</p>
</li>
<li class="li"><p class="p">32-bit I2S</p>
</li>
</ul>
<p class="p">It must match the audio protocol and data length set up in either the SSC or I2S PLIB.</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">Microphone/Line Input</strong> selects which microphone or line input is selected, either:</p>
</li>
<li class="li"><p class="p">Internal Mic (mounted on the AK4954 daughterboard)</p>
</li>
<li class="li"><p class="p">External Mic Input</p>
</li>
<li class="li"><p class="p">Line Input</p>
</li>
</ul>
<p class="p">If External Mic input or Line Input is selected, then the following option is provided:</p>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title94" id="-ext-mic-gain-in-db-range-0min-to-31max-1"><h4 class="title topictitle4" id="ariaid-title94">• Ext Mic Gain in dB range 0(min) to 31(max)</h4><div class="body"><p class="p">If External Mic input is selected, then the following option is provided:</p>
<p class="p">• <strong class="ph b">Enable Microphone Bias</strong> should be checked if using an electret microphone.</p>
<p class="p">You can also bring in the AK4954 Driver by itself, by double clicking AK4954 under Audio_-&gt;Driver-&gt;Codec_ in the Available Components list. You will then need to add any additional needed components manually and connect them together.</p>
<p class="p">Note that the AK4954 requires the TCx Peripheral Library and TIME System Service in order to perform some of its internal timing sequences.</p>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title95" id="building-the-library"><h3 class="title topictitle3" id="ariaid-title95">Building the Library</h3><div class="body"><p class="p">This section lists the files that are available in the AK4954 Codec Driver Library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section lists the files that are available in the src folder of the AK4954 Codec Driver. It lists which files need to be included in the build based on either a hardware feature present on the board or configuration option selected by the system.</p>
<p class="p">The following three tables list and describe the header (.h) and source (.c) files that implement this library. The parent folder for these files is audio/driver/codec/AK4954.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title96" id="interface-files"><h3 class="title topictitle3" id="ariaid-title96">Interface File(s)</h3><div class="body"><p class="p">This table lists and describes the header files that must be included (i.e., using #include) by any code that uses this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5365"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5368"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5365 "><span>drv_ak4954.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5368 "><span>Header file that exports the driver API.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title97" id="required-files-1"><h3 class="title topictitle3" id="ariaid-title97">Required File(s)</h3><div class="body"><p class="p"><img class="image" src="GUID-B924D07A-0D74-453B-BCDE-8190A195C55D-low.png" /><br /> <strong class="ph b"><em class="ph i">All of the required files listed in the following table are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use.</em></strong></p>
<p class="p">This table lists and describes the source and header files that must <em class="ph i">always</em> be included in the MPLAB X IDE project to build this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5398"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5401"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5398 "><span>/src/drv_ak4954.c</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5401 "><span>This file contains implementation of the AK4954 Codec Driver.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title98" id="optional-files-1"><h3 class="title topictitle3" id="ariaid-title98">Optional File(s)</h3><div class="body"><p class="p">This table lists and describes the source and header files that may optionally be included if required for the desired implementation.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5422"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5425"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5422 "><span>N/A</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5425 "><span>No optional files are available for this library.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title99" id="module-dependencies-1"><h3 class="title topictitle3" id="ariaid-title99">Module Dependencies</h3><div class="body"><p class="p">The AK4954 Codec Driver Library depends on the following modules:</p>
<ul class="ul"><li class="li"><p class="p">I2S Driver Library</p>
</li>
<li class="li"><p class="p">I2C Driver Library</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title100" id="library-interface-1"><h4 class="title topictitle4" id="ariaid-title100"><em class="ph i">Library Interface</em></h4><div class="body"><p class="p"><strong class="ph b">Client Setup Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5462"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5464"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5467"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5464 "><span>DRV_AK4954_Open</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5467 "><span>Opens the specified AK4954 driver instance and returns a handle to it.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5464 "><span>DRV_AK4954_Close</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5467 "><span>Closes an opened-instance of the AK4954 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5464 "><span>DRV_AK4954_BufferEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5467 "><span>This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5464 "><span>DRV_AK4954_CommandEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5467 "><span>This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Transfer Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5509"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5511"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5514"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5509 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5511 "><span>DRV_AK4954_BufferAddRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5514 "><span>Schedule a non-blocking driver read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5509 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5511 "><span>DRV_AK4954_BufferAddWrite</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5514 "><span>Schedule a non-blocking driver write operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5509 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5511 "><span>DRV_AK4954_BufferAddWriteRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5514 "><span>Schedule a non-blocking driver write-read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5509 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5511 "><span>DRV_AK4954_ReadQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5514 "><span>Removes all buffer requests from the read queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5509 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5511 "><span>DRV_AK4954_WriteQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5514 "><span>Removes all buffer requests from the write queue.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Types and Constants</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5563"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5565"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5568"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_AUDIO_DATA_FORMAT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies the Serial Audio data interface format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_BUFFER_EVENT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies the possible events that can result from a buffer add request.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_BUFFER_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Pointer to a AK4954 Driver Buffer Event handler function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_BUFFER_HANDLE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Handle identifying a write buffer passed to the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_CHANNEL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies Left/Right Audio channel</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_COMMAND_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Pointer to a AK4954 Driver Command Event Handler Function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_DIGITAL_BLOCK_CONTROL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies Bass-Boost Control function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INIT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Defines the data required to initialize or reinitialize the AK4954 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INT_EXT_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies the Mic input source.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is type DRV_AK4954_MIC.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_MONO_STEREO_MIC</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Identifies the Mic input as Mono / Stereo.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>SAMPLE_LENGTH</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>in bits</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_AUDIO_DATA_FORMAT_I2S</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>for compatability with old code</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_BUFFER_HANDLE_INVALID</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Definition of an invalid buffer handle.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_COUNT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>Number of valid AK4954 driver indices</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_0</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>AK4954 driver index definitions</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_1</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is macro DRV_AK4954_INDEX_1.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_2</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is macro DRV_AK4954_INDEX_2.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_3</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is macro DRV_AK4954_INDEX_3.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_4</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is macro DRV_AK4954_INDEX_4.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5563 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5565 "><span>DRV_AK4954_INDEX_5</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5568 "><span>This is macro DRV_AK4954_INDEX_5.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Other Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5730"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5732"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5735"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5730 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5732 "><span>DRV_AK4954_LRCLK_Sync</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5735 "><span>Synchronize to the start of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5730 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5732 "><span>DRV_AK4954_GetI2SDriver</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5735 "><span>Get the handle to the I2S driver for this codec instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5730 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5732 "><span>DRV_AK4954_VersionStrGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5735 "><span>This function returns the version of AK4954 driver in string format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5730 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5732 "><span>DRV_AK4954_VersionGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5735 "><span>This function returns the version of AK4954 driver.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Settings Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5777"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5779"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5782"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MicGainGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function gets the microphone gain for the AK4954 Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MicGainSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets the microphone gain for the AK4954 CODEC.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MicMuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>Umutes th AK4954's microphone input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MicMuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>Mutes the AK4954's microphone input</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets up the codec for the internal or the AK4954 Mic1 or Mic2 input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MonoStereoMicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets up the codec for the Mono or Stereo microphone mode.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function disables AK4954 output for soft mute.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_MuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function allows AK4954 output for soft mute on.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_IntExtMicSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets up the codec for the X32 DB internal or the external microphone use.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_SamplingRateGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function gets the sampling rate set on the DAC AK4954.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_SamplingRateSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets the sampling rate of the media stream.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_VolumeGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function gets the volume for AK4954 Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5777 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5779 "><span>DRV_AK4954_VolumeSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5782 "><span>This function sets the volume for AK4954 Codec.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">System Interaction Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5889"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5891"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5894"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Initializes hardware and data for the instance of the AK4954 Codec module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_EnableInitialization</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Enable delayed initialization of the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_IsInitializationDelayed</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Checks if delayed initialization of the driver has been requested.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_Deinitialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Deinitializes the specified instance of the AK4954 driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_Status</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Gets the current status of the AK4954 driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5889 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5891 "><span>DRV_AK4954_Tasks</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5894 "><span>Maintains the driver's control and data interface state machine.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title101" id="system-interaction-functions-1"><h4 class="title topictitle4" id="ariaid-title101">System Interaction Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title102" id="drv-ak4954-initialize-function"><h5 class="title topictitle5" id="ariaid-title102">DRV_AK4954_Initialize Function</h5><div class="body"><p class="p">SYS_MODULE_OBJ DRV_AK4954_Initialize</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const SYS_MODULE_INIT *const init</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes hardware and data for the instance of the AK4954 Codec module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine initializes the AK4954 driver instance for the specified driver index, making it ready for clients to open and use it. The initialization data is specified by the init parameter. The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Initialize must be called before calling this function to initialize the data interface of this Codec driver. DRV_I2C_Initialize must be called if SPI driver is used for handling the control interface of this Codec driver.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5984"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e5987"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5984 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5987 "><span>Identifier for the driver instance to be initialized</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5984 "><span>init</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e5987 "><span>Pointer to the data structure containing any data necessary to initialize the hardware. This pointer may be null if no data is required and default initialization is to be used.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, returns a valid handle to a driver instance object. Otherwise, it returns SYS_MODULE_OBJ_INVALID.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine must be called before any other AK4954 routine is called.</p>
<p class="p">This routine should only be called once during system initialization unless DRV_AK4954_Deinitialize is called to deinitialize the driver instance. This routine will NEVER block for hardware access.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_AK4954_INIT init;</p>
<p class="p">SYS_MODULE_OBJ objectHandle; init-&gt;inUse = <strong class="ph b">true</strong>; init-&gt;status = SYS_STATUS_BUSY; init-&gt;numClients = 0; init-&gt;i2sDriverModuleIndex = ak4954Init-&gt;i2sDriverModuleIndex; init-&gt;i2cDriverModuleIndex = ak4954Init-&gt;i2cDriverModuleIndex; init-&gt;samplingRate = DRV_AK4954_AUDIO_SAMPLING_RATE; init-&gt;audioDataFormat = DRV_AK4954_AUDIO_DATA_FORMAT_MACRO; <strong class="ph b">for</strong>(index=0; index &lt; DRV_AK4954_NUMBER_OF_CHANNELS; index++) {</p>
<p class="p">init-&gt;volume<span class="xref"></span> = ak4954Init-&gt;volume; } init-&gt;isInInterruptContext = <strong class="ph b">false</strong>; init-&gt;commandCompleteCallback = (DRV_AK4954_COMMAND_EVENT_HANDLER)0; init-&gt;commandContextData = 0; init-&gt;mclk_multiplier = DRV_AK4954_MCLK_SAMPLE_FREQ_MULTPLIER; objectHandle = DRV_AK4954_Initialize(DRV_AK4954_0, (SYS_MODULE_INIT*)init); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == objectHandle) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_MODULE_OBJ <strong class="ph b">DRV_AK4954_Initialize</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">drvIndex</strong>, <strong class="ph b">const</strong> SYS_MODULE_INIT * <strong class="ph b">const</strong> <strong class="ph b">init</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title103" id="drv-ak4954-enableinitialization-function"><h5 class="title topictitle5" id="ariaid-title103">DRV_AK4954_EnableInitialization Function</h5><div class="body"><p class="p">void DRV_AK4954_EnableInitialization(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Enable delayed initialization of the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">If the AK4954 codec is sharing a RESET line with another peripheral, such as a Bluetooth module with its own driver, then the codec driver initialization has to be delayed until after the Bluetooth module has toggled its RESET pin. Once this has been accomplished, this function should be called to kick-start the codec driver initialization.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6097"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6100"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6097 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6100 "><span>Object handle for the specified driver instance (returned from DRV_AK4954_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This is not needed for audio-only applications without a Bluetooth module.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_EnableInitialization</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title104" id="drv-ak4954-isinitializationdelayed-function"><h5 class="title topictitle5" id="ariaid-title104">DRV_AK4954_IsInitializationDelayed Function</h5><div class="body"><p class="p">bool DRV_AK4954_IsInitializationDelayed(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Checks if delayed initialization of the driver has been requested.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">If the AK4954 codec is sharing a RESET line with another peripheral, such as a Bluetooth module with its own driver, then the codec driver initialization has to be delayed until after the Bluetooth module has toggled its RESET pin. This function returns true if that option has been selected in MHC in the checkbox: "Delay driver initialization (due to shared RESET pin)"</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6163"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6166"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6163 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6166 "><span>Object handle for the specified driver instance (returned from DRV_AK4954_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the delayed initialization option has been enabled</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This is not needed for audio-only applications without a Bluetooth module.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4954_IsInitializationDelayed</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title105" id="drv-ak4954-deinitialize-function"><h5 class="title topictitle5" id="ariaid-title105">DRV_AK4954_Deinitialize Function</h5><div class="body"><p class="p">void DRV_AK4954_Deinitialize( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Deinitializes the specified instance of the AK4954 driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Deinitializes the specified instance of the AK4954 driver module, disabling its operation (and any hardware). Invalidates all the internal data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4954_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6229"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6232"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6229 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6232 "><span>Driver object handle, returned from the DRV_AK4954_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Once the Initialize operation has been called, the De-initialize operation must be called before the Initialize operation can be called again. This routine will NEVER block waiting for hardware.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4954_Initialize</em></p>
<p class="p">SYS_STATUS status;</p>
<p class="p">DRV_AK4954_Deinitialize(object);</p>
<p class="p">status = DRV_AK4954_Status(object); <strong class="ph b">if</strong> (SYS_MODULE_DEINITIALIZED != status) {</p>
<p class="p"><em class="ph i">// Check again later if you need to know</em> <em class="ph i">// when the driver is deinitialized.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_Deinitialize</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title106" id="drv-ak4954-status-function"><h5 class="title topictitle5" id="ariaid-title106">DRV_AK4954_Status Function</h5><div class="body"><p class="p">SYS_STATUS DRV_AK4954_Status( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the current status of the AK4954 driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine provides the current status of the AK4954 driver module.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4954_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6319"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6322"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6319 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6322 "><span>Driver object handle, returned from the DRV_AK4954_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized</p>
<p class="p">SYS_STATUS_READY - Indicates that any previous module operation for the specified module has completed</p>
<p class="p">SYS_STATUS_BUSY - Indicates that a previous module operation for the specified module has not yet completed</p>
<p class="p">SYS_STATUS_ERROR - Indicates that the specified module is in an error state</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">A driver can opened only when its status is SYS_STATUS_READY.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4954_Initialize</em></p>
<p class="p">SYS_STATUS AK4954Status;</p>
<p class="p">AK4954Status = DRV_AK4954_Status(object); <strong class="ph b">if</strong> (SYS_STATUS_READY == AK4954Status) {</p>
<p class="p"><em class="ph i">// This means the driver can be opened using the</em> <em class="ph i">// DRV_AK4954_Open() function.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_STATUS <strong class="ph b">DRV_AK4954_Status</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title107" id="drv-ak4954-tasks-function"><h5 class="title topictitle5" id="ariaid-title107">DRV_AK4954_Tasks Function</h5><div class="body"><p class="p">void DRV_AK4954_Tasks(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Maintains the driver's control and data interface state machine.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine is used to maintain the driver's internal control and data interface state machine and implement its control and data interface implementations. This function should be called from the SYS_Tasks() function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6412"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6415"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6412 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6415 "><span>Object handle for the specified driver instance (returned from DRV_AK4954_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine is normally not called directly by an application. It is called by the system's Tasks routine (SYS_Tasks).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_AK4954_Initialize</em> <strong class="ph b">while</strong> (<strong class="ph b">true</strong>) {</p>
<p class="p">DRV_AK4954_Tasks (object);</p>
<p class="p"><em class="ph i">// Do other tasks</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_Tasks</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title108" id="client-setup-functions-1"><h4 class="title topictitle4" id="ariaid-title108">Client Setup Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title109" id="drv-ak4954-open-function"><h5 class="title topictitle5" id="ariaid-title109">DRV_AK4954_Open Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_AK4954_Open</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT ioIntent</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Opens the specified AK4954 driver instance and returns a handle to it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine opens the specified AK4954 driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver. The ioIntent parameter defines how the client interacts with this driver instance.</p>
<p class="p">The DRV_IO_INTENT_BLOCKING and DRV_IO_INTENT_NONBLOCKING ioIntent options are not relevant to this driver. All the data transfer functions of this driver are non blocking.</p>
<p class="p">AK4954 can be opened with DRV_IO_INTENT_WRITE, or DRV_IO_INTENT_READ or DRV_IO_INTENT_WRITEREAD io_intent option. This decides whether the driver is used for headphone output, or microphone input or both modes simultaneously.</p>
<p class="p">Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client. The driver cannot be opened by any other client.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_AK4954_Initialize must have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6516"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6519"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6516 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6519 "><span>Identifier for the object instance to be opened</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6516 "><span>ioIntent</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6519 "><span>Zero or more of the values from the enumeration DRV_IO_INTENT "ORed" together to indicate the intended use of the driver. See function description for details.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, the routine returns a valid open-instance handle (a number identifying both the caller and the module instance).</p>
<p class="p">If an error occurs, the return value is DRV_HANDLE_INVALID. Error can occur</p>
<ul class="ul"><li class="li"><p class="p">if the number of client objects allocated via DRV_AK4954_CLIENTS_NUMBER is insufficient.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver but driver has been opened exclusively by another client.</p>
</li>
<li class="li"><p class="p">if the driver hardware instance being opened is not initialized or is invalid.</p>
</li>
<li class="li"><p class="p">if the ioIntent options passed are not relevant to this driver.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The handle returned is valid until the DRV_AK4954_Close routine is called. This routine will NEVER block waiting for hardware.If the requested intent flags are not supported, the routine will return DRV_HANDLE_INVALID. This function is thread safe in a RTOS application. It should not be called in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; handle = DRV_AK4954_Open(DRV_AK4954_INDEX_0, DRV_IO_INTENT_WRITEREAD | DRV_IO_INTENT_EXCLUSIVE); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em></p>
<p class="p"><em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_AK4954_Open</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">iDriver</strong>, <strong class="ph b">const</strong> DRV_IO_INTENT <strong class="ph b">ioIntent</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title110" id="drv-ak4954-close-function"><h5 class="title topictitle5" id="ariaid-title110">DRV_AK4954_Close Function</h5><div class="body"><p class="p">void DRV_AK4954_Close( DRV_Handle handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Closes an opened-instance of the AK4954 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine closes an opened-instance of the AK4954 driver, invalidating the handle. Any buffers in the driver queue that were submitted by this client will be removed. After calling this routine, the handle passed in "handle" must not be used with any of the remaining driver routines. A new handle must be obtained by calling DRV_AK4954_Open before the caller may use the driver again</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6630"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6633"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6630 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6633 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Usually there is no need for the driver client to verify that the Close operation has completed. The driver will abort any ongoing operations when this routine is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; <em class="ph i">// Returned from DRV_AK4954_Open</em></p>
<p class="p">DRV_AK4954_Close(handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_Close</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title111" id="drv-ak4954-buffereventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title111">DRV_AK4954_BufferEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_AK4954_BufferEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_AK4954_BUFFER_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished. When a client calls DRV_AK4954_BufferAddRead function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "buffer add" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6721"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6724"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6721 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6724 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6721 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6724 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6721 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6724 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the queued buffer transfer has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4954_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4954_BufferEventHandlerSet(myAK4954Handle,</p>
<p class="p">APP_AK4954BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4954_BufferAddRead(myAK4954handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_AK4954_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4954BufferEventHandler(DRV_AK4954_BUFFER_EVENT event, DRV_AK4954_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_BufferEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_AK4954_BUFFER_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title112" id="drv-ak4954-commandeventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title112">DRV_AK4954_CommandEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_AK4954_CommandEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_AK4954_COMMAND_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p">When a client calls DRV_AK4954_BufferAddWrite function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "AK4954 CODEC Specific Client Routines" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6898"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e6901"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6898 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6901 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6898 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6901 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6898 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e6901 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the command has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4954_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4954_CommandEventHandlerSet(myAK4954Handle,</p>
<p class="p">APP_AK4954CommandEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4954_DeEmphasisFilterSet(myAK4954Handle, DRV_AK4954_DEEMPHASIS_FILTER_44_1KHZ)</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4954CommandEventHandler(uintptr_t contextHandle) { <em class="ph i">// contextHandle points to myAppObj.</em></p>
<p class="p"><strong class="ph b">switch</strong>(event) { <em class="ph i">// Last Submitted command is completed.</em> <em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_CommandEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_AK4954_COMMAND_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title113" id="data-transfer-functions-1"><h4 class="title topictitle4" id="ariaid-title113">Data Transfer Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title114" id="drv-ak4954-bufferaddread-function"><h5 class="title topictitle5" id="ariaid-title114">DRV_AK4954_BufferAddRead Function</h5><div class="body"><p class="p">void DRV_AK4954_BufferAddRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4954_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking read operation. The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully. The function adds the request to the hardware instance receive queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4954_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4954_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4954_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 device instance and the DRV_AK4954_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle. DRV_IO_INTENT_READ must have been specified in the DRV_AK4954_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7064"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7067"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7064 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7067 "><span>Handle of the AK4954 instance as return by the DRV_AK4954_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7064 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7067 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7064 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7067 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7064 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7067 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4954_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4954 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4954 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_BufferAddRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title115" id="drv-ak4954-bufferaddwrite-function"><h5 class="title topictitle5" id="ariaid-title115">DRV_AK4954_BufferAddWrite Function</h5><div class="body"><p class="p">void DRV_AK4954_BufferAddWrite</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4954_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write operation. The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully. The function adds the request to the hardware instance transmit queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4954_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4954_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4954_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 device instance and the DRV_AK4954_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_WRITE must have been specified in the DRV_AK4954_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7191"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7194"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7191 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7194 "><span>Handle of the AK4954 instance as return by the DRV_AK4954_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7191 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7194 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7191 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7194 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7191 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7194 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4954_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4954 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4954 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_AK4954_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4954_BufferEventHandlerSet(myAK4954Handle,</p>
<p class="p">APP_AK4954BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4954_BufferAddWrite(myAK4954handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_AK4954_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4954BufferEventHandler(DRV_AK4954_BUFFER_EVENT event, DRV_AK4954_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_BufferAddWrite</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title116" id="drv-ak4954-bufferaddwriteread-function"><h5 class="title topictitle5" id="ariaid-title116">DRV_AK4954_BufferAddWriteRead Function</h5><div class="body"><p class="p">void DRV_AK4954_BufferAddWriteRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_AK4954_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *transmitBuffer, void *receiveBuffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write-read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write-read operation. The function returns with a valid buffer handle in the bufferHandle argument if the write-read request was scheduled successfully. The function adds the request to the hardware instance queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_AK4954_BUFFER_EVENT_COMPLETE:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only or write only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_AK4954_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_AK4954_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 device instance and the DRV_AK4954_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_READWRITE must have been specified in the DRV_AK4954_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7394"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7397"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7394 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7397 "><span>Handle of the AK4954 instance as returned by the DRV_AK4954_Open function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7394 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7397 "><span>Pointer to an argument that will contain the return buffer handle</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7394 "><span>transmitBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7397 "><span>The buffer where the transmit data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7394 "><span>receiveBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7397 "><span>The buffer where the received data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7394 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7397 "><span>Buffer size in bytes</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_AK4954_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the AK4954 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another AK4954 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p">This function is useful when there is valid read expected for every AK4954 write. The transmit and receive size must be same.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybufferTx<span class="xref"></span>; uint8_t mybufferRx<span class="xref"></span>; DRV_AK4954_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myak4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_AK4954_BufferEventHandlerSet(myak4954Handle,</p>
<p class="p">APP_AK4954BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_AK4954_BufferAddWriteRead(myak4954handle, &amp;bufferHandle,</p>
<p class="p">mybufferTx,mybufferRx,MY_BUFFER_SIZE);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_AK4954_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4954BufferEventHandler(DRV_AK4954_BUFFER_EVENT event, DRV_AK4954_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_BufferAddWriteRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">transmitBuffer</strong>, <strong class="ph b">void</strong> * <strong class="ph b">receiveBuffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title117" id="drv-ak4954-readqueuepurge-function"><h5 class="title topictitle5" id="ariaid-title117">DRV_AK4954_ReadQueuePurge Function</h5><div class="body"><p class="p">bool DRV_AK4954_ReadQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the read queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the read queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7583"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7586"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7583 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7586 "><span>Handle of the communication channel as returned by the DRV_AK4954_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Read queue purge is successful. False - Read queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_AK4954_BufferAddRead to queue read requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_AK4954_ReadQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the read queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4954_ReadQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title118" id="drv-ak4954-writequeuepurge-function"><h5 class="title topictitle5" id="ariaid-title118">DRV_AK4954_WriteQueuePurge Function</h5><div class="body"><p class="p">bool DRV_AK4954_WriteQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the write queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the write queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7690"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7693"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7690 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7693 "><span>Handle of the communication channel as returned by the DRV_AK4954_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Write queue purge is successful. False - Write queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_AK4954_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_AK4954_BufferAddWrite to queue write requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_AK4954_WriteQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the write queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4954_WriteQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title119" id="settings-functions-1"><h4 class="title topictitle4" id="ariaid-title119">Settings Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title120" id="drv-ak4954-micgainget-function"><h5 class="title topictitle5" id="ariaid-title120">DRV_AK4954_MicGainGet Function</h5><div class="body"><p class="p">uint8_t DRV_AK4954_MicGainGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the microphone gain for the AK4954 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current microphone gain programmed to the Codec AK4954.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7803"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7806"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7803 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7806 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Microphone gain, in range 0-31.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t gain;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">gain = DRV_AK4954_MicGainGet(myAK4954Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_AK4954_MicGainGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title121" id="drv-ak4954-micgainset-function"><h5 class="title topictitle5" id="ariaid-title121">DRV_AK4954_MicGainSet Function</h5><div class="body"><p class="p">void DRV_AK4954_MicGainSet(DRV_HANDLE handle, uint8_t gain)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the microphone gain for the AK4954 CODEC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the microphone gain value from 0-31 which can range from -1.5 to 28.3 dB</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7881"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7884"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7881 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7884 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7881 "><span>gain</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7884 "><span>Gain value, in range 0-31</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_MicGainSet(myAK4954Handle, 15); <em class="ph i">//AK4954 mic gain set to 15</em></p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MicGainSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint8_t <strong class="ph b">gain</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title122" id="drv-ak4954-micmuteoff-function"><h5 class="title topictitle5" id="ariaid-title122">DRV_AK4954_MicMuteOff Function</h5><div class="body"><p class="p">void DRV_AK4954_MicMuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Umutes th AK4954's microphone input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function unmutes the AK4954's microphone input.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7969"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e7972"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7969 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e7972 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_MicMuteOff(myAK4954Handle); <em class="ph i">//AK4954 microphone unmuted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MicMuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title123" id="drv-ak4954-micmuteon-function"><h5 class="title topictitle5" id="ariaid-title123">DRV_AK4954_MicMuteOn Function</h5><div class="body"><p class="p">void DRV_AK4954_MicMuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Mutes the AK4954's microphone input</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function mutes the AK4954's microphone input</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8052"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8055"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8052 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8055 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_MicMuteOn(myAK4954Handle); <em class="ph i">//AK4954 microphone muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MicMuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title124" id="drv-ak4954-micset-function"><h5 class="title topictitle5" id="ariaid-title124">DRV_AK4954_MicSet Function</h5><div class="body"><p class="p">void DRV_AK4954_IntMic12Set</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the internal or the AK4954 Mic1 or Mic2 input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8135"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8138"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8135 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8138 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8135 "><span>micInput</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8138 "><span>Internal vs External mic input</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_MIC <strong class="ph b">micInput</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title125" id="drv-ak4954-monostereomicset-function"><h5 class="title topictitle5" id="ariaid-title125">DRV_AK4954_MonoStereoMicSet Function</h5><div class="body"><p class="p">void DRV_AK4954_MonoStereoMicSet(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the Mono or Stereo microphone mode.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec for the Mono or Stereo microphone mode.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8211"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8214"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8211 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8214 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MonoStereoMicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_MONO_STEREO_MIC <strong class="ph b">mono_stereo_mic</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title126" id="drv-ak4954-muteoff-function"><h5 class="title topictitle5" id="ariaid-title126">DRV_AK4954_MuteOff Function</h5><div class="body"><p class="p">void DRV_AK4954_MuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function disables AK4954 output for soft mute.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function disables AK4954 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8282"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8285"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8282 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8285 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_MuteOff(myAK4954Handle); <em class="ph i">//AK4954 output soft mute disabled</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title127" id="drv-ak4954-muteon-function"><h5 class="title topictitle5" id="ariaid-title127">DRV_AK4954_MuteOn Function</h5><div class="body"><p class="p">void DRV_AK4954_MuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows AK4954 output for soft mute on.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function Enables AK4954 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8370"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8373"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8370 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8373 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_MuteOn(myAK4954Handle); <em class="ph i">//AK4954 output soft muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_MuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title128" id="drv-ak4954-intextmicset-function"><h5 class="title topictitle5" id="ariaid-title128">DRV_AK4954_IntExtMicSet Function</h5><div class="body"><p class="p">void DRV_AK4954_IntExtMicSet</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets up the codec for the X32 DB internal or the external microphone use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets up the codec for the internal or the external microphone use.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8458"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8461"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8458 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8461 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8458 "><span>micInput</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8461 "><span>Internal vs External mic input</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_IntExtMicSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_INT_EXT_MIC <strong class="ph b">micInput</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title129" id="drv-ak4954-samplingrateget-function"><h5 class="title topictitle5" id="ariaid-title129">DRV_AK4954_SamplingRateGet Function</h5><div class="body"><p class="p">uint32_t DRV_AK4954_SamplingRateGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the sampling rate set on the DAC AK4954.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function gets the sampling rate set on the DAC AK4954.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8535"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8538"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8535 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8538 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint32_t baudRate;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">baudRate = DRV_AK4954_SamplingRateGet(myAK4954Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_AK4954_SamplingRateGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title130" id="drv-ak4954-samplingrateset-function"><h5 class="title topictitle5" id="ariaid-title130">DRV_AK4954_SamplingRateSet Function</h5><div class="body"><p class="p">void DRV_AK4954_SamplingRateSet(DRV_HANDLE handle, uint32_t samplingRate)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the sampling rate of the media stream.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the media sampling rate for the client handle.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8611"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8614"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8611 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8614 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_SamplingRateSet(myAK4954Handle, 48000); <em class="ph i">//Sets 48000 media sampling rate</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_SamplingRateSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint32_t <strong class="ph b">samplingRate</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title131" id="drv-ak4954-volumeget-function"><h5 class="title topictitle5" id="ariaid-title131">DRV_AK4954_VolumeGet Function</h5><div class="body"><p class="p">uint8_t DRV_AK4954_VolumeGet(DRV_HANDLE handle, DRV_AK4954_CHANNEL chan)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the volume for AK4954 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current volume programmed to the CODEC AK4954.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8692"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8695"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8692 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8695 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8692 "><span>chan</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8695 "><span>Audio channel volume to be set</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t volume;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">volume = DRV_AK4954_VolumeGet(myAK4954Handle,DRV_AK4954_CHANNEL_LEFT);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_AK4954_VolumeGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_CHANNEL <strong class="ph b">chan</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title132" id="drv-ak4954-volumeset-function"><h5 class="title topictitle5" id="ariaid-title132">DRV_AK4954_VolumeSet Function</h5><div class="body"><p class="p">void DRV_AK4954_VolumeSet(DRV_HANDLE handle, DRV_AK4954_CHANNEL channel, uint8_t volume);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the volume for AK4954 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the volume value from 0-255. The codec has DAC value to volume range mapping as :- 00 H : +12dB FF H : -115dB In order to make the volume value to dB mapping monotonically increasing from 00 to FF, re-mapping is introduced which reverses the volume value to dB mapping as well as normalizes the volume range to a more audible dB range. The current driver implementation assumes that all dB values under -60 dB are inaudible to the human ear. Re-Mapped values 00 H : -60 dB FF H : +12 dB</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8778"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8781"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8778 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8781 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8778 "><span>chan</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8781 "><span>Audio channel volume to be set</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8778 "><span>volume</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8781 "><span>volume value specified in the range 0-255 (0x00 to 0xFF)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned // by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_VolumeSet(myAK4954Handle, DRV_AK4954_CHANNEL_LEFT, 120);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_AK4954_VolumeSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_AK4954_CHANNEL <strong class="ph b">channel</strong>, uint8_t <strong class="ph b">volume</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title133" id="other-functions-1"><h4 class="title topictitle4" id="ariaid-title133">Other Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title134" id="drv-ak4954-lrclk-sync-function"><h5 class="title topictitle5" id="ariaid-title134">DRV_AK4954_LRCLK_Sync Function</h5><div class="body"><p class="p">uint32_t DRV_AK4954_LRCLK_Sync (const DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Synchronize to the start of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function waits until low-to high transition of the I2S LRCLK (left/right clock) signal (high-low if Left-Justified format, this is determined by the PLIB). In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize calls to the DMA with the LRCLK signal so the left/right channel association is valid.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8882"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8885"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8882 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8885 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAK4954Handle is the handle returned</em> <em class="ph i">// by the DRV_AK4954_Open function.</em></p>
<p class="p">DRV_AK4954_LRCLK_Sync(myAK4954Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_AK4954_LRCLK_Sync</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title135" id="drv-ak4954-geti2sdriver-function"><h5 class="title topictitle5" id="ariaid-title135">DRV_AK4954_GetI2SDriver Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_AK4954_GetI2SDriver(DRV_HANDLE codecHandle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the handle to the I2S driver for this codec instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Returns the appropriate handle to the I2S based on the ioIent member of the codec object.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_AK4954_Initialize routine must have been called for the specified AK4954 driver instance.</p>
<p class="p">DRV_AK4954_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8964"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e8967"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8964 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e8967 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<ul class="ul"><li class="li"><p class="p">A handle to the I2S driver for this codec instance</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This allows the caller to directly access portions of the I2S driver that might not be available via the codec API.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_AK4954_GetI2SDriver</strong>(DRV_HANDLE <strong class="ph b">codecHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title136" id="drv-ak4954-versionstrget-function"><h5 class="title topictitle5" id="ariaid-title136">DRV_AK4954_VersionStrGet Function</h5><div class="body"><p class="p">int8_t* DRV_AK4954_VersionStrGet(void)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of AK4954 driver in string format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The DRV_AK4954_VersionStrGet function returns a string in the format: ".<span class="xref"></span>" Where: is the AK4954 driver's version number. is the AK4954 driver's version number. is an optional "patch" or "dot" release number (which is not included in the string if it equals "00"). is an optional release type ("a" for alpha, "b" for beta ? not the entire word spelled out) that is not included if the release is a production version (I.e. Not an alpha or beta).</p>
<p class="p">The String does not contain any spaces.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns a string containing the version of AK4954 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">"0.03a" "1.00"</p>
<p class="p"><strong class="ph b">Example 2</strong></p>
<p class="p">int8_t *AK4954string; AK4954string = DRV_AK4954_VersionStrGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int8_t* <strong class="ph b">DRV_AK4954_VersionStrGet</strong>();</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title137" id="drv-ak4954-versionget-function"><h5 class="title topictitle5" id="ariaid-title137">DRV_AK4954_VersionGet Function</h5><div class="body"><p class="p">uint32_t DRV_AK4954_VersionGet( void )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of AK4954 driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The version number returned from the DRV_AK4954_VersionGet function is an unsigned integer in the following decimal format. * 10000 + * 100 + Where the numbers are represented in decimal and the meaning is the same as above. Note that there is no numerical representation of release type.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns the version of AK4954 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">For version "0.03a", return: 0 * 10000 + 3 * 100 + 0 For version "1.00", return: 1 * 100000 + 0 * 100 + 0</p>
<p class="p"><strong class="ph b">Example 2</strong></p>
<p class="p">uint32_t AK4954version; AK4954version = DRV_AK4954_VersionGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_AK4954_VersionGet</strong>();</p>
<p class="p"><strong class="ph b">Data Types and Constants</strong></p>
</div>
</div>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title138" id="drv-ak4954-audio-data-format-type"><h2 class="title topictitle2" id="ariaid-title138"><em class="ph i">DRV_AK4954_AUDIO_DATA_FORMAT Type</em></h2><div class="body"><p class="p">Identifies the Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Audio data format</p>
<p class="p">This enumeration identifies Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4954_AUDIO_DATA_FORMAT@1 <strong class="ph b">DRV_AK4954_AUDIO_DATA_FORMAT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title139" id="drv-ak4954-buffer-event-type"><h2 class="title topictitle2" id="ariaid-title139"><em class="ph i">DRV_AK4954_BUFFER_EVENT Type</em></h2><div class="body"><p class="p">Identifies the possible events that can result from a buffer add request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Events</p>
<p class="p">This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_AK4954_BufferAddWrite() or the DRV_AK4954_BufferAddRead() function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">One of these values is passed in the "event" parameter of the event handling callback function that the client registered with the driver by calling the DRV_AK4954_BufferEventHandlerSet function when a buffer transfer request is completed.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4954_BUFFER_EVENT@1 <strong class="ph b">DRV_AK4954_BUFFER_EVENT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title140" id="drv-ak4954-buffer-event-handler-type"><h2 class="title topictitle2" id="ariaid-title140"><em class="ph i">DRV_AK4954_BUFFER_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a AK4954 Driver Buffer Event handler function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Buffer Event Handler Function</p>
<p class="p">This data type defines the required function signature for the AK4954 driver buffer event handling callback function. A client must register a pointer to a buffer event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9192"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9195"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9192 "><span>event</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9195 "><span>Identifies the type of event</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9192 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9195 "><span>Handle identifying the buffer to which the event relates</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9192 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9195 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the event is DRV_AK4954_BUFFER_EVENT_COMPLETE, this means that the data was transferred successfully.</p>
<p class="p">If the event is DRV_AK4954_BUFFER_EVENT_ERROR, this means that the data was not transferred successfully. The bufferHandle parameter contains the buffer handle of the buffer that failed. The DRV_AK4954_BufferProcessedSizeGet() function can be called to find out how many bytes were processed.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that associated with the event.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_AK4954_BufferEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The buffer handle in bufferHandle expires after this event handler exits. In that the buffer object that was allocated is deallocated by the driver after the event handler exits.</p>
<p class="p">The event handler function executes in the data driver(i2S) peripheral's interrupt context when the driver is configured for interrupt mode operation. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p">DRV_AK4954_BufferAddWrite function can be called in the event handler to add a buffer to the driver queue.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_MyBufferEventHandler( DRV_AK4954_BUFFER_EVENT event, DRV_AK4954_BUFFER_HANDLE bufferHandle, uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_COMPLETE: <em class="ph i">// Handle the completed buffer.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_AK4954_BUFFER_EVENT_ERROR: <strong class="ph b">default</strong>: <em class="ph i">// Handle error.</em> <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_AK4954_BUFFER_EVENT_HANDLER</strong>)(DRV_AK4954_BUFFER_EVENT event, DRV_AK4954_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title141" id="drv-ak4954-buffer-handle-type"><h2 class="title topictitle2" id="ariaid-title141"><em class="ph i">DRV_AK4954_BUFFER_HANDLE Type</em></h2><div class="body"><p class="p">Handle identifying a write buffer passed to the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Buffer Handle</p>
<p class="p">A buffer handle value is returned by a call to the DRV_AK4954_BufferAddWrite() or DRV_AK4954_BufferAddRead() function. This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer.</p>
<p class="p">The buffer handle value returned from the "buffer add" function is returned back to the client by the "event handler callback" function registered with the driver.</p>
<p class="p">The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> uintptr_t <strong class="ph b">DRV_AK4954_BUFFER_HANDLE</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title142" id="drv-ak4954-channel-type"><h2 class="title topictitle2" id="ariaid-title142"><em class="ph i">DRV_AK4954_CHANNEL Type</em></h2><div class="body"><p class="p">Identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Audio Channel</p>
<p class="p">This enumeration identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p">DRV_AK4954_CHANNEL@1 <strong class="ph b">DRV_AK4954_CHANNEL</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title143" id="drv-ak4954-command-event-handler-type"><h2 class="title topictitle2" id="ariaid-title143"><em class="ph i">DRV_AK4954_COMMAND_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a AK4954 Driver Command Event Handler Function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Command Event Handler Function</p>
<p class="p">This data type defines the required function signature for the AK4954 driver command event handling callback function.</p>
<p class="p">A command is a control instruction to the AK4954 Codec. Example Mute ON/OFF, Zero Detect Enable/Disable etc.</p>
<p class="p">A client must register a pointer to a command event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive command related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9373"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9376"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9373 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9376 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The occurrence of this call back means that the last control command was transferred successfully.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_AK4954_CommandEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The event handler function executes in the control data driver interrupt context. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_AK4954CommandEventHandler( uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context;</p>
<p class="p"><em class="ph i">// Last Submitted command is completed.</em> <em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_AK4954_COMMAND_EVENT_HANDLER</strong>)(uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title144" id="drv-ak4954-digital-block-control-type"><h2 class="title topictitle2" id="ariaid-title144"><em class="ph i">DRV_AK4954_DIGITAL_BLOCK_CONTROL Type</em></h2><div class="body"><p class="p">Identifies Bass-Boost Control function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Bass-Boost Control</p>
<p class="p">This enumeration identifies the settings for Bass-Boost Control function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p">DRV_AK4954_DIGITAL_BLOCK_CONTROL@1 <strong class="ph b">DRV_AK4954_DIGITAL_BLOCK_CONTROL</strong>;</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title145" id="drv-ak4954-init-type"><h3 class="title topictitle3" id="ariaid-title145">DRV_AK4954_INIT Type</h3><div class="body"><p class="p">Defines the data required to initialize or reinitialize the AK4954 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Initialization Data</p>
<p class="p">This data type defines the data required to initialize or reinitialize the AK4954 Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">struct</strong> DRV_AK4954_INIT@1 <strong class="ph b">DRV_AK4954_INIT</strong>;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title146" id="drv-ak4954-int-ext-mic-type"><h2 class="title topictitle2" id="ariaid-title146"><em class="ph i">DRV_AK4954_INT_EXT_MIC Type</em></h2><div class="body"><p class="p">Identifies the Mic input source.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Mic Internal / External Input</p>
<p class="p">This enumeration identifies the Mic input source.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4954_INT_EXT_MIC@1 <strong class="ph b">DRV_AK4954_INT_EXT_MIC</strong>;</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title147" id="drv-ak4954-mic-type"><h3 class="title topictitle3" id="ariaid-title147">DRV_AK4954_MIC Type</h3><div class="body"><p class="p">This is type DRV_AK4954_MIC.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4954_MIC@1 <strong class="ph b">DRV_AK4954_MIC</strong>;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title148" id="drv-ak4954-mono-stereo-mic-type"><h2 class="title topictitle2" id="ariaid-title148"><em class="ph i">DRV_AK4954_MONO_STEREO_MIC Type</em></h2><div class="body"><p class="p">Identifies the Mic input as Mono / Stereo.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Mic Mono / Stereo Input</p>
<p class="p">This enumeration identifies the Mic input as Mono / Stereo.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_AK4954_MONO_STEREO_MIC@1 <strong class="ph b">DRV_AK4954_MONO_STEREO_MIC</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title149" id="sample-length-type"><h2 class="title topictitle2" id="ariaid-title149"><em class="ph i">SAMPLE_LENGTH Type</em></h2><div class="body"><p class="p">in bits</p>
<p class="p">SAMPLE_LENGTH@2 <strong class="ph b">SAMPLE_LENGTH</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title150" id="drv-ak4954-audio-data-format-i2s-macro"><h2 class="title topictitle2" id="ariaid-title150"><em class="ph i">DRV_AK4954_AUDIO_DATA_FORMAT_I2S Macro</em></h2><div class="body"><p class="p">for compatability with old code</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_AUDIO_DATA_FORMAT_I2S</strong> DRV_AK4954_AUDIO_DATA_FORMAT_I2S_16BIT_24BIT <em class="ph i">// for compatability with old code</em></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title151" id="drv-ak4954-buffer-handle-invalid-macro"><h2 class="title topictitle2" id="ariaid-title151"><em class="ph i">DRV_AK4954_BUFFER_HANDLE_INVALID Macro</em></h2><div class="body"><p class="p">Definition of an invalid buffer handle.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Invalid Buffer Handle</p>
<p class="p">This is the definition of an invalid buffer handle. An invalid buffer handle is returned by DRV_AK4954_BufferAddWrite() and the DRV_AK4954_BufferAddRead() function if the buffer add request was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_BUFFER_HANDLE_INVALID</strong> ((DRV_AK4954_BUFFER_HANDLE)(-1))</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title152" id="drv-ak4954-count-macro"><h3 class="title topictitle3" id="ariaid-title152">DRV_AK4954_COUNT Macro</h3><div class="body"><p class="p">Number of valid AK4954 driver indices</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Driver Module Count</p>
<p class="p">This constant identifies the maximum number of AK4954 Driver instances that should be defined by the application. Defining more instances than this constant will waste RAM memory space.</p>
<p class="p">This constant can also be used by the application to identify the number of AK4954 instances on this microcontroller.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This value is part-specific.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_COUNT</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title153" id="drv-ak4954-index-0-macro"><h3 class="title topictitle3" id="ariaid-title153">DRV_AK4954_INDEX_0 Macro</h3><div class="body"><p class="p">AK4954 driver index definitions</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Driver AK4954 Module Index</p>
<p class="p">These constants provide AK4954 driver index definition.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">These constants should be used in place of hard-coded numeric literals. These values should be passed into the</p>
<p class="p">DRV_AK4954_Initialize and DRV_AK4954_Open routines to identify the driver instance in use.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_0</strong> 0</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title154" id="drv-ak4954-index-1-macro"><h3 class="title topictitle3" id="ariaid-title154">DRV_AK4954_INDEX_1 Macro</h3><div class="body"><p class="p">This is macro DRV_AK4954_INDEX_1.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_1</strong> 1</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title155" id="drv-ak4954-index-2-macro"><h3 class="title topictitle3" id="ariaid-title155">DRV_AK4954_INDEX_2 Macro</h3><div class="body"><p class="p">This is macro DRV_AK4954_INDEX_2.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_2</strong> 2</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title156" id="drv-ak4954-index-3-macro"><h3 class="title topictitle3" id="ariaid-title156">DRV_AK4954_INDEX_3 Macro</h3><div class="body"><p class="p">This is macro DRV_AK4954_INDEX_3.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_3</strong> 3</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title157" id="drv-ak4954-index-4-macro"><h3 class="title topictitle3" id="ariaid-title157">DRV_AK4954_INDEX_4 Macro</h3><div class="body"><p class="p">This is macro DRV_AK4954_INDEX_4.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_4</strong> 4</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title158" id="drv-ak4954-index-5-macro"><h3 class="title topictitle3" id="ariaid-title158">DRV_AK4954_INDEX_5 Macro</h3><div class="body"><p class="p">This is macro DRV_AK4954_INDEX_5.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_AK4954_INDEX_5</strong> 5</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title159" id="files"><h3 class="title topictitle3" id="ariaid-title159">Files</h3><div class="body"><p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9771"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9774"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9771 "><span>drv_ak4954.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9774 "><span>AK4954 Codec Driver Interface header file</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9771 "><span>drv_ak4954_config_template.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9774 "><span>AK4954 Codec Driver Configuration Template.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title160" id="drv-ak4954h"><h3 class="title topictitle3" id="ariaid-title160">drv_ak4954.h</h3><div class="body"><p class="p">drv_ak4954.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">AK4954 Codec Driver Interface header file</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Codec Driver Interface</p>
<p class="p">The AK4954 Codec device driver interface provides a simple interface to manage the AK4954 16/24/32-Bit Codec that can be interfaced to a Microchip microcontroller. This file provides the public interface definitions for the AK4954 Codec device driver.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title161" id="drv-ak4954-config-templateh"><h3 class="title topictitle3" id="ariaid-title161">drv_ak4954_config_template.h</h3><div class="body"><p class="p">drv_ak4954_config_template.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">AK4954 Codec Driver Configuration Template.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">AK4954 Codec Driver Configuration Template</p>
<p class="p">These file provides the list of all the configurations that can be used with the driver. This file should not be included in the driver.</p>
<p class="p"><strong class="ph b">GENERIC AUDIO DRIVER CODEC Library</strong></p>
<p class="p">This topic describes the Generic Codec Driver Library.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title162" id="introduction-2"><h2 class="title topictitle2" id="ariaid-title162"><em class="ph i">Introduction</em></h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title163" id="summary"><h3 class="title topictitle3" id="ariaid-title163">Summary</h3><div class="body"><p class="p">This library provides an Applications Programming Interface (API) to manage the Generic Codec that is serially interfaced to the I2C and I2S peripherals of a Microchip microcontroller for the purpose of providing audio solutions.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title164" id="description"><h3 class="title topictitle3" id="ariaid-title164">Description</h3><div class="body"><p class="p">This file contains the implementation of the Generic Codec driver, which provides a simple interface to manage a codec that can be interfaced to Microchip microcontroller. The user will need to modify it to match the requirements of their codec. Areas where code needs to be added or changed are marked with TO-DO!!</p>
<p class="p">Note: this module assumes the codec is controlled over an I2C interface. The I2C Driver will need to be enabled in the MHC Project Graph. If another type of interface is used, the user will need to modify the code to suit. This module makes use of SYS_TIME. It will need to be enabled in the Project Graph.</p>
<p class="p">This module assumes the an I2S interface is used for audio data output (to headphones or line-out) and input (from microphone or line-in).</p>
<p class="p">The Generic Codec can be configured as either an I2S clock slave (receives all clocks from the host), or I2S clock master (generates I2S clocks from a master clock input MCLK).</p>
<p class="p">A typical interface of Generic Codec to a Microchip microcontroller using an I2C and SSC interface (configured as I2S), with the Generic Codec set up as the I2S clock slave, is provided in the following diagram:
<img class="image" src="GUID-98432D6B-B7BB-41C7-81E9-59C3894319CD-low.png" /><br /></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title165" id="using-the-library"><h2 class="title topictitle2" id="ariaid-title165"><em class="ph i">Using the Library</em></h2><div class="body"><p class="p">This topic describes the basic architecture of the Generic Codec Driver Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title166" id="interface-header-file-drv-generich"><h3 class="title topictitle3" id="ariaid-title166">Interface Header File: drv_Generic.h</h3><div class="body"><p class="p">The interface to the Generic Codec Driver library is defined in the audio/driver/codec/Generic/drv_Generic.h header file. Any C language source (.c) file that uses the Generic Codec Driver library should include this header.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The Generic Codec Driver library source files are provided in the audio/driver/codec/Generic/src directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features and to <strong class="ph b">Building the Library</strong> for instructions on how to build the library.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This codec is not used directly by any demonstration applications. However the following applications could be looked at, to see how a codec such as the WM8904 or AK4954 is used:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title167" id="abstraction-model-1"><h2 class="title topictitle2" id="ariaid-title167">Abstraction Model</h2><div class="body"><p class="p">This library provides a low-level abstraction of the Generic Codec Driver Library on the Microchip family microcontrollers with a convenient C language interface. This topic describes how that abstraction is modeled in software and introduces the library's interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The abstraction model shown in the following diagram depicts how the Generic Codec Driver is positioned in the MPLAB Harmony framework. The Generic Codec Driver uses the I2C and I2S drivers for control and audio data transfers to the Generic module.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title168" id="generic-driver-abstraction-model"><h3 class="title topictitle3" id="ariaid-title168">Generic Driver Abstraction Model</h3><div class="body"><br /><img class="image" src="GUID-4461FAD4-1090-4853-AA68-0119968102AD-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title169" id="library-overview-2"><h2 class="title topictitle2" id="ariaid-title169">Library Overview</h2><div class="body"><p class="p">Refer to the Driver Library Overview section for information on how the driver operates in a system.</p>
<p class="p">The Generic Codec Driver Library provides an API interface to transfer control commands and digital audio data to the serially interfaced Generic Codec module. The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the Generic Codec Driver Library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9931"><span><strong class="ph b">Library Interface Section</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e9934"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>System Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>Provides system module interfaces, device initialization, deinitialization, reinitialization, tasks and status functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>Client Setup Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>Provides open and close functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>Data Transfer Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>Provides data transfer functions, such as Buffer Read and Write.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>Settings Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>Provides driver specific functions for settings, such as volume control and sampling rate.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>Other Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>Miscellaneous functions, such as getting the driver’s version number and syncing to the LRCLK signal.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9931 "><span>Data Types and Constants</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e9934 "><span>These data types and constants are required while interacting and setting up the Generic Codec Driver Library.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> All functions and constants in this section are named with the format DRV_ Generic_xxx, where 'xxx' is a function name or constant. These names are redefined in the appropriate configuration’s configuration.h file to the format DRV_CODEC_xxx using #defines so that code in the application that references the library can be written as generically as possible (e.g., by writing DRV_CODEC_Open instead of DRV_ Generic_Open etc.). This allows the codec type to be changed in the MHC without having to modify the application’s source code.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title170" id="how-the-library-works-2"><h2 class="title topictitle2" id="ariaid-title170">How the Library Works</h2><div class="body"><p class="p">How the Library Works</p>
<p class="p">The library provides interfaces to support:</p>
<ul class="ul"><li class="li"><p class="p">System Functionality</p>
</li>
<li class="li"><p class="p">Client Functionality</p>
</li>
</ul>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title171" id="setup-initialization-2"><h3 class="title topictitle3" id="ariaid-title171">Setup (Initialization)</h3><div class="body"><p class="p">This topic describes system initialization, implementations, and includes a system access code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title172" id="system-initialization-1"><h2 class="title topictitle2" id="ariaid-title172">System Initialization</h2><div class="body"><p class="p">The system performs the initialization of the device driver with settings that affect only the instance of the device that is being initialized. During system initialization in the system_init.c file, each instance of the Generic module would be initialized with the following configuration settings (either passed dynamically at run time using DRV_Generic_INIT or by using Initialization Overrides) that are supported by the specific Generic device hardware:</p>
<ul class="ul"><li class="li"><p class="p">Device requested power state: one of the System Module Power States. For specific details please refer to Data Types and Constants in the Library Interface section.</p>
</li>
<li class="li"><p class="p">I2C driver module index. The module index should be same as the one used in initializing the I2C Driver</p>
</li>
<li class="li"><p class="p">I2S driver module index. The module index should be same as the one used in initializing the I2S Driver</p>
</li>
<li class="li"><p class="p">Sampling rate</p>
</li>
<li class="li"><p class="p">Volume</p>
</li>
<li class="li"><p class="p">Audio data format. The audio data format should match with the audio data format settings done in I2S driver initialization</p>
</li>
<li class="li"><p class="p">Determines whether or not the microphone input is enabled</p>
</li>
</ul>
<p class="p">The DRV_Generic_Initialize API returns an object handle of the type SYS_MODULE_OBJ. The object handle returned by the Initialize interface would be used by the other system interfaces such as DRV_ Generic_Deinitialize, DRV_ Generic_Status and DRV_I2S_Tasks.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title173" id="client-access-2"><h3 class="title topictitle3" id="ariaid-title173">Client Access</h3><div class="body"><p class="p">This topic describes driver initialization and provides a code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">For the application to start using an instance of the module, it must call the DRV_Generic_Open function. The</p>
<p class="p">DRV_Generic_Open function provides a driver handle to the Generic Codec Driver instance for operations. If the driver is deinitialized using the function DRV_Generic_Deinitialize, the application must call the DRV_Generic_Open function again to set up the instance of the driver.</p>
<p class="p">For the various options available for IO_INTENT, please refer to Data Types and Constants in the Library Interface section.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is necessary to check the status of driver initialization before opening a driver instance. The status of the Generic Codec Driver can be known by calling DRV_ Generic_Status.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_HANDLE handle; SYS_STATUS genericStatus;</p>
<p class="p">genericStatus Status = DRV_Generic_Status(sysObjects.genericStatus DevObject); if (SYS_STATUS_READY == genericStatus) { // The driver can now be opened.</p>
<p class="p">appData.genericClient.handle = DRV_Generic_Open</p>
<p class="p">(DRV_Generic_INDEX_0, DRV_IO_INTENT_WRITE | DRV_IO_INTENT_EXCLUSIVE); if(appData.genericClient.handle != DRV_HANDLE_INVALID) {</p>
<p class="p">appData.state = APP_STATE_Generic_SET_BUFFER_HANDLER; } else { SYS_DEBUG(0, "Find out what's wrong \r\n");</p>
<p class="p">} } else { /* Generic Driver Is not ready */</p>
<p class="p">}</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title174" id="client-operations-2"><h3 class="title topictitle3" id="ariaid-title174">Client Operations</h3><div class="body"><p class="p">This topic provides information on client operations.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Client operations provide the API interface for control command and audio data transfer to the Generic Codec.</p>
<p class="p">The following Generic Codec specific control command functions are provided:</p>
<ul class="ul"><li class="li"><p class="p">DRV_Generic_SamplingRateSet</p>
</li>
<li class="li"><p class="p">DRV_Generic_SamplingRateGet</p>
</li>
<li class="li"><p class="p">DRV_Generic_VolumeSet</p>
</li>
<li class="li"><p class="p">DRV_Generic_VolumeGet</p>
</li>
<li class="li"><p class="p">DRV_Generic_MuteOn</p>
</li>
<li class="li"><p class="p">DRV_Generic_MuteOff</p>
</li>
</ul>
<p class="p">These functions schedule a non-blocking control command transfer operation. These functions submit the control command request to the Generic Codec. These functions submit the control command request to I2C Driver transmit queue, the request is processed immediately if it is the first request, or processed when the previous request is complete.</p>
<p class="p">DRV_Generic_BufferAddWrite, DRV_Generic_BufferAddRead, and DRV_Generic_BufferAddWriteRead are buffered data operation functions. These functions schedule non-blocking audio data transfer operations. These functions add the request to I2S Driver transmit or receive buffer queue depends on the request type, and are executed immediately if it is the first buffer, or executed later when the previous buffer is complete. The driver notifies the client with</p>
<p class="p">DRV_Generic_BUFFER_EVENT_COMPLETE, DRV_Generic_BUFFER_EVENT_ERROR, or DRV_Generic_BUFFER_EVENT_ABORT events.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is not necessary to close and reopen the client between multiple transfers.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title175" id="configuring-the-library-2"><h3 class="title topictitle3" id="ariaid-title175">Configuring the Library</h3><div class="body"><p class="p">The configuration of the I2S Driver Library is based on the file configurations.h, as generated by the MHC.</p>
<p class="p">This header file contains the configuration selection for the I2S Driver Library. Based on the selections made, the I2S Driver Library may support the selected features. These configuration settings will apply to all instances of the I2S Driver Library.</p>
<p class="p">This header can be placed anywhere; however, the path of this header needs to be present in the include search path for a successful build. Refer to the Applications Help section for more details.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title176" id="system-configuration-2"><h3 class="title topictitle3" id="ariaid-title176">System Configuration</h3><div class="body"><p class="p"><strong class="ph b">Macros</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10135"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10137"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10140"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_AUDIO_DATA_FORMAT_MACRO</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Specifies the audio data format for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_AUDIO_SAMPLING_RATE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Specifies the initial baud rate for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_CLIENTS_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Sets up the maximum number of clients that can be connected to any hardware instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_I2C_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Specifies the instance number of the I2C interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_I2S_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Specifies the instance number of the I2S interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_INSTANCES_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Sets up the maximum number of hardware instances that can be supported</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10135 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10137 "><span>DRV_GENERICCODEC_VOLUME</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10140 "><span>Specifies the initial volume level.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title177" id="drv-genericcodec-audio-data-format-macro-macro"><h2 class="title topictitle2" id="ariaid-title177"><em class="ph i">DRV_GENERICCODEC_AUDIO_DATA_FORMAT_MACRO Macro</em></h2><div class="body"><p class="p">Specifies the audio data format for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Audio Data Format</p>
<p class="p">Sets up the length of each sample plus the format (I2S or left-justified) for the audio.</p>
<p class="p">Valid choices are: "DATA_16_BIT_LEFT_JUSTIFIED", 16-bit Left Justified "DATA_16_BIT_I2S", 16-bit I2S"</p>
<p class="p">"DATA_32_BIT_LEFT_JUSTIFIED", 32-bit Left Justified "DATA_32_BIT_I2S", 32-bit I2S"</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_AUDIO_DATA_FORMAT_MACRO</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title178" id="drv-genericcodec-audio-sampling-rate-macro"><h2 class="title topictitle2" id="ariaid-title178"><em class="ph i">DRV_GENERICCODEC_AUDIO_SAMPLING_RATE Macro</em></h2><div class="body"><p class="p">Specifies the initial baud rate for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Baud Rate</p>
<p class="p">Sets the initial baud rate (sampling rate) for the codec. Typical values are 8000, 16000, 44100, 48000, 88200 and 96000.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_AUDIO_SAMPLING_RATE</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title179" id="drv-genericcodec-clients-number-macro"><h2 class="title topictitle2" id="ariaid-title179"><em class="ph i">DRV_GENERICCODEC_CLIENTS_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of clients that can be connected to any hardware instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Client Count Configuration</p>
<p class="p">Sets up the maximum number of clients that can be connected to any hardware instance. Typically only one client could be connected to one hardware instance. This value represents the total number of clients to be supported across all hardware instances.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_CLIENTS_NUMBER</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title180" id="drv-genericcodec-i2c-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title180"><em class="ph i">DRV_GENERICCODEC_I2C_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2C interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec I2C instance number</p>
<p class="p">Specifies the instance number of the I2C interface being used by the MCU to send commands and receive status to and from the Generic Codec. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_I2C_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title181" id="drv-genericcodec-i2s-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title181"><em class="ph i">DRV_GENERICCODEC_I2S_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2S interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec I2S instance number</p>
<p class="p">Specifies the instance number of the I2S interface being used by the MCU to send and receive audio data to and from the Generic Codec. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_I2S_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title182" id="drv-genericcodec-instances-number-macro"><h2 class="title topictitle2" id="ariaid-title182"><em class="ph i">DRV_GENERICCODEC_INSTANCES_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of hardware instances that can be supported</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec driver objects configuration</p>
<p class="p">Sets up the maximum number of hardware instances that can be supported. It is recommended that this number be set exactly equal to the number of Generic Codec modules that are needed by an application, namely one.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INSTANCES_NUMBER</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title183" id="drv-genericcodec-volume-macro"><h2 class="title topictitle2" id="ariaid-title183"><em class="ph i">DRV_GENERICCODEC_VOLUME Macro</em></h2><div class="body"><p class="p">Specifies the initial volume level.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Volume</p>
<p class="p">Sets the initial volume level, in the range 0-255.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The value is mapped to an internal Generic Codec volume level in the range 0-192 using a logarithmic table so the input scale appears linear (128 is half volume).</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_VOLUME</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title184" id="confuguring-mhc"><h3 class="title topictitle3" id="ariaid-title184">Confuguring MHC</h3><div class="body"><p class="p">Provides examples on how to configure the MPLAB Harmony Configurator (MHC) for a specific driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When building a new application, start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <em class="ph i">File &gt; New Project</em>. Chose the Configuration name the based on the BSP, and select the appropriate processor (such as ATSAME70Q21B).</p>
<p class="p">In the MHC, under Available Components select the appropriate BSP, such as SAM E70 Xplained Ultra. Under <em class="ph i">Audio&gt;Templates</em>, double-click on a codec template such as Generic. Answer Yes to all questions.</p>
<p class="p">You should end up with a project graph that looks like this, after rearranging the boxes:
<img class="image" src="GUID-FFCFDEBB-A94E-4375-A7AC-AD7C7AF3BB37-low.png" /><br /></p>
<p class="p">Click on the Generic Driver component (not Generic Codec) and the following menu will be displayed in the Configurations Options:
<img class="image" src="GUID-D90F9968-8569-4729-BDA2-B18F10381A33-low.png" /><br /></p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">I2C Driver Used</strong> will display the driver instance used for the I2C interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">I2S Driver Used</strong> will display the driver instance used for the I2S interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Number of Generic Clients</strong> indicates the maximum number of clients that can be connected to the Generic Driver.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Sampling Rate</strong> indicates the number of samples per second per channel, 8000 to 96,000.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Volume</strong> indicates the volume in a linear scale from 0-255.</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title185" id="-audio-data-format-is-either-2"><h4 class="title topictitle4" id="ariaid-title185">• Audio Data Format is either</h4><div class="body"><ul class="ul"><li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 16-bit Right-justified(DAC)</p>
</li>
<li class="li"><p class="p">24-bit Left Justified (ADC), 24-bit Left-justified(DAC)</p>
</li>
<li class="li"><p class="p">24/16-bit I2S</p>
</li>
<li class="li"><p class="p">32-bit Left Justified (ADC), 32-bit Left-justified(DAC)</p>
</li>
<li class="li"><p class="p">32-bit I2S</p>
</li>
</ul>
<p class="p">It must match the audio protocol and data length set up in either the SSC or I2S PLIB..</p>
<p class="p">You can also bring in the Generic Driver by itself, by double clicking Generic under Audio_-&gt;Driver-&gt;Codec_ in the Available Components list. You will then need to add any additional needed components manually and connect them together.</p>
<p class="p">Note that the Generic requires the TCx Peripheral Library and TIME System Service in order to perform some of its internal timing sequences.</p>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title186" id="building-the-library-1"><h3 class="title topictitle3" id="ariaid-title186">Building the Library</h3><div class="body"><p class="p">This section lists the files that are available in the Generic Codec Driver Library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section lists the files that are available in the src folder of the Generic Codec Driver. It lists which files need to be included in the build based on either a hardware feature present on the board or configuration option selected by the system.</p>
<p class="p">The following three tables list and describe the header (.h) and source (.c) files that implement this library. The parent folder for these files is audio/driver/codec/Generic.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title187" id="interface-files-1"><h3 class="title topictitle3" id="ariaid-title187">Interface File(s)</h3><div class="body"><p class="p">This table lists and describes the header files that must be included (i.e., using #include) by any code that uses this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10472"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10475"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10472 "><span>drv_genericcodec.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10475 "><span>Header file that exports the driver API.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title188" id="required-files-2"><h3 class="title topictitle3" id="ariaid-title188">Required File(s)</h3><div class="body"><p class="p"><img class="image" src="GUID-B924D07A-0D74-453B-BCDE-8190A195C55D-low.png" /><br /> <strong class="ph b"><em class="ph i">All of the required files listed in the following table are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use.</em></strong></p>
<p class="p">This table lists and describes the source and header files that must <em class="ph i">always</em> be included in the MPLAB X IDE project to build this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10505"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10508"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10505 "><span>/src/drv_genericcodec.c</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10508 "><span>This file contains implementation of the Generic Codec Driver.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title189" id="optional-files-2"><h3 class="title topictitle3" id="ariaid-title189">Optional File(s)</h3><div class="body"><p class="p">This table lists and describes the source and header files that may optionally be included if required for the desired implementation.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10529"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10532"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10529 "><span>N/A</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10532 "><span>No optional files are available for this library.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title190" id="module-dependencies-2"><h3 class="title topictitle3" id="ariaid-title190">Module Dependencies</h3><div class="body"><p class="p">The Generic Codec Driver Library depends on the following modules:</p>
<ul class="ul"><li class="li"><p class="p">I2S Driver Library</p>
</li>
<li class="li"><p class="p">I2C Driver Library</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title191" id="library-interface-2"><h4 class="title topictitle4" id="ariaid-title191"><em class="ph i">Library Interface</em></h4><div class="body"><p class="p"><strong class="ph b">Client Setup Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10569"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10571"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10574"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10569 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10571 "><span>DRV_GENERICCODEC_Open</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10574 "><span>Opens the specified Generic Codec driver instance and returns a handle to it</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10569 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10571 "><span>DRV_GENERICCODEC_Close</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10574 "><span>Closes an opened-instance of the Generic Codec driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10569 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10571 "><span>DRV_GENERICCODEC_BufferEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10574 "><span>This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10569 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10571 "><span>DRV_GENERICCODEC_CommandEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10574 "><span>This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Dara Types and Constants</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10616"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10618"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10621"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_BUFFER_EVENT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Identifies the possible events that can result from a buffer add request.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_BUFFER_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Pointer to a Generic Codec Driver Buffer Event handler function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_BUFFER_HANDLE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Handle identifying a write buffer passed to the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_CHANNEL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Identifies Left/Right Audio channel</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_COMMAND_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Pointer to a Generic Codec Driver Command Event Handler Function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INIT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Defines the data required to initialize or reinitialize the Generic Codec driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_BUFFER_HANDLE_INVALID</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Definition of an invalid buffer handle.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_COUNT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Number of valid Generic Codec driver indices</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_0</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Generic Codec driver index definitions</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_1</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>This is macro DRV_GENERICCODEC_INDEX_1.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_2</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>This is macro DRV_GENERICCODEC_INDEX_2.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_3</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>This is macro DRV_GENERICCODEC_INDEX_3.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_4</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>This is macro DRV_GENERICCODEC_INDEX_4.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_INDEX_5</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>This is macro DRV_GENERICCODEC_INDEX_5.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10616 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10618 "><span>DRV_GENERICCODEC_AUDIO_DATA_FORMAT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10621 "><span>Identifies the Serial Audio data interface format.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Transfer Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10741"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10743"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10746"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10741 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10743 "><span>DRV_GENERICCODEC_BufferAddRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10746 "><span>Schedule a non-blocking driver read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10741 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10743 "><span>DRV_GENERICCODEC_BufferAddWrite</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10746 "><span>Schedule a non-blocking driver write operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10741 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10743 "><span>DRV_GENERICCODEC_BufferAddWriteRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10746 "><span>Schedule a non-blocking driver write-read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10741 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10743 "><span>DRV_GENERICCODEC_ReadQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10746 "><span>Removes all buffer requests from the read queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10741 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10743 "><span>DRV_GENERICCODEC_WriteQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10746 "><span>Removes all buffer requests from the write queue.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Other Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10795"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10797"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10800"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10795 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10797 "><span>DRV_GENERICCODEC_GetI2SDriver</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10800 "><span>Get the handle to the I2S driver for this codec instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10795 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10797 "><span>DRV_GENERICCODEC_LRCLK_Sync</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10800 "><span>Synchronize to the start of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Settings Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10828"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10830"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10833"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MicGainGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function gets the microphone gain for the Generic Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MicGainSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function sets the microphone gain for the Generic Codec CODEC.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MicMuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>Umutes th Generic Codec's microphone input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MicMuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>Mutes the Generic Codec's microphone input</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function disables Generic Codec output for soft mute.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_MuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function allows Generic Codec output for soft mute on.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_SamplingRateGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function gets the sampling rate set on the Generic Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_SamplingRateSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function sets the sampling rate of the media stream.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_VersionGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function returns the version of Generic Codec driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_VersionStrGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function returns the version of Generic Codec driver in string format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_VolumeGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function gets the volume for Generic Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10828 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10830 "><span>DRV_GENERICCODEC_VolumeSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10833 "><span>This function sets the volume for Generic Codec.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">System Interaction Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10933"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10935"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e10938"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10933 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10935 "><span>DRV_GENERICCODEC_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10938 "><span>Initializes hardware and data for the instance of the Generic Codec module</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10933 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10935 "><span>DRV_GENERICCODEC_Deinitialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10938 "><span>Deinitializes the specified instance of the Generic Codec driver module</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10933 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10935 "><span>DRV_GENERICCODEC_Status</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10938 "><span>Gets the current status of the Generic Codec driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10933 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10935 "><span>DRV_GENERICCODEC_Tasks</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e10938 "><span>Maintains the driver's control and data interface state machine.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title192" id="system-interaction-functions-2"><h4 class="title topictitle4" id="ariaid-title192">System Interaction Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title193" id="drv-genericcodec-initialize-function"><h5 class="title topictitle5" id="ariaid-title193">DRV_GENERICCODEC_Initialize Function</h5><div class="body"><p class="p">SYS_MODULE_OBJ DRV_GENERICCODEC_Initialize</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const SYS_MODULE_INIT *const init</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes hardware and data for the instance of the Generic Codec module</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine initializes the Generic Codec driver instance for the specified driver index, making it ready for clients to open and use it. The initialization data is specified by the init parameter. The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Initialize must be called before calling this function to initialize the data interface of this Codec driver. DRV_I2C_Initialize must be called if SPI driver is used for handling the control interface of this Codec driver.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11014"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11017"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11014 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11017 "><span>Identifier for the driver instance to be initialized</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11014 "><span>init</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11017 "><span>Pointer to the data structure containing any data necessary to initialize the hardware. This pointer may be null if no data is required and default initialization is to be used.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, returns a valid handle to a driver instance object. Otherwise, it returns SYS_MODULE_OBJ_INVALID.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine must be called before any other Generic Codec routine is called.</p>
<p class="p">This routine should only be called once during system initialization unless DRV_GENERICCODEC_Deinitialize is called to deinitialize the driver instance. This routine will NEVER block for hardware access.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_GENERICCODEC_INIT init;</p>
<p class="p">SYS_MODULE_OBJ objectHandle; init-&gt;inUse = <strong class="ph b">true</strong>; init-&gt;status = SYS_STATUS_BUSY; init-&gt;numClients = 0; init-&gt;i2sDriverModuleIndex = genercicodecInit-&gt;i2sDriverModuleIndex; init-&gt;i2cDriverModuleIndex = genercicodecInit-&gt;i2cDriverModuleIndex; init-&gt;samplingRate = DRV_GENERICCODEC_AUDIO_SAMPLING_RATE; init-&gt;audioDataFormat = DRV_GENERICCODEC_AUDIO_DATA_FORMAT_MACRO; init-&gt;isInInterruptContext = <strong class="ph b">false</strong>; init-&gt;commandCompleteCallback = (DRV_GENERICCODEC_COMMAND_EVENT_HANDLER)0; init-&gt;commandContextData = 0; init-&gt;mclk_multiplier = DRV_GENERICCODEC_MCLK_SAMPLE_FREQ_MULTPLIER; objectHandle = DRV_GENERICCODEC_Initialize(DRV_GENERICCODEC_0, (SYS_MODULE_INIT*)init); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == objectHandle) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_MODULE_OBJ <strong class="ph b">DRV_GENERICCODEC_Initialize</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">drvIndex</strong>, <strong class="ph b">const</strong></p>
<p class="p">SYS_MODULE_INIT * <strong class="ph b">const</strong> <strong class="ph b">init</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title194" id="drv-genericcodec-deinitialize-function"><h5 class="title topictitle5" id="ariaid-title194">DRV_GENERICCODEC_Deinitialize Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_Deinitialize( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Deinitializes the specified instance of the Generic Codec driver module</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Deinitializes the specified instance of the Generic Codec driver module, disabling its operation (and any hardware). Invalidates all the internal data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_GENERICCODEC_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11119"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11122"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11119 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11122 "><span>Driver object handle, returned from the DRV_GENERICCODEC_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Once the Initialize operation has been called, the De-initialize operation must be called before the Initialize operation can be called again. This routine will NEVER block waiting for hardware.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_GENERICCODEC_Initialize</em></p>
<p class="p">SYS_STATUS status;</p>
<p class="p">DRV_GENERICCODEC_Deinitialize(object); status = DRV_GENERICCODEC_Status(object); <strong class="ph b">if</strong> (SYS_MODULE_DEINITIALIZED != status) {</p>
<p class="p"><em class="ph i">// Check again later if you need to know</em> <em class="ph i">// when the driver is deinitialized.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_Deinitialize</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title195" id="drv-genericcodec-status-function"><h5 class="title topictitle5" id="ariaid-title195">DRV_GENERICCODEC_Status Function</h5><div class="body"><p class="p">SYS_STATUS DRV_GENERICCODEC_Status( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the current status of the Generic Codec driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine provides the current status of the Generic Codec driver module.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_GENERICCODEC_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11207"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11210"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11207 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11210 "><span>Driver object handle, returned from the DRV_GENERICCODEC_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized</p>
<p class="p">SYS_STATUS_READY - Indicates that any previous module operation for the specified module has completed</p>
<p class="p">SYS_STATUS_BUSY - Indicates that a previous module operation for the specified module has not yet completed</p>
<p class="p">SYS_STATUS_ERROR - Indicates that the specified module is in an error state</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">A driver can opened only when its status is SYS_STATUS_READY.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_GENERICCODEC_Initialize</em></p>
<p class="p">SYS_STATUS GENERICCODECStatus;</p>
<p class="p">GENERICCODECStatus = DRV_GENERICCODEC_Status(object); <strong class="ph b">if</strong> (SYS_STATUS_READY == GENERICCODECStatus) {</p>
<p class="p"><em class="ph i">// This means the driver can be opened using the</em> <em class="ph i">// DRV_GENERICCODEC_Open() function.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_STATUS <strong class="ph b">DRV_GENERICCODEC_Status</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title196" id="drv-genericcodec-tasks-function"><h5 class="title topictitle5" id="ariaid-title196">DRV_GENERICCODEC_Tasks Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_Tasks(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Maintains the driver's control and data interface state machine.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine is used to maintain the driver's internal control and data interface state machine and implement its control and data interface implementations. This function should be called from the SYS_Tasks() function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11300"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11303"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11300 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11303 "><span>Object handle for the specified driver instance (returned from DRV_GENERICCODEC_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine is normally not called directly by an application. It is called by the system's Tasks routine (SYS_Tasks).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_GENERICCODEC_Initialize</em> <strong class="ph b">while</strong> (<strong class="ph b">true</strong>) {</p>
<p class="p">DRV_GENERICCODEC_Tasks (object);</p>
<p class="p"><em class="ph i">// Do other tasks</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_Tasks</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title197" id="client-setup-functions-2"><h4 class="title topictitle4" id="ariaid-title197">Client Setup Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title198" id="drv-genericcodec-open-function"><h5 class="title topictitle5" id="ariaid-title198">DRV_GENERICCODEC_Open Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_GENERICCODEC_Open</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT ioIntent</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Opens the specified Generic Codec driver instance and returns a handle to it</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine opens the specified Generic Codec driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver. The ioIntent parameter defines how the client interacts with this driver instance.</p>
<p class="p">The DRV_IO_INTENT_BLOCKING and DRV_IO_INTENT_NONBLOCKING ioIntent options are not relevant to this driver. All the data transfer functions of this driver are non blocking.</p>
<p class="p">Generic Codec can be opened with DRV_IO_INTENT_WRITE, or DRV_IO_INTENT_READ or DRV_IO_INTENT_WRITEREAD</p>
<p class="p">io_intent option. This decides whether the driver is used for headphone output, or microphone input or both modes simultaneously.</p>
<p class="p">Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client. The driver cannot be opened by any other client.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_GENERICCODEC_Initialize must have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11406"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11409"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11406 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11409 "><span>Identifier for the object instance to be opened</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11406 "><span>ioIntent</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11409 "><span>Zero or more of the values from the enumeration DRV_IO_INTENT "ORed" together to indicate the intended use of the driver. See function description for details.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, the routine returns a valid open-instance handle (a number identifying both the caller and the module instance).</p>
<p class="p">If an error occurs, the return value is DRV_HANDLE_INVALID. Error can occur</p>
<ul class="ul"><li class="li"><p class="p">if the number of client objects allocated via DRV_GENERICCODEC_CLIENTS_NUMBER is insufficient.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver but driver has been opened exclusively by another client.</p>
</li>
<li class="li"><p class="p">if the driver hardware instance being opened is not initialized or is invalid.</p>
</li>
<li class="li"><p class="p">if the ioIntent options passed are not relevant to this driver.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The handle returned is valid until the DRV_GENERICCODEC_Close routine is called. This routine will NEVER block waiting for hardware.If the requested intent flags are not supported, the routine will return DRV_HANDLE_INVALID. This function is thread safe in a RTOS application. It should not be called in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle;</p>
<p class="p">handle = DRV_GENERICCODEC_Open(DRV_GENERICCODEC_INDEX_0, DRV_IO_INTENT_WRITEREAD | DRV_IO_INTENT_EXCLUSIVE); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em> <em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_GENERICCODEC_Open</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">iDriver</strong>, <strong class="ph b">const</strong> DRV_IO_INTENT <strong class="ph b">ioIntent</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title199" id="drv-genericcodec-close-function"><h5 class="title topictitle5" id="ariaid-title199">DRV_GENERICCODEC_Close Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_Close( DRV_Handle handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Closes an opened-instance of the Generic Codec driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine closes an opened-instance of the Generic Codec driver, invalidating the handle. Any buffers in the driver queue that were submitted by this client will be removed. After calling this routine, the handle passed in "handle" must not be used with any of the remaining driver routines. A new handle must be obtained by calling DRV_GENERICCODEC_Open before the caller may use the driver again</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11522"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11525"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11522 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11525 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">• None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Usually there is no need for the driver client to verify that the Close operation has completed. The driver will abort any ongoing operations when this routine is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; <em class="ph i">// Returned from DRV_GENERICCODEC_Open</em></p>
<p class="p">DRV_GENERICCODEC_Close(handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_Close</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title200" id="drv-genericcodec-buffereventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title200">DRV_GENERICCODEC_BufferEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_BufferEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_GENERICCODEC_BUFFER_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished. When a client calls DRV_GENERICCODEC_BufferAddWrite function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "buffer add" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11613"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11616"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11613 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11616 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11613 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11616 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11613 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11616 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the queued buffer transfer has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_GENERICCODEC_BufferEventHandlerSet(myGENERICCODECHandle,</p>
<p class="p">DRV_GENERICCODECBufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_GENERICCODEC_BufferAddWrite(myGENERICCODEChandle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_GENERICCODEC_BUFFER_HANDLE_INVALID == bufferHandle) { <em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> DRV_GENERICCODECBufferEventHandler(DRV_GENERICCODEC_BUFFER_EVENT event, DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em></p>
<p class="p"><strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><strong class="ph b">break</strong>;</p>
<p class="p"><strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_BufferEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_GENERICCODEC_BUFFER_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title201" id="drv-genericcodec-commandeventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title201">DRV_GENERICCODEC_CommandEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_CommandEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_GENERICCODEC_COMMAND_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p">The event handler should be set before the client performs any "Generic Codec Specific Client Routines" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11787"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11790"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11787 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11790 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11787 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11790 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11787 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11790 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the command has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_GENERICCODEC_CommandEventHandlerSet(myGENERICCODECHandle,</p>
<p class="p">DRV_GENERICCODECCommandEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_GENERICCODEC_DeEmphasisFilterSet(myGENERICCODECHandle,</p>
<p class="p">DRV_GENERICCODEC_DEEMPHASIS_FILTER_44_1KHZ)</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em> <strong class="ph b">void</strong> DRV_GENERICCODECCommandEventHandler(uintptr_t contextHandle) { <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <em class="ph i">// Last Submitted command is completed.</em></p>
<p class="p"><em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_CommandEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_GENERICCODEC_COMMAND_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title202" id="data-transfer-functions-2"><h4 class="title topictitle4" id="ariaid-title202">Data Transfer Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title203" id="drv-genericcodec-bufferaddread-function"><h5 class="title topictitle5" id="ariaid-title203">DRV_GENERICCODEC_BufferAddRead Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_BufferAddRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking read operation. The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully. The function adds the request to the hardware instance receive queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_GENERICCODEC_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_GENERICCODEC_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec device instance and the DRV_GENERICCODEC_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle. DRV_IO_INTENT_READ must have been specified in the DRV_GENERICCODEC_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11957"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e11960"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11957 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11960 "><span>Handle of the Generic Codec instance as return by the DRV_GENERICCODEC_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11957 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11960 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11957 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11960 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11957 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e11960 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the Generic Codec Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another Generic Codec driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_BufferAddRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_GENERICCODEC_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title204" id="drv-genericcodec-bufferaddwrite-function"><h5 class="title topictitle5" id="ariaid-title204">DRV_GENERICCODEC_BufferAddWrite Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_BufferAddWrite</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write operation. The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully. The function adds the request to the hardware instance transmit queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_GENERICCODEC_BUFFER_HANDLE_INVALID:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_GENERICCODEC_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec device instance and the DRV_GENERICCODEC_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_WRITE must have been specified in the DRV_GENERICCODEC_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12088"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12091"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12088 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12091 "><span>Handle of the Generic Codec instance as return by the DRV_GENERICCODEC_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12088 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12091 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12088 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12091 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12088 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12091 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the Generic Codec Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another Generic Codec driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_GENERICCODEC_BufferEventHandlerSet(myGENERICCODECHandle,</p>
<p class="p">DRV_GENERICCODECBufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_GENERICCODEC_BufferAddWrite(myGENERICCODEChandle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_GENERICCODEC_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> DRV_GENERICCODECBufferEventHandler(DRV_GENERICCODEC_BUFFER_EVENT event, DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_BufferAddWrite</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_GENERICCODEC_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title205" id="drv-genericcodec-bufferaddwriteread-function"><h5 class="title topictitle5" id="ariaid-title205">DRV_GENERICCODEC_BufferAddWriteRead Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_BufferAddWriteRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *transmitBuffer, void *receiveBuffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write-read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write-read operation. The function returns with a valid buffer handle in the bufferHandle argument if the write-read request was scheduled successfully. The function adds the request to the hardware instance queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified.</p>
<p class="p">The function returns DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only or write only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_GENERICCODEC_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec device instance and the DRV_GENERICCODEC_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_READWRITE must have been specified in the DRV_GENERICCODEC_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12297"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12300"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12297 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12300 "><span>Handle of the Generic Codec instance as returned by the DRV_GENERICCODEC_Open function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12297 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12300 "><span>Pointer to an argument that will contain the return buffer handle</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12297 "><span>transmitBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12300 "><span>The buffer where the transmit data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12297 "><span>receiveBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12300 "><span>The buffer where the received data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12297 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12300 "><span>Buffer size in bytes</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be</p>
<p class="p">DRV_GENERICCODEC_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the Generic Codec Driver Buffer Event Handler that</p>
<p class="p">is registered by this client. It should not be called in the event handler associated with another Generic Codec driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p">This function is useful when there is valid read expected for every Generic Codec write. The transmit and receive size must be same.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj; uint8_t mybufferTx<span class="xref"></span>; uint8_t mybufferRx<span class="xref"></span>; DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// mygenericcodecHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_GENERICCODEC_BufferEventHandlerSet(mygenericcodecHandle,</p>
<p class="p">DRV_GENERICCODECBufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_GENERICCODEC_BufferAddWriteRead(mygenericcodecHandle, &amp;bufferHandle, mybufferTx,mybufferRx,MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_GENERICCODEC_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> DRV_GENERICCODECBufferEventHandler(DRV_GENERICCODEC_BUFFER_EVENT event, DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_BufferAddWriteRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_GENERICCODEC_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">transmitBuffer</strong>, <strong class="ph b">void</strong> * <strong class="ph b">receiveBuffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title206" id="drv-genericcodec-readqueuepurge-function"><h5 class="title topictitle5" id="ariaid-title206">DRV_GENERICCODEC_ReadQueuePurge Function</h5><div class="body"><p class="p">bool DRV_GENERICCODEC_ReadQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the read queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the read queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12485"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12488"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12485 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12488 "><span>Handle of the communication channel as returned by the DRV_GENERICCODEC_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Read queue purge is successful. False - Read queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_GENERICCODEC_BufferAddRead to queue read requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_GENERICCODEC_ReadQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the read queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_GENERICCODEC_ReadQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title207" id="drv-genericcodec-writequeuepurge-function"><h5 class="title topictitle5" id="ariaid-title207">DRV_GENERICCODEC_WriteQueuePurge Function</h5><div class="body"><p class="p">bool DRV_GENERICCODEC_WriteQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the write queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the write queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12592"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12595"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12592 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12595 "><span>Handle of the communication channel as returned by the DRV_GENERICCODEC_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Write queue purge is successful. False - Write queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_GENERICCODEC_BufferAddWrite to queue write requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_GENERICCODEC_WriteQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the write queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_GENERICCODEC_WriteQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title208" id="settings-functions-2"><h4 class="title topictitle4" id="ariaid-title208">Settings Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title209" id="drv-genericcodec-micgainget-function"><h5 class="title topictitle5" id="ariaid-title209">DRV_GENERICCODEC_MicGainGet Function</h5><div class="body"><p class="p">uint8_t DRV_GENERICCODEC_MicGainGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the microphone gain for the Generic Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current microphone gain programmed to the Generic Codec.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12705"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12708"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12705 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12708 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Microphone gain, in range 0-31.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t gain;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">gain = DRV_GENERICCODEC_MicGainGet(myGENERICCODECHandle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_GENERICCODEC_MicGainGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title210" id="drv-genericcodec-micgainset-function"><h5 class="title topictitle5" id="ariaid-title210">DRV_GENERICCODEC_MicGainSet Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_MicGainSet(DRV_HANDLE handle, uint8_t gain)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the microphone gain for the Generic Codec CODEC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the microphone gain value from 0-31</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12786"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12789"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12786 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12789 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12786 "><span>gain</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12789 "><span>Gain value, in range 0-31</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_MicGainSet(myGENERICCODECHandle, 15); <em class="ph i">//GENERICCODEC mic gain set to 15</em> <strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_MicGainSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint8_t <strong class="ph b">gain</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title211" id="drv-genericcodec-micmuteoff-function"><h5 class="title topictitle5" id="ariaid-title211">DRV_GENERICCODEC_MicMuteOff Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_MicMuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Umutes th Generic Codec's microphone input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function unmutes the Generic Codec's microphone input.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12874"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12877"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12874 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12877 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_MicMuteOff(myGENERICCODECHandle); <em class="ph i">//Generic Codec microphone unmuted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_MicMuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title212" id="drv-genericcodec-micmuteon-function"><h5 class="title topictitle5" id="ariaid-title212">DRV_GENERICCODEC_MicMuteOn Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_MicMuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Mutes the Generic Codec's microphone input</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function mutes the Generic Codec's microphone input</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12957"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e12960"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12957 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e12960 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_MicMuteOn(myGENERICCODECHandle); <em class="ph i">//Generic Codec microphone muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_MicMuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title213" id="drv-genericcodec-muteoff-function"><h5 class="title topictitle5" id="ariaid-title213">DRV_GENERICCODEC_MuteOff Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_MuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function disables Generic Codec output for soft mute.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function disables Generic Codec output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13039"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13042"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13039 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13042 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_MuteOff(myGENERICCODECHandle); <em class="ph i">//Generic Codec output soft mute disabled</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_MuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title214" id="drv-genericcodec-muteon-function"><h5 class="title topictitle5" id="ariaid-title214">DRV_GENERICCODEC_MuteOn Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_MuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows Generic Codec output for soft mute on.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function Enables Generic Codec output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13127"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13130"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13127 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13130 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_MuteOn(myGENERICCODECHandle); <em class="ph i">//GENERICCODEC output soft muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_MuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title215" id="drv-genericcodec-samplingrateget-function"><h5 class="title topictitle5" id="ariaid-title215">DRV_GENERICCODEC_SamplingRateGet Function</h5><div class="body"><p class="p">uint32_t DRV_GENERICCODEC_SamplingRateGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the sampling rate set on the Generic Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function gets the sampling rate set on the DAC Generic Codec.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13208"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13211"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13208 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13211 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint32_t baudRate;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">baudRate = DRV_GENERICCODEC_SamplingRateGet(myGENERICCODECHandle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_GENERICCODEC_SamplingRateGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title216" id="drv-genericcodec-samplingrateset-function"><h5 class="title topictitle5" id="ariaid-title216">DRV_GENERICCODEC_SamplingRateSet Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_SamplingRateSet(DRV_HANDLE handle, uint32_t samplingRate)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the sampling rate of the media stream.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the media sampling rate for the client handle.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13279"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13282"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13279 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13282 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13279 "><span>samplingRate</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13282 "><span>Sampling frequency in Hz</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_SamplingRateSet(myGENERICCODECHandle, 48000); <em class="ph i">//Sets 48000 media sampling rate</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_SamplingRateSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint32_t <strong class="ph b">samplingRate</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title217" id="drv-genericcodec-versionget-function"><h5 class="title topictitle5" id="ariaid-title217">DRV_GENERICCODEC_VersionGet Function</h5><div class="body"><p class="p">uint32_t DRV_GENERICCODEC_VersionGet( void )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of Generic Codec driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The version number returned from the DRV_GENERICCODEC_VersionGet function is an unsigned integer in the following decimal format. * 10000 + * 100 + Where the numbers are represented in decimal and the meaning is the same as above. Note that there is no numerical representation of release type.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns the version of Generic Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">For version "0.03a", return: 0 * 10000 + 3 * 100 + 0 For version "1.00", return: 1 * 100000 + 0 * 100 + 0</p>
<p class="p"><strong class="ph b">Example 2</strong> uint32_t GENERICCODECversion; GENERICCODECversion = DRV_GENERICCODEC_VersionGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_GENERICCODEC_VersionGet</strong>();</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title218" id="drv-genericcodec-versionstrget-function"><h5 class="title topictitle5" id="ariaid-title218">DRV_GENERICCODEC_VersionStrGet Function</h5><div class="body"><p class="p">int8_t* DRV_GENERICCODEC_VersionStrGet(void)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of Generic Codec driver in string format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The DRV_GENERICCODEC_VersionStrGet function returns a string in the format: ".<span class="xref"></span>" Where: is the Generic Codec driver's version number. is the Generic Codec driver's version number. is an optional "patch" or "dot" release number (which is not included in the string if it equals "00"). is an optional release type ("a" for alpha, "b" for beta ? not the entire word spelled out) that is not included if the release is a production version (I.e. Not an alpha or beta).</p>
<p class="p">The String does not contain any spaces. For example, "0.03a" "1.00"</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns a string containing the version of Generic Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int8_t *GENERICCODECstring; GENERICCODECstring = DRV_GENERICCODEC_VersionStrGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int8_t* <strong class="ph b">DRV_GENERICCODEC_VersionStrGet</strong>();</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title219" id="drv-genericcodec-volumeget-function"><h5 class="title topictitle5" id="ariaid-title219">DRV_GENERICCODEC_VolumeGet Function</h5><div class="body"><p class="p">uint8_t DRV_GENERICCODEC_VolumeGet(DRV_HANDLE handle, DRV_GENERICCODEC_CHANNEL channel)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the volume for Generic Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current volume programmed to the Generic Codec.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13465"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13468"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13465 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13468 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13465 "><span>channel</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13468 "><span>argument indicating Left or Right or Both channel volume to be modified</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t volume;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">volume = DRV_GENERICCODEC_VolumeGet(myGENERICCODECHandle, DRV_GENERICCODEC_CHANNEL_LEFT);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_GENERICCODEC_VolumeGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_GENERICCODEC_CHANNEL <strong class="ph b">channel</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title220" id="drv-genericcodec-volumeset-function"><h5 class="title topictitle5" id="ariaid-title220">DRV_GENERICCODEC_VolumeSet Function</h5><div class="body"><p class="p">void DRV_GENERICCODEC_VolumeSet(DRV_HANDLE handle, DRV_GENERICCODEC_CHANNEL channel, uint8_t volume);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the volume for Generic Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions sets the volume value from 0-255.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13551"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13554"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13551 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13554 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13551 "><span>channel</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13554 "><span>argument indicating Left or Right or Both channel volume to be modified</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13551 "><span>volume</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13554 "><span>volume value specified in the range 0-255 (0x00 to 0xFF)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned // by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_VolumeSet(myGENERICCODECHandle,DRV_GENERICCODEC_CHANNEL_LEFT, 120);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_GENERICCODEC_VolumeSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_GENERICCODEC_CHANNEL <strong class="ph b">channel</strong>, uint8_t <strong class="ph b">volume</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title221" id="other-functions-2"><h4 class="title topictitle4" id="ariaid-title221">Other Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title222" id="drv-genericcodec-geti2sdriver-function"><h5 class="title topictitle5" id="ariaid-title222">DRV_GENERICCODEC_GetI2SDriver Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_GENERICCODEC_GetI2SDriver(DRV_HANDLE codecHandle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the handle to the I2S driver for this codec instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Returns the appropriate handle to the I2S based on the ioIent member of the codec object.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_GENERICCODEC_Initialize routine must have been called for the specified Generic Codec driver instance.</p>
<p class="p">DRV_GENERICCODEC_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13656"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13659"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13656 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13659 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<ul class="ul"><li class="li"><p class="p">A handle to the I2S driver for this codec instance</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This allows the caller to directly access portions of the I2S driver that might not be available via the codec API.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_GENERICCODEC_GetI2SDriver</strong>(DRV_HANDLE <strong class="ph b">codecHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title223" id="drv-genericcodec-lrclk-sync-function"><h5 class="title topictitle5" id="ariaid-title223">DRV_GENERICCODEC_LRCLK_Sync Function</h5><div class="body"><p class="p">uint32_t DRV_GENERICCODEC_LRCLK_Sync (const DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Synchronize to the start of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function waits until low-to high transition of the I2S LRCLK (left/right clock) signal (high-low if Left-Justified format, this is determined by the PLIB). In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize calls to the DMA with the LRCLK signal so the left/right channel association is valid.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13722"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13725"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13722 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13725 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myGENERICCODECHandle is the handle returned</em> <em class="ph i">// by the DRV_GENERICCODEC_Open function.</em></p>
<p class="p">DRV_GENERICCODEC_LRCLK_Sync(myGENERICCODECHandle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_GENERICCODEC_LRCLK_Sync</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
<p class="p"><strong class="ph b">Dara Types and Constants</strong></p>
</div>
</div>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title224" id="drv-genericcodec-buffer-event-type"><h2 class="title topictitle2" id="ariaid-title224"><em class="ph i">DRV_GENERICCODEC_BUFFER_EVENT Type</em></h2><div class="body"><p class="p">Identifies the possible events that can result from a buffer add request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Events</p>
<p class="p">This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_GENERICCODEC_BufferAddWrite() or the DRV_GENERICCODEC_BufferAddRead() function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">One of these values is passed in the "event" parameter of the event handling callback function that the client registered with the driver by calling the DRV_GENERICCODEC_BufferEventHandlerSet function when a buffer transfer request is completed.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_GENERICCODEC_BUFFER_EVENT@1 <strong class="ph b">DRV_GENERICCODEC_BUFFER_EVENT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title225" id="drv-genericcodec-buffer-event-handler-type"><h2 class="title topictitle2" id="ariaid-title225"><em class="ph i">DRV_GENERICCODEC_BUFFER_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a Generic Codec Driver Buffer Event handler function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Buffer Event Handler Function</p>
<p class="p">This data type defines the required function signature for the Generic Codec driver buffer event handling callback function. A client must register a pointer to a buffer event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13832"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e13835"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13832 "><span>event</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13835 "><span>Identifies the type of event</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13832 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13835 "><span>Handle identifying the buffer to which the event relates</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13832 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e13835 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the event is DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE, this means that the data was transferred successfully.</p>
<p class="p">If the event is DRV_GENERICCODEC_BUFFER_EVENT_ERROR, this means that the data was not transferred successfully.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that failed. The</p>
<p class="p">DRV_GENERICCODEC_BufferProcessedSizeGet() function can be called to find out how many bytes were processed.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that associated with the event.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_GENERICCODEC_BufferEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The buffer handle in bufferHandle expires after this event handler exits. In that the buffer object that was allocated is deallocated by the driver after the event handler exits.</p>
<p class="p">The event handler function executes in the data driver(i2S) peripheral's interrupt context when the driver is configured for interrupt mode operation. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p">DRV_GENERICCODEC_BufferAddWrite function can be called in the event handler to add a buffer to the driver queue.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> DRV_GENERICCODECBufferEventHandler( DRV_GENERICCODEC_BUFFER_EVENT event, DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle, uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_COMPLETE: <em class="ph i">// Handle the completed buffer.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_GENERICCODEC_BUFFER_EVENT_ERROR: <strong class="ph b">default</strong>: <em class="ph i">// Handle error.</em> <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_GENERICCODEC_BUFFER_EVENT_HANDLER</strong>)(DRV_GENERICCODEC_BUFFER_EVENT event, DRV_GENERICCODEC_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title226" id="drv-genericcodec-buffer-handle-type"><h2 class="title topictitle2" id="ariaid-title226"><em class="ph i">DRV_GENERICCODEC_BUFFER_HANDLE Type</em></h2><div class="body"><p class="p">Handle identifying a write buffer passed to the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Buffer Handle</p>
<p class="p">A buffer handle value is returned by a call to the DRV_GENERICCODEC_BufferAddWrite() or</p>
<p class="p">DRV_GENERICCODEC_BufferAddRead() function. This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer.</p>
<p class="p">The buffer handle value returned from the "buffer add" function is returned back to the client by the "event handler callback" function registered with the driver.</p>
<p class="p">The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> uintptr_t <strong class="ph b">DRV_GENERICCODEC_BUFFER_HANDLE</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title227" id="drv-genericcodec-channel-type"><h2 class="title topictitle2" id="ariaid-title227"><em class="ph i">DRV_GENERICCODEC_CHANNEL Type</em></h2><div class="body"><p class="p">Identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Audio Channel</p>
<p class="p">This enumeration identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_GENERICCODEC_CHANNEL@1 <strong class="ph b">DRV_GENERICCODEC_CHANNEL</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title228" id="drv-genericcodec-command-event-handler-type"><h2 class="title topictitle2" id="ariaid-title228"><em class="ph i">DRV_GENERICCODEC_COMMAND_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a Generic Codec Driver Command Event Handler Function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Command Event Handler Function</p>
<p class="p">This data type defines the required function signature for the Generic Codec driver command event handling callback function.</p>
<p class="p">A command is a control instruction to the Generic Codec. Example Mute ON/OFF, Zero Detect Enable/Disable etc.</p>
<p class="p">A client must register a pointer to a command event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive command related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14027"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14030"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14027 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14030 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The occurrence of this call back means that the last control command was transferred successfully.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_GENERICCODEC_CommandEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The event handler function executes in the control data driver interrupt context. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> DRV_GENERICCODECCommandEventHandler( uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context;</p>
<p class="p"><em class="ph i">// Last Submitted command is completed.</em></p>
<p class="p"><em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_GENERICCODEC_COMMAND_EVENT_HANDLER</strong>)(uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title229" id="drv-genericcodec-init-type"><h2 class="title topictitle2" id="ariaid-title229"><em class="ph i">DRV_GENERICCODEC_INIT Type</em></h2><div class="body"><p class="p">Defines the data required to initialize or reinitialize the Generic Codec driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Initialization Data</p>
<p class="p">This data type defines the data required to initialize or reinitialize the Generic Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">struct</strong> DRV_GENERICCODEC_INIT@1 <strong class="ph b">DRV_GENERICCODEC_INIT</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title230" id="drv-genericcodec-buffer-handle-invalid-macro"><h2 class="title topictitle2" id="ariaid-title230"><em class="ph i">DRV_GENERICCODEC_BUFFER_HANDLE_INVALID Macro</em></h2><div class="body"><p class="p">Definition of an invalid buffer handle.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Invalid Buffer Handle</p>
<p class="p">This is the definition of an invalid buffer handle. An invalid buffer handle is returned by DRV_GENERICCODEC_BufferAddWrite() and the DRV_GENERICCODEC_BufferAddRead() function if the buffer add request was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_BUFFER_HANDLE_INVALID</strong> ((DRV_GENERICCODEC_BUFFER_HANDLE)(-1))</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title231" id="drv-genericcodec-count-macro"><h2 class="title topictitle2" id="ariaid-title231"><em class="ph i">DRV_GENERICCODEC_COUNT Macro</em></h2><div class="body"><p class="p">Number of valid Generic Codec driver indices</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Module Count</p>
<p class="p">This constant identifies the maximum number of Generic Codec Driver instances that should be defined by the application. Defining more instances than this constant will waste RAM memory space.</p>
<p class="p">This constant can also be used by the application to identify the number of Generic Codec instances on this microcontroller.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This value is part-specific.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_COUNT</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title232" id="drv-genericcodec-index-0-macro"><h3 class="title topictitle3" id="ariaid-title232">DRV_GENERICCODEC_INDEX_0 Macro</h3><div class="body"><p class="p">Generic Codec driver index definitions</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Driver Generic Codec Module Index</p>
<p class="p">These constants provide Generic Codec driver index definition.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">These constants should be used in place of hard-coded numeric literals. These values should be passed into the DRV_GENERICCODEC_Initialize and DRV_GENERICCODEC_Open routines to identify the driver instance in use.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_0</strong> 0</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title233" id="drv-genericcodec-index-1-macro"><h2 class="title topictitle2" id="ariaid-title233"><em class="ph i">DRV_GENERICCODEC_INDEX_1 Macro</em></h2><div class="body"><p class="p">This is macro DRV_GENERICCODEC_INDEX_1.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_1</strong> 1</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title234" id="drv-genericcodec-index-2-macro"><h2 class="title topictitle2" id="ariaid-title234"><em class="ph i">DRV_GENERICCODEC_INDEX_2 Macro</em></h2><div class="body"><p class="p">This is macro DRV_GENERICCODEC_INDEX_2.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_2</strong> 2</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title235" id="drv-genericcodec-index-3-macro"><h2 class="title topictitle2" id="ariaid-title235"><em class="ph i">DRV_GENERICCODEC_INDEX_3 Macro</em></h2><div class="body"><p class="p">This is macro DRV_GENERICCODEC_INDEX_3.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_3</strong> 3</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title236" id="drv-genericcodec-index-4-macro"><h2 class="title topictitle2" id="ariaid-title236"><em class="ph i">DRV_GENERICCODEC_INDEX_4 Macro</em></h2><div class="body"><p class="p">This is macro DRV_GENERICCODEC_INDEX_4.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_4</strong> 4</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title237" id="drv-genericcodec-index-5-macro"><h2 class="title topictitle2" id="ariaid-title237"><em class="ph i">DRV_GENERICCODEC_INDEX_5 Macro</em></h2><div class="body"><p class="p">This is macro DRV_GENERICCODEC_INDEX_5.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_GENERICCODEC_INDEX_5</strong> 5</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title238" id="drv-genericcodec-audio-data-format-type"><h3 class="title topictitle3" id="ariaid-title238">DRV_GENERICCODEC_AUDIO_DATA_FORMAT Type</h3><div class="body"><p class="p">Identifies the Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Audio data format</p>
<p class="p">This enumeration identifies Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DRV_GENERICCODEC_AUDIO_DATA_FORMAT@1 <strong class="ph b">DRV_GENERICCODEC_AUDIO_DATA_FORMAT</strong>;</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title239" id="files-1"><h3 class="title topictitle3" id="ariaid-title239">Files</h3><div class="body"><p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14329"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14332"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14329 "><span>drv_genericcodec.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14332 "><span>Generic Codec Driver Interface header file</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14329 "><span>drv_genericcodec_config_template.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14332 "><span>Generic Codec Driver Configuration Template.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title240" id="drv-genericcodech"><h3 class="title topictitle3" id="ariaid-title240">drv_genericcodec.h</h3><div class="body"><p class="p">drv_genericcodec.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Generic Codec Driver Interface header file</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Interface</p>
<p class="p">The Generic Codec device driver interface provides a simple interface to manage a codec that can be interfaced to a Microchip microcontroller. This file provides the public interface definitions for the Generic Codec device driver.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title241" id="drv-genericcodec-config-templateh"><h3 class="title topictitle3" id="ariaid-title241">drv_genericcodec_config_template.h</h3><div class="body"><p class="p">drv_genericcodec_config_template.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Generic Codec Driver Configuration Template.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Generic Codec Driver Configuration Template</p>
<p class="p">These file provides the list of all the configurations that can be used with the driver. This file should not be included in the driver.</p>
<p class="p"><strong class="ph b">WM8904 CODEC Driver Library Help</strong></p>
<p class="p">This topic describes the WM8904 Codec Driver Library.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title242" id="introduction-3"><h2 class="title topictitle2" id="ariaid-title242"><em class="ph i">Introduction</em></h2><div class="body"><p class="p">This library provides an Applications Programming Interface (API) to manage the WM8904 Codec that is serially interfaced to the I2C and I2S peripherals of a Microchip microcontroller for the purpose of providing audio solutions.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The WM8904 module is 24-bit Audio Codec from Cirrus Logic, which can operate in 16-, 20-, 24-, and 32-bit audio modes. The WM8904 can be interfaced to Microchip microcontrollers through I2C and I2S serial interfaces. The I2C interface is used to send commands and receive status, and the I2S interface is used for audio data output (to headphones or line-out) and input (from microphone or line-in).</p>
<p class="p">The WM8904 can be configured as either an I2S clock slave (receives all clocks from the host), or I2S clock master (generates I2S clocks from a master clock input MCLK). Currently the driver only supports master mode with headphone output and (optionally) microphone input.</p>
<p class="p">A typical interface of WM8904 to a Microchip microcontroller using an I2C and SSC interface (configured as I2S), with the WM8904 set up as the I2S clock master, is provided in the following diagram:
<img class="image" src="GUID-2299F263-3B83-46C3-8B94-8535A4E6B104-low.png" /><br /></p>
<p class="p">The WM8904 Codec supports the following features:</p>
<ul class="ul"><li class="li"><p class="p">Audio Interface Format: 16-/20-/24-/32-bit interface, LSB justified or I2S format (only 16 and 32-bit interfaces supported in the driver)</p>
</li>
<li class="li"><p class="p">Sampling Frequency Range: 8 kHz to 96 kHz</p>
</li>
<li class="li"><p class="p">Digital Volume Control: -71.625 to 0 dB in 192 steps (converted to a linear scale 0-255 in the driver)</p>
</li>
<li class="li"><p class="p">Soft mute capability</p>
</li>
</ul>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title243" id="using-the-library-1"><h2 class="title topictitle2" id="ariaid-title243"><em class="ph i">Using the Library</em></h2><div class="body"><p class="p">This topic describes the basic architecture of the WM8904 Codec Driver Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title244" id="interface-header-file-drv-wm8904h"><h3 class="title topictitle3" id="ariaid-title244">Interface Header File: drv_WM8904.h</h3><div class="body"><p class="p">The interface to the WM8904 Codec Driver library is defined in the audio/driver/codec/WM8904/drv_WM8904.h header file.</p>
<p class="p">Any C language source (.c) file that uses the WM8904 Codec Driver library should include this header.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The WM8904 Codec Driver library source files are provided in the audio/driver/codec/WM8904/src directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features and to <strong class="ph b">Building the Library</strong> for instructions on how to build the library.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/audio_tone_linkeddma</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title245" id="abstraction-model-2"><h2 class="title topictitle2" id="ariaid-title245">Abstraction Model</h2><div class="body"><p class="p">This library provides a low-level abstraction of the WM8904 Codec Driver Library on the Microchip family microcontrollers with a convenient C language interface. This topic describes how that abstraction is modeled in software and introduces the library's interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The abstraction model shown in the following diagram depicts how the WM8904 Codec Driver is positioned in the MPLAB Harmony framework. The WM8904 Codec Driver uses the I2C and I2S drivers for control and audio data transfers to the WM8904 module.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title246" id="wm8904-driver-abstraction-model"><h3 class="title topictitle3" id="ariaid-title246">WM8904 Driver Abstraction Model</h3><div class="body"><br /><img class="image" src="GUID-FB7447CC-3095-4365-B789-3FF239D5A9CF-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title247" id="library-overview-3"><h2 class="title topictitle2" id="ariaid-title247">Library Overview</h2><div class="body"><p class="p">Refer to the Driver Library Overview section for information on how the driver operates in a system.</p>
<p class="p">The WM8904 Codec Driver Library provides an API interface to transfer control commands and digital audio data to the serially interfaced WM8904 Codec module. The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the WM8904 Codec Driver Library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14497"><span><strong class="ph b">Library Interface Section</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14500"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>System Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>Provides system module interfaces, device initialization, deinitialization, reinitialization, tasks and status functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>Client Setup Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>Provides open and close functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>Data Transfer Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>Provides data transfer functions, such as Buffer Read and Write.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>Settings Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>Provides driver specific functions for settings, such as volume control and sampling rate.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>Other Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>Miscellaneous functions, such as getting the driver’s version number and syncing to the LRCLK signal.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14497 "><span>Data Types and Constants</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14500 "><span>These data types and constants are required while interacting and setting up the WM8904 Codec Driver Library.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> All functions and constants in this section are named with the format DRV_ WM8904_xxx, where 'xxx' is a function name or constant. These names are redefined in the appropriate configuration’s configuration.h file to the format DRV_CODEC_xxx using #defines so that code in the application that references the library can be written as generically as possible (e.g., by writing DRV_CODEC_Open instead of DRV_ WM8904_Open etc.). This allows the codec type to be changed in the MHC without having to modify the application’s source code.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title248" id="how-the-library-works-3"><h2 class="title topictitle2" id="ariaid-title248">How the Library Works</h2><div class="body"><p class="p">How the Library Works</p>
<p class="p">The library provides interfaces to support:</p>
<ul class="ul"><li class="li"><p class="p">System Functionality</p>
</li>
<li class="li"><p class="p">Client Functionality</p>
</li>
</ul>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title249" id="setup-initialization-3"><h3 class="title topictitle3" id="ariaid-title249">Setup (Initialization)</h3><div class="body"><p class="p">This topic describes system initialization, implementations, and includes a system access code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title250" id="system-initialization-2"><h2 class="title topictitle2" id="ariaid-title250">System Initialization</h2><div class="body"><p class="p">The system performs the initialization of the device driver with settings that affect only the instance of the device that is being initialized. During system initialization in the system_init.c file, each instance of the WM8904 module would be initialized with the following configuration settings (either passed dynamically at run time using DRV_WM8904_INIT or by using Initialization Overrides) that are supported by the specific WM8904 device hardware:</p>
<ul class="ul"><li class="li"><p class="p">Device requested power state: one of the System Module Power States. For specific details please refer to Data Types and Constants in the Library Interface section.</p>
</li>
<li class="li"><p class="p">I2C driver module index. The module index should be same as the one used in initializing the I2C Driver</p>
</li>
<li class="li"><p class="p">I2S driver module index. The module index should be same as the one used in initializing the I2S Driver</p>
</li>
<li class="li"><p class="p">Sampling rate</p>
</li>
<li class="li"><p class="p">Volume</p>
</li>
<li class="li"><p class="p">Audio data format. The audio data format should match with the audio data format settings done in I2S driver initialization</p>
</li>
<li class="li"><p class="p">Determines whether or not the microphone input is enabled</p>
</li>
</ul>
<p class="p">The DRV_WM8904_Initialize API returns an object handle of the type SYS_MODULE_OBJ. The object handle returned by the Initialize interface would be used by the other system interfaces such as DRV_ WM8904_Deinitialize, DRV_ WM8904_Status and DRV_I2S_Tasks.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title251" id="client-access-3"><h3 class="title topictitle3" id="ariaid-title251">Client Access</h3><div class="body"><p class="p">This topic describes driver initialization and provides a code example.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">For the application to start using an instance of the module, it must call the DRV_WM8904_Open function. The</p>
<p class="p">DRV_WM8904_Open function provides a driver handle to the WM8904 Codec Driver instance for operations. If the driver is deinitialized using the function DRV_WM8904_Deinitialize, the application must call the DRV_WM8904_Open function again to set up the instance of the driver.</p>
<p class="p">For the various options available for IO_INTENT, please refer to Data Types and Constants in the Library Interface section.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is necessary to check the status of driver initialization before opening a driver instance. The status of the WM8904 Codec Driver can be known by calling DRV_ WM8904_Status.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_HANDLE handle; SYS_STATUS wm8904Status;</p>
<p class="p">wm8904Status Status = DRV_WM8904_Status(sysObjects.wm8904Status DevObject); if (SYS_STATUS_READY == wm8904Status) { // The driver can now be opened. appData.wm8904Client.handle = DRV_WM8904_Open</p>
<p class="p">( DRV_WM8904_INDEX_0, DRV_IO_INTENT_WRITE | DRV_IO_INTENT_EXCLUSIVE); if(appData.wm8904Client.handle != DRV_HANDLE_INVALID) {</p>
<p class="p">appData.state = APP_STATE_WM8904_SET_BUFFER_HANDLER; } else { SYS_DEBUG(0, "Find out what's wrong \r\n");</p>
<p class="p">} } else { /* WM8904 Driver Is not ready */</p>
<p class="p">}</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title252" id="client-operations-3"><h3 class="title topictitle3" id="ariaid-title252">Client Operations</h3><div class="body"><p class="p">This topic provides information on client operations.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Client operations provide the API interface for control command and audio data transfer to the WM8904 Codec.</p>
<p class="p">The following WM8904 Codec specific control command functions are provided:</p>
<ul class="ul"><li class="li"><p class="p">DRV_WM8904_SamplingRateSet</p>
</li>
<li class="li"><p class="p">DRV_WM8904_SamplingRateGet</p>
</li>
<li class="li"><p class="p">DRV_WM8904_VolumeSet</p>
</li>
<li class="li"><p class="p">DRV_WM8904_VolumeGet</p>
</li>
<li class="li"><p class="p">DRV_WM8904_MuteOn</p>
</li>
<li class="li"><p class="p">DRV_WM8904_MuteOff</p>
</li>
</ul>
<p class="p">These functions schedule a non-blocking control command transfer operation. These functions submit the control command request to the WM8904 Codec. These functions submit the control command request to I2C Driver transmit queue, the request is processed immediately if it is the first request, or processed when the previous request is complete.</p>
<p class="p">DRV_WM8904_BufferAddWrite, DRV_WM8904_BufferAddRead, and DRV_WM8904_BufferAddWriteRead are buffered data operation functions. These functions schedule non-blocking audio data transfer operations. These functions add the request to I2S Driver transmit or receive buffer queue depends on the request type, and are executed immediately if it is the first buffer, or executed later when the previous buffer is complete. The driver notifies the client with</p>
<p class="p">DRV_WM8904_BUFFER_EVENT_COMPLETE, DRV_WM8904_BUFFER_EVENT_ERROR, or DRV_WM8904_BUFFER_EVENT_ABORT events.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is not necessary to close and reopen the client between multiple transfers.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title253" id="configuring-the-library-3"><h3 class="title topictitle3" id="ariaid-title253">Configuring the Library</h3><div class="body"><p class="p">The configuration of the I2S Driver Library is based on the file configurations.h, as generated by the MHC.</p>
<p class="p">This header file contains the configuration selection for the I2S Driver Library. Based on the selections made, the I2S Driver Library may support the selected features. These configuration settings will apply to all instances of the I2S Driver Library.</p>
<p class="p">This header can be placed anywhere; however, the path of this header needs to be present in the include search path for a successful build. Refer to the Applications Help section for more details.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title254" id="system-configuration-3"><h3 class="title topictitle3" id="ariaid-title254">System Configuration</h3><div class="body"><p class="p"><strong class="ph b">Macros</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14699"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14701"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e14704"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_AUDIO_DATA_FORMAT_MACRO</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies the audio data format for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_AUDIO_SAMPLING_RATE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies the initial baud rate for the codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_CLIENTS_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Sets up the maximum number of clients that can be connected to any hardware instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_ENABLE_MIC_BIAS</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies whether to enable the microphone bias.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_ENABLE_MIC_INPUT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies whether to enable the microphone input.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_I2C_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies the instance number of the I2C interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_I2S_DRIVER_MODULE_INDEX_IDXx</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies the instance number of the I2S interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_INSTANCES_NUMBER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Sets up the maximum number of hardware instances that can be supported</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_MASTER_MODE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies if codec is in Master or Slave mode.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14699 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14701 "><span>DRV_WM8904_VOLUME</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e14704 "><span>Specifies the initial volume level.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title255" id="drv-wm8904-audio-data-format-macro-macro"><h2 class="title topictitle2" id="ariaid-title255"><em class="ph i">DRV_WM8904_AUDIO_DATA_FORMAT_MACRO Macro</em></h2><div class="body"><p class="p">Specifies the audio data format for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Audio Data Format</p>
<p class="p">Sets up the length of each sample plus the format (I2S or left-justified) for the audio.</p>
<p class="p">Valid choices are: "DATA_16_BIT_LEFT_JUSTIFIED" "DATA_16_BIT_I2S" "DATA_32_BIT_LEFT_JUSTIFIED" "DATA_32_BIT_I2S"</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If 24-bit audio is needed, it should be sent, left-justified, in a 32-bit format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_AUDIO_DATA_FORMAT_MACRO</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title256" id="drv-wm8904-audio-sampling-rate-macro"><h2 class="title topictitle2" id="ariaid-title256"><em class="ph i">DRV_WM8904_AUDIO_SAMPLING_RATE Macro</em></h2><div class="body"><p class="p">Specifies the initial baud rate for the codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Baud Rate</p>
<p class="p">Sets the initial baud rate (sampling rate) for the codec. Typical values are 8000, 16000, 44100, 48000, 88200 and 96000.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_AUDIO_SAMPLING_RATE</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title257" id="drv-wm8904-clients-number-macro"><h2 class="title topictitle2" id="ariaid-title257"><em class="ph i">DRV_WM8904_CLIENTS_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of clients that can be connected to any hardware instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Client Count Configuration</p>
<p class="p">Sets up the maximum number of clients that can be connected to any hardware instance. Typically only one client could be connected to one hardware instance. This value represents the total number of clients to be supported across all hardware instances.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_CLIENTS_NUMBER</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title258" id="drv-wm8904-enable-mic-bias-macro"><h2 class="title topictitle2" id="ariaid-title258"><em class="ph i">DRV_WM8904_ENABLE_MIC_BIAS Macro</em></h2><div class="body"><p class="p">Specifies whether to enable the microphone bias.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Microphone Enable</p>
<p class="p">Indicates whether the bias voltage needed for electret microphones should be enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_ENABLE_MIC_BIAS</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title259" id="drv-wm8904-enable-mic-input-macro"><h2 class="title topictitle2" id="ariaid-title259"><em class="ph i">DRV_WM8904_ENABLE_MIC_INPUT Macro</em></h2><div class="body"><p class="p">Specifies whether to enable the microphone input.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Microphone Enable</p>
<p class="p">Indicates whether the ADC inputs for the two microphone channels (L-R) should be enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_ENABLE_MIC_INPUT</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title260" id="drv-wm8904-i2c-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title260"><em class="ph i">DRV_WM8904_I2C_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2C interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 I2C instance number</p>
<p class="p">Specifies the instance number of the I2C interface being used by the MCU to send commands and receive status to and from the WM8904. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_I2C_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title261" id="drv-wm8904-i2s-driver-module-index-idxx-macro"><h2 class="title topictitle2" id="ariaid-title261"><em class="ph i">DRV_WM8904_I2S_DRIVER_MODULE_INDEX_IDXx Macro</em></h2><div class="body"><p class="p">Specifies the instance number of the I2S interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 I2S instance number</p>
<p class="p">Specifies the instance number of the I2S interface being used by the MCU to send and receive audio data to and from the WM8904. enabled.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_I2S_DRIVER_MODULE_INDEX_IDXx</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title262" id="drv-wm8904-instances-number-macro"><h2 class="title topictitle2" id="ariaid-title262"><em class="ph i">DRV_WM8904_INSTANCES_NUMBER Macro</em></h2><div class="body"><p class="p">Sets up the maximum number of hardware instances that can be supported</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 driver objects configuration</p>
<p class="p">Sets up the maximum number of hardware instances that can be supported. It is recommended that this number be set exactly equal to the number of WM8904 Codec modules that are needed by an application, namely one.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_INSTANCES_NUMBER</strong></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title263" id="drv-wm8904-master-mode-macro"><h3 class="title topictitle3" id="ariaid-title263">DRV_WM8904_MASTER_MODE Macro</h3><div class="body"><p class="p">Specifies if codec is in Master or Slave mode.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Codec Master/Slave Mode</p>
<p class="p">Indicates whether the codec is to be operating in a Master mode (generating word and bit clock as outputs) or Slave mode receiving word and bit clock as inputs).</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_MASTER_MODE</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title264" id="drv-wm8904-volume-macro"><h3 class="title topictitle3" id="ariaid-title264">DRV_WM8904_VOLUME Macro</h3><div class="body"><p class="p">Specifies the initial volume level.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Volume</p>
<p class="p">Sets the initial volume level, in the range 0-255.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The value is mapped to an internal WM8904 volume level in the range 0-192 using a logarithmic table so the input scale appears linear (128 is half volume).</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_VOLUME</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title265" id="configuring-mhc-2"><h3 class="title topictitle3" id="ariaid-title265">Configuring MHC</h3><div class="body"><p class="p">Provides examples on how to configure the MPLAB Harmony Configurator (MHC) for a specific driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When building a new application, start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <em class="ph i">File &gt; New Project</em>. Chose the Configuration name the based on the BSP, and select the appropriate processor (such as ATSAME70Q21B).</p>
<p class="p">In the MHC, under Available Components select the appropriate BSP, such as SAM E70 Xplained Ultra. Under <em class="ph i">Audio&gt;Templates</em>, double-click on a codec template such as WM8904. Answer Yes to all questions.</p>
<p class="p">You should end up with a project graph that looks like this, after rearranging the boxes:
<img class="image" src="GUID-FDF866A7-5FBB-4DA9-AA7E-5F6135618110-low.png" /><br /></p>
<p class="p">Click on the WM8904 Driver component (not WM8904 Codec) and the following menu will be displayed in the Configurations Options:
<img class="image" src="GUID-940559E6-52E1-49CF-BE6D-284BA3AE560C-low.png" /><br /></p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">I2C Driver Used</strong> will display the driver instance used for the I2C interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">I2S Driver Used</strong> will display the driver instance used for the I2S interface.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Usage Mode</strong> indicates whether the WM8904 is a Master (supplies I2S clocks) or a Slave (MCU supplies I2S clocks).</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Number of WM8904 Clients</strong> indicates the maximum number of clients that can be connected to the WM8904 Driver.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Sampling Rate</strong> indicates the number of samples per second per channel, 8000 to 96,000.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Volume</strong> indicates the volume in a linear scale from 0-255.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Audio Data Format</strong> is either 16-bit Left Justified, 16-bit I2S, 32-bit Left Justified, or 32-bit I2S. It must match the audio protocol and data length set up in either the SSC or I2S PLIB.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Sampling Rate</strong> indicates the number of samples per second per channel, 8000 to 96,000.</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Enable Microphone Input</strong> should be checked a microphone is being used. If checked, another option,</p>
</li>
<li class="li"><p class="p"><strong class="ph b">Enable Microphone Bias</strong> should be checked if using an electret microphone.</p>
</li>
</ul>
<p class="p">You can also bring in the WM8904 Driver by itself, by double clicking WM8904 under Audio_-&gt;Driver-&gt;Codec_ in the Available Components list. You will then need to add any additional needed components manually and connect them together.</p>
<p class="p">Note that the WM8904 requires the TCx Peripheral Library and TIME System Service in order to perform some of its internal timing sequences.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title266" id="building-the-library-2"><h3 class="title topictitle3" id="ariaid-title266">Building the Library</h3><div class="body"><p class="p">This section lists the files that are available in the WM8904 Codec Driver Library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section lists the files that are available in the src folder of the WM8904 Codec Driver. It lists which files need to be included in the build based on either a hardware feature present on the board or configuration option selected by the system.</p>
<p class="p">The following three tables list and describe the header (.h) and source (.c) files that implement this library. The parent folder for these files is audio/driver/codec/WM8904.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title267" id="interface-files-2"><h3 class="title topictitle3" id="ariaid-title267">Interface File(s)</h3><div class="body"><p class="p">This table lists and describes the header files that must be included (i.e., using #include) by any code that uses this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15126"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15129"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15126 "><span>drv_wm8904.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15129 "><span>Header file that exports the driver API.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title268" id="required-files-3"><h3 class="title topictitle3" id="ariaid-title268">Required File(s)</h3><div class="body"><p class="p"><img class="image" src="GUID-B924D07A-0D74-453B-BCDE-8190A195C55D-low.png" /><br /> <strong class="ph b"><em class="ph i">All of the required files listed in the following table are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use.</em></strong></p>
<p class="p">This table lists and describes the source and header files that must <em class="ph i">always</em> be included in the MPLAB X IDE project to build this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15159"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15162"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15159 "><span>/src/drv_wm8904.c</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15162 "><span>This file contains implementation of the WM8904 Codec Driver.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title269" id="optional-files-3"><h3 class="title topictitle3" id="ariaid-title269">Optional File(s)</h3><div class="body"><p class="p">This table lists and describes the source and header files that may optionally be included if required for the desired implementation.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15183"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15186"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15183 "><span>N/A</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15186 "><span>No optional files are available for this library.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title270" id="module-dependencies-3"><h3 class="title topictitle3" id="ariaid-title270">Module Dependencies</h3><div class="body"><p class="p">The WM8904 Codec Driver Library depends on the following modules:</p>
<ul class="ul"><li class="li"><p class="p">I2S Driver Library</p>
</li>
<li class="li"><p class="p">I2C Driver Library</p>
</li>
</ul>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title271" id="library-interface-3"><h4 class="title topictitle4" id="ariaid-title271"><em class="ph i">Library Interface</em></h4><div class="body"><p class="p"><strong class="ph b">Client Setup Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15223"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15225"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15228"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15223 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15225 "><span>DRV_WM8904_Open</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15228 "><span>Opens the specified WM8904 driver instance and returns a handle to it</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15223 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15225 "><span>DRV_WM8904_Close</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15228 "><span>Closes an opened-instance of the WM8904 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15223 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15225 "><span>DRV_WM8904_BufferEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15228 "><span>This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15223 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15225 "><span>DRV_WM8904_CommandEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15228 "><span>This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Transfer Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15270"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15272"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15275"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15272 "><span>DRV_WM8904_BufferAddRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15275 "><span>Schedule a non-blocking driver read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15272 "><span>DRV_WM8904_BufferAddWrite</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15275 "><span>Schedule a non-blocking driver write operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15272 "><span>DRV_WM8904_BufferAddWriteRead</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15275 "><span>Schedule a non-blocking driver write-read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15272 "><span>DRV_WM8904_ReadQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15275 "><span>Removes all buffer requests from the read queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15272 "><span>DRV_WM8904_WriteQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15275 "><span>Removes all buffer requests from the write queue.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Data Types and Constants</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15324"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15326"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15329"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DATA_LENGTH</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>in bits</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_AUDIO_DATA_FORMAT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Identifies the Serial Audio data interface format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_BUFFER_EVENT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Identifies the possible events that can result from a buffer add request.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_BUFFER_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Pointer to a WM8904 Driver Buffer Event handler function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_BUFFER_HANDLE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Handle identifying a write buffer passed to the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_CHANNEL</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Identifies Left/Right Audio channel</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_COMMAND_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Pointer to a WM8904 Driver Command Event Handler Function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_INIT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Defines the data required to initialize or reinitialize the WM8904 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_BUFFER_HANDLE_INVALID</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Definition of an invalid buffer handle.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_COUNT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>Number of valid WM8904 driver indices</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_WM8904_INDEX_0</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>WM8904 driver index definitions</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15324 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15326 "><span>DRV_I2C_INDEX</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15329 "><span>This is macro DRV_I2C_INDEX.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Other Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15428"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15430"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15433"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15428 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15430 "><span>DRV_WM8904_GetI2SDriver</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15433 "><span>Get the handle to the I2S driver for this codec instance.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15428 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15430 "><span>DRV_WM8904_VersionGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15433 "><span>This function returns the version of WM8904 driver</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15428 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15430 "><span>DRV_WM8904_VersionStrGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15433 "><span>This function returns the version of WM8904 driver in string format.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15428 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15430 "><span>DRV_WM8904_LRCLK_Sync</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15433 "><span>Synchronize to the start of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Settings Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15475"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15477"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15480"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_MuteOff</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function disables WM8904 output for soft mute.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_MuteOn</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function allows WM8904 output for soft mute on.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_SamplingRateGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function gets the sampling rate set on the WM8904.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_SamplingRateSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function sets the sampling rate of the media stream.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_VolumeGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function gets the volume for WM8904 Codec.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15475 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15477 "><span>DRV_WM8904_VolumeSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15480 "><span>This function sets the volume for WM8904 Codec.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">System Interaction Functions</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15537"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15539"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15542"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15537 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15539 "><span>DRV_WM8904_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15542 "><span>Initializes hardware and data for the instance of the WM8904 DAC module</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15537 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15539 "><span>DRV_WM8904_Deinitialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15542 "><span>Deinitializes the specified instance of the WM8904 driver module</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15537 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15539 "><span>DRV_WM8904_Status</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15542 "><span>Gets the current status of the WM8904 driver module.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15537 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15539 "><span>DRV_WM8904_Tasks</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15542 "><span>Maintains the driver's control and data interface state machine.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title272" id="system-interaction-functions-3"><h4 class="title topictitle4" id="ariaid-title272">System Interaction Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title273" id="drv-wm8904-initialize-function"><h5 class="title topictitle5" id="ariaid-title273">DRV_WM8904_Initialize Function</h5><div class="body"><p class="p">SYS_MODULE_OBJ DRV_WM8904_Initialize</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const SYS_MODULE_INIT *const init</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes hardware and data for the instance of the WM8904 DAC module</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine initializes the WM8904 driver instance for the specified driver index, making it ready for clients to open and use it. The initialization data is specified by the init parameter. The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Initialize must be called before calling this function to initialize the data interface of this Codec driver. DRV_I2C_Initialize must be called if SPI driver is used for handling the control interface of this Codec driver.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15615"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15618"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15615 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15618 "><span>Identifier for the driver instance to be initialized</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15615 "><span>init</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15618 "><span>Pointer to the data structure containing any data necessary to initialize the hardware. This pointer may be null if no data is required and default initialization is to be used.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, returns a valid handle to a driver instance object. Otherwise, it returns SYS_MODULE_OBJ_INVALID.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine must be called before any other WM8904 routine is called.</p>
<p class="p">This routine should only be called once during system initialization unless DRV_WM8904_Deinitialize is called to deinitialize the driver instance. This routine will NEVER block for hardware access.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_WM8904_INIT init; SYS_MODULE_OBJ objectHandle;</p>
<p class="p">init-&gt;inUse = <strong class="ph b">true</strong>; init-&gt;status = SYS_STATUS_BUSY; init-&gt;numClients = 0;</p>
<p class="p">init-&gt;i2sDriverModuleIndex = wm8904Init-&gt;i2sDriverModuleIndex; init-&gt;i2cDriverModuleIndex = wm8904Init-&gt;i2cDriverModuleIndex; init-&gt;samplingRate = DRV_WM8904_AUDIO_SAMPLING_RATE; init-&gt;audioDataFormat = DRV_WM8904_AUDIO_DATA_FORMAT_MACRO;</p>
<p class="p">init-&gt;isInInterruptContext = <strong class="ph b">false</strong>; init-&gt;commandCompleteCallback = (DRV_WM8904_COMMAND_EVENT_HANDLER)0; init-&gt;commandContextData = 0; init-&gt;mclk_multiplier = DRV_WM8904_MCLK_SAMPLE_FREQ_MULTPLIER; objectHandle = DRV_WM8904_Initialize(DRV_WM8904_0, (SYS_MODULE_INIT*)init); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == objectHandle) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_MODULE_OBJ <strong class="ph b">DRV_WM8904_Initialize</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">drvIndex</strong>, <strong class="ph b">const</strong> SYS_MODULE_INIT * <strong class="ph b">const</strong> <strong class="ph b">init</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title274" id="drv-wm8904-deinitialize-function"><h5 class="title topictitle5" id="ariaid-title274">DRV_WM8904_Deinitialize Function</h5><div class="body"><p class="p">void DRV_WM8904_Deinitialize( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Deinitializes the specified instance of the WM8904 driver module</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Deinitializes the specified instance of the WM8904 driver module, disabling its operation (and any hardware). Invalidates all the internal data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_WM8904_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15724"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15727"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15724 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15727 "><span>Driver object handle, returned from the DRV_WM8904_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Once the Initialize operation has been called, the De-initialize operation must be called before the Initialize operation can be called again. This routine will NEVER block waiting for hardware.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_WM8904_Initialize</em></p>
<p class="p">SYS_STATUS status;</p>
<p class="p">DRV_WM8904_Deinitialize(object); status = DRV_WM8904_Status(object); <strong class="ph b">if</strong> (SYS_MODULE_DEINITIALIZED != status) {</p>
<p class="p"><em class="ph i">// Check again later if you need to know</em> <em class="ph i">// when the driver is deinitialized.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_Deinitialize</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title275" id="drv-wm8904-status-function"><h5 class="title topictitle5" id="ariaid-title275">DRV_WM8904_Status Function</h5><div class="body"><p class="p">SYS_STATUS DRV_WM8904_Status( SYS_MODULE_OBJ object)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the current status of the WM8904 driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine provides the current status of the WM8904 driver module.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_WM8904_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15812"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15815"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15812 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15815 "><span>Driver object handle, returned from the DRV_WM8904_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized</p>
<p class="p">SYS_STATUS_READY - Indicates that any previous module operation for the specified module has completed</p>
<p class="p">SYS_STATUS_BUSY - Indicates that a previous module operation for the specified module has not yet completed</p>
<p class="p">SYS_STATUS_ERROR - Indicates that the specified module is in an error state</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">A driver can opened only when its status is SYS_STATUS_READY.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_WM8904_Initialize</em></p>
<p class="p">SYS_STATUS WM8904Status;</p>
<p class="p">WM8904Status = DRV_WM8904_Status(object); <strong class="ph b">if</strong> (SYS_STATUS_READY == WM8904Status) {</p>
<p class="p"><em class="ph i">// This means the driver can be opened using the</em> <em class="ph i">// DRV_WM8904_Open() function.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_STATUS <strong class="ph b">DRV_WM8904_Status</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title276" id="drv-wm8904-tasks-function"><h5 class="title topictitle5" id="ariaid-title276">DRV_WM8904_Tasks Function</h5><div class="body"><p class="p">void DRV_WM8904_Tasks(SYS_MODULE_OBJ object);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Maintains the driver's control and data interface state machine.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine is used to maintain the driver's internal control and data interface state machine and implement its control and data interface implementations. This function should be called from the SYS_Tasks() function.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15905"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e15908"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15905 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e15908 "><span>Object handle for the specified driver instance (returned from DRV_WM8904_Initialize)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine is normally not called directly by an application. It is called by the system's Tasks routine (SYS_Tasks).</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_WM8904_Initialize</em> <strong class="ph b">while</strong> (<strong class="ph b">true</strong>) {</p>
<p class="p">DRV_WM8904_Tasks (object);</p>
<p class="p"><em class="ph i">// Do other tasks</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_Tasks</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title277" id="client-setup-functions-3"><h4 class="title topictitle4" id="ariaid-title277">Client Setup Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title278" id="drv-wm8904-open-function"><h5 class="title topictitle5" id="ariaid-title278">DRV_WM8904_Open Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_WM8904_Open</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX drvIndex, const DRV_IO_INTENT ioIntent</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Opens the specified WM8904 driver instance and returns a handle to it</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine opens the specified WM8904 driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver. The ioIntent parameter defines how the client interacts with this driver instance.</p>
<p class="p">The DRV_IO_INTENT_BLOCKING and DRV_IO_INTENT_NONBLOCKING ioIntent options are not relevant to this driver. All the data transfer functions of this driver are non blocking.</p>
<p class="p">The WM8904 can be opened with DRV_IO_INTENT_WRITE, or DRV_IO_INTENT_READ or DRV_IO_INTENT_WRITEREAD</p>
<p class="p">io_intent option. This decides whether the driver is used for headphone output, or microphone input or both modes simultaneously.</p>
<p class="p">Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client. The driver cannot be opened by any other client.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_WM8904_Initialize must have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16011"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16014"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16011 "><span>drvIndex</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16014 "><span>Identifier for the object instance to be opened</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16011 "><span>ioIntent</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16014 "><span>Zero or more of the values from the enumeration DRV_IO_INTENT "ORed" together to indicate the intended use of the driver. See function description for details.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, the routine returns a valid open-instance handle (a number identifying both the caller and the module instance).</p>
<p class="p">If an error occurs, the return value is DRV_HANDLE_INVALID. Error can occur:</p>
<ul class="ul"><li class="li"><p class="p">if the number of client objects allocated via DRV_WM8904_CLIENTS_NUMBER is insufficient.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver but driver has been opened exclusively by another client.</p>
</li>
<li class="li"><p class="p">if the driver hardware instance being opened is not initialized or is invalid.</p>
</li>
<li class="li"><p class="p">if the ioIntent options passed are not relevant to this driver.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The handle returned is valid until the DRV_WM8904_Close routine is called. This routine will NEVER block waiting for hardware.If the requested intent flags are not supported, the routine will return DRV_HANDLE_INVALID. This function is thread safe in a RTOS application. It should not be called in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; handle = DRV_WM8904_Open(DRV_WM8904_INDEX_0, DRV_IO_INTENT_WRITEREAD | DRV_IO_INTENT_EXCLUSIVE); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em></p>
<p class="p"><em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_WM8904_Open</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">iDriver</strong>, <strong class="ph b">const</strong> DRV_IO_INTENT <strong class="ph b">ioIntent</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title279" id="drv-wm8904-close-function"><h5 class="title topictitle5" id="ariaid-title279">DRV_WM8904_Close Function</h5><div class="body"><p class="p">void DRV_WM8904_Close( DRV_Handle handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Closes an opened-instance of the WM8904 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine closes an opened-instance of the WM8904 driver, invalidating the handle. Any buffers in the driver queue that were submitted by this client will be removed. After calling this routine, the handle passed in "handle" must not be used with any of the remaining driver routines. A new handle must be obtained by calling DRV_WM8904_Open before the caller may use the driver again</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16125"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16128"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16125 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16128 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">• None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">Usually there is no need for the driver client to verify that the Close operation has completed. The driver will abort any ongoing operations when this routine is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; <em class="ph i">// Returned from DRV_WM8904_Open</em></p>
<p class="p">DRV_WM8904_Close(handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_Close</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title280" id="drv-wm8904-buffereventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title280">DRV_WM8904_BufferEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_WM8904_BufferEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_WM8904_BUFFER_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When a client calls DRV_WM8904_BufferAddWrite function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "buffer add" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16216"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16219"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16216 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16219 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16216 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16219 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16216 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16219 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the queued buffer transfer has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_WM8904_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_WM8904_BufferEventHandlerSet(myWM8904Handle,</p>
<p class="p">APP_WM8904BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_WM8904_BufferAddWrite(myWM8904handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_WM8904_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_WM8904BufferEventHandler(DRV_WM8904_BUFFER_EVENT event, DRV_WM8904_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_BufferEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_WM8904_BUFFER_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title281" id="drv-wm8904-commandeventhandlerset-function"><h5 class="title topictitle5" id="ariaid-title281">DRV_WM8904_CommandEventHandlerSet Function</h5><div class="body"><p class="p">void DRV_WM8904_CommandEventHandlerSet</p>
<p class="p">(</p>
<p class="p">DRV_HANDLE handle,</p>
<p class="p">const DRV_WM8904_COMMAND_EVENT_HANDLER eventHandler, const uintptr_t contextHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to identify a command event handling function for the driver to call back when the last submitted command have finished.</p>
<p class="p">The event handler should be set before the client performs any "WM8904 Codec Specific Client Routines" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16391"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16394"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16391 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16394 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16391 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16394 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16391 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16394 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the command has completed, it does not need to register a callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_WM8904_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_WM8904_CommandEventHandlerSet(myWM8904Handle,</p>
<p class="p">APP_WM8904CommandEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_WM8904_DeEmphasisFilterSet(myWM8904Handle, DRV_WM8904_DEEMPHASIS_FILTER_44_1KHZ)</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em> <strong class="ph b">void</strong> APP_WM8904CommandEventHandler(uintptr_t contextHandle) { <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <em class="ph i">// Last Submitted command is completed.</em> <em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_CommandEventHandlerSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong></p>
<p class="p">DRV_WM8904_COMMAND_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">contextHandle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title282" id="data-transfer-functions-3"><h4 class="title topictitle4" id="ariaid-title282">Data Transfer Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title283" id="drv-wm8904-bufferaddread-function"><h5 class="title topictitle5" id="ariaid-title283">DRV_WM8904_BufferAddRead Function</h5><div class="body"><p class="p">void DRV_WM8904_BufferAddRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_WM8904_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking read operation. The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully. The function adds the request to the hardware instance receive queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_WM8904_BUFFER_HANDLE_INVALID</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_WM8904_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_WM8904_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 device instance and the DRV_WM8904_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle. DRV_IO_INTENT_READ must have been specified in the DRV_WM8904_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16556"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16559"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16556 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16559 "><span>Handle of the WM8904 instance as return by the DRV_WM8904_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16556 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16559 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16556 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16559 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16556 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16559 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_WM8904_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the WM8904 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another WM8904 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_BufferAddRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_WM8904_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title284" id="drv-wm8904-bufferaddwrite-function"><h5 class="title topictitle5" id="ariaid-title284">DRV_WM8904_BufferAddWrite Function</h5><div class="body"><p class="p">void DRV_WM8904_BufferAddWrite</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_WM8904_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *buffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write operation. The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully. The function adds the request to the hardware instance transmit queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_WM8904_BUFFER_HANDLE_INVALID:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0.</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_WM8904_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_WM8904_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 device instance and the DRV_WM8904_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_WRITE must have been specified in the DRV_WM8904_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16683"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16686"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16683 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16686 "><span>Handle of the WM8904 instance as return by the DRV_WM8904_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16683 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16686 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16683 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16686 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16683 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16686 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_WM8904_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the WM8904 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another WM8904 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_WM8904_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned</em></p>
<p class="p"><em class="ph i">// by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_WM8904_BufferEventHandlerSet(myWM8904Handle,</p>
<p class="p">APP_WM8904BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_WM8904_BufferAddWrite(myWM8904handle, &amp;bufferHandle myBuffer, MY_BUFFER_SIZE); <strong class="ph b">if</strong>(DRV_WM8904_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_WM8904BufferEventHandler(DRV_WM8904_BUFFER_EVENT event, DRV_WM8904_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_BufferAddWrite</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_WM8904_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title285" id="drv-wm8904-bufferaddwriteread-function"><h5 class="title topictitle5" id="ariaid-title285">DRV_WM8904_BufferAddWriteRead Function</h5><div class="body"><p class="p">void DRV_WM8904_BufferAddWriteRead</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">DRV_WM8904_BUFFER_HANDLE *bufferHandle,</p>
<p class="p">void *transmitBuffer, void *receiveBuffer, size_t size</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Schedule a non-blocking driver write-read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write-read operation. The function returns with a valid buffer handle in the bufferHandle argument if the write-read request was scheduled successfully. The function adds the request to the hardware instance queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_WM8904_BUFFER_EVENT_COMPLETE:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only or write only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a DRV_WM8904_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_WM8904_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 device instance and the DRV_WM8904_Status must have returned SYS_STATUS_READY.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">DRV_IO_INTENT_READWRITE must have been specified in the DRV_WM8904_Open call.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16889"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e16892"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16889 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16892 "><span>Handle of the WM8904 instance as returned by the DRV_WM8904_Open function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16889 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16892 "><span>Pointer to an argument that will contain the return buffer handle</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16889 "><span>transmitBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16892 "><span>The buffer where the transmit data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16889 "><span>receiveBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16892 "><span>The buffer where the received data will be stored</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16889 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e16892 "><span>Buffer size in bytes</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_WM8904_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the WM8904 Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another WM8904 driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p">This function is useful when there is valid read expected for every WM8904 write. The transmit and receive size must be same.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj; uint8_t mybufferTx<span class="xref"></span>; uint8_t mybufferRx<span class="xref"></span>; DRV_WM8904_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// mywm8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver</em></p>
<p class="p">DRV_WM8904_BufferEventHandlerSet(mywm8904Handle, APP_WM8904BufferEventHandler, (uintptr_t)&amp;myAppObj);</p>
<p class="p">DRV_WM8904_BufferAddWriteRead(mywm8904handle, &amp;bufferHandle,</p>
<p class="p">mybufferTx,mybufferRx,MY_BUFFER_SIZE);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_WM8904_BUFFER_HANDLE_INVALID == bufferHandle) { <em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em> <strong class="ph b">void</strong> APP_WM8904BufferEventHandler(DRV_WM8904_BUFFER_EVENT event, DRV_WM8904_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle)</p>
<p class="p">{ <em class="ph i">// contextHandle points to myAppObj.</em> <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_BufferAddWriteRead</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_WM8904_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">transmitBuffer</strong>, <strong class="ph b">void</strong> * <strong class="ph b">receiveBuffer</strong>, size_t <strong class="ph b">size</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title286" id="drv-wm8904-readqueuepurge-function"><h5 class="title topictitle5" id="ariaid-title286">DRV_WM8904_ReadQueuePurge Function</h5><div class="body"><p class="p">bool DRV_WM8904_ReadQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the read queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the read queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17073"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17076"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17073 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17076 "><span>Handle of the communication channel as returned by the DRV_WM8904_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Read queue purge is successful. False - Read queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_WM8904_BufferAddRead to queue read requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) {</p>
<p class="p"><strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_WM8904_ReadQueuePurge(myCodecHandle))</p>
<p class="p">{</p>
<p class="p"><em class="ph i">//Couldn't purge the read queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_WM8904_ReadQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title287" id="drv-wm8904-writequeuepurge-function"><h5 class="title topictitle5" id="ariaid-title287">DRV_WM8904_WriteQueuePurge Function</h5><div class="body"><p class="p">bool DRV_WM8904_WriteQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the write queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the write queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17184"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17187"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17184 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17187 "><span>Handle of the communication channel as returned by the DRV_WM8904_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Write queue purge is successful. False - Write queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myCodecHandle is the handle returned by the DRV_WM8904_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_WM8904_BufferAddWrite to queue write requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_WM8904_WriteQueuePurge(myCodecHandle)) { <em class="ph i">//Couldn't purge the write queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_WM8904_WriteQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title288" id="settings-functions-3"><h4 class="title topictitle4" id="ariaid-title288">Settings Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title289" id="drv-wm8904-muteoff-function"><h5 class="title topictitle5" id="ariaid-title289">DRV_WM8904_MuteOff Function</h5><div class="body"><p class="p">void DRV_WM8904_MuteOff(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function disables WM8904 output for soft mute.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function disables WM8904 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17297"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17300"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17297 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17300 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">DRV_WM8904_MuteOff(myWM8904Handle); <em class="ph i">//WM8904 output soft mute disabled</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_MuteOff</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title290" id="drv-wm8904-muteon-function"><h5 class="title topictitle5" id="ariaid-title290">DRV_WM8904_MuteOn Function</h5><div class="body"><p class="p">void DRV_WM8904_MuteOn(DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function allows WM8904 output for soft mute on.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function Enables WM8904 output for soft mute.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17385"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17388"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17385 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17388 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">DRV_WM8904_MuteOn(myWM8904Handle); <em class="ph i">//WM8904 output soft muted</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_MuteOn</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title291" id="drv-wm8904-samplingrateget-function"><h5 class="title topictitle5" id="ariaid-title291">DRV_WM8904_SamplingRateGet Function</h5><div class="body"><p class="p">uint32_t DRV_WM8904_SamplingRateGet(DRV_HANDLE handle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the sampling rate set on the WM8904.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function gets the sampling rate set on the DAC WM8904.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17466"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17469"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17466 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17469 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">uint32_t baudRate;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">baudRate = DRV_WM8904_SamplingRateGet(myWM8904Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_WM8904_SamplingRateGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title292" id="drv-wm8904-samplingrateset-function"><h5 class="title topictitle5" id="ariaid-title292">DRV_WM8904_SamplingRateSet Function</h5><div class="body"><p class="p">void DRV_WM8904_SamplingRateSet(DRV_HANDLE handle, uint32_t samplingRate)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the sampling rate of the media stream.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the media sampling rate for the client handle.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17537"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17540"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17537 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17540 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17537 "><span>samplingRate</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17540 "><span>Sampling frequency in Hz</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">DRV_WM8904_SamplingRateSet(myWM8904Handle, 48000); <em class="ph i">//Sets 48000 media sampling rate</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_SamplingRateSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint32_t <strong class="ph b">samplingRate</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title293" id="drv-wm8904-volumeget-function"><h5 class="title topictitle5" id="ariaid-title293">DRV_WM8904_VolumeGet Function</h5><div class="body"><p class="p">uint8_t DRV_WM8904_VolumeGet(DRV_HANDLE handle, DRV_WM8904_CHANNEL channel)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function gets the volume for WM8904 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This functions gets the current volume programmed to the Codec WM8904.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17623"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17626"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17623 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17626 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17623 "><span>channel</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17626 "><span>argument indicating Left or Right or Both channel volume to be modified</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj; uint8_t volume;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">volume = DRV_WM8904_VolumeGet(myWM8904Handle, DRV_WM8904_CHANNEL_LEFT);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint8_t <strong class="ph b">DRV_WM8904_VolumeGet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_WM8904_CHANNEL <strong class="ph b">channel</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title294" id="drv-wm8904-volumeset-function"><h5 class="title topictitle5" id="ariaid-title294">DRV_WM8904_VolumeSet Function</h5><div class="body"><p class="p">void DRV_WM8904_VolumeSet(DRV_HANDLE handle, DRV_WM8904_CHANNEL channel, uint8_t volume);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function sets the volume for WM8904 Codec.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the volume value from 0-255. The codec has DAC value to volume range mapping as :- 00 H : +12dB FF H : -115dB In order to make the volume value to dB mapping monotonically increasing from 00 to FF, re-mapping is introduced which reverses the volume value to dB mapping as well as normalizes the volume range to a more audible dB range. The current driver implementation assumes that all dB values under -60 dB are inaudible to the human ear. Re-Mapped values 00 H : -60 dB FF H : +12 dB</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17709"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17712"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17709 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17712 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17709 "><span>channel</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17712 "><span>argument indicating Left or Right or Both channel volume to be modified</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17709 "><span>volume</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17712 "><span>volume value specified in the range 0-255 (0x00 to 0xFF)</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned // by the DRV_WM8904_Open function.</em></p>
<p class="p">DRV_WM8904_VolumeSet(myWM8904Handle,DRV_WM8904_CHANNEL_LEFT, 120);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_WM8904_VolumeSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, DRV_WM8904_CHANNEL <strong class="ph b">channel</strong>, uint8_t <strong class="ph b">volume</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title295" id="other-functions-3"><h4 class="title topictitle4" id="ariaid-title295">Other Functions</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title296" id="drv-wm8904-geti2sdriver-function"><h5 class="title topictitle5" id="ariaid-title296">DRV_WM8904_GetI2SDriver Function</h5><div class="body"><p class="p">DRV_HANDLE DRV_WM8904_GetI2SDriver(DRV_HANDLE codecHandle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the handle to the I2S driver for this codec instance.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Returns the appropriate handle to the I2S based on the ioIent member of the codec object.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">The DRV_WM8904_Initialize routine must have been called for the specified WM8904 driver instance.</p>
<p class="p">DRV_WM8904_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17815"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17818"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17815 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17818 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">A handle to the I2S driver for this codec instance</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This allows the caller to directly access portions of the I2S driver that might not be available via the codec API.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_WM8904_GetI2SDriver</strong>(DRV_HANDLE <strong class="ph b">codecHandle</strong>);</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title297" id="drv-wm8904-versionget-function"><h5 class="title topictitle5" id="ariaid-title297">DRV_WM8904_VersionGet Function</h5><div class="body"><p class="p">uint32_t DRV_WM8904_VersionGet( void )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of WM8904 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The version number returned from the DRV_WM8904_VersionGet function is an unsigned integer in the following decimal format. * 10000 + * 100 + Where the numbers are represented in decimal and the meaning is the same as above. Note that there is no numerical representation of release type.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns the version of WM8904 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example 1</strong></p>
<p class="p">For version "0.03a", return: 0 * 10000 + 3 * 100 + 0 For version "1.00", return: 1 * 100000 + 0 * 100 + 0</p>
<p class="p"><strong class="ph b">Example 2</strong></p>
<p class="p">uint32_t WM8904version; WM8904version = DRV_WM8904_VersionGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">DRV_WM8904_VersionGet</strong>();</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title298" id="drv-wm8904-versionstrget-function"><h5 class="title topictitle5" id="ariaid-title298">DRV_WM8904_VersionStrGet Function</h5><div class="body"><p class="p">int8_t* DRV_WM8904_VersionStrGet(void)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">This function returns the version of WM8904 driver in string format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The DRV_WM8904_VersionStrGet function returns a string in the format: ".<span class="xref"></span>" Where: is the WM8904 driver's version number. is the WM8904 driver's version number. is an optional "patch" or "dot" release number (which is not included in the string if it equals "00"). is an optional release type ("a" for alpha, "b" for beta ? not the entire word spelled out) that is not included if the release is a production version (I.e. Not an alpha or beta).</p>
<p class="p">The String does not contain any spaces. For example, "0.03a" "1.00"</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">returns a string containing the version of WM8904 driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">int8_t *WM8904string; WM8904string = DRV_WM8904_VersionStrGet();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">int8_t* <strong class="ph b">DRV_WM8904_VersionStrGet</strong>();</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title299" id="drv-wm8904-lrclk-sync-function"><h5 class="title topictitle5" id="ariaid-title299">DRV_WM8904_LRCLK_Sync Function</h5><div class="body"><p class="p">uint32_t DRV_WM8904_LRCLK_Sync (const DRV_HANDLE handle);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Synchronize to the start of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function waits until low-to high transition of the I2S LRCLK (left/right clock) signal (high-low if Left-Justified format, this is determined by the PLIB). In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize calls to the DMA with the LRCLK signal so the left/right channel association is valid.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17979"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e17982"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17979 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e17982 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myWM8904Handle is the handle returned</em> <em class="ph i">// by the DRV_WM8904_Open function.</em></p>
<p class="p">DRV_WM8904_LRCLK_Sync(myWM8904Handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_WM8904_LRCLK_Sync</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title300" id="data-types-and-constants"><h4 class="title topictitle4" id="ariaid-title300">Data Types and Constants</h4><div class="body"></div>
<div class="topic nested4" aria-labelledby="ariaid-title301" id="data-length-type"><h5 class="title topictitle5" id="ariaid-title301">DATA_LENGTH Type</h5><div class="body"><p class="p">in bits</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> DATA_LENGTH@4 <strong class="ph b">DATA_LENGTH</strong>;</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title302" id="drv-wm8904-audio-data-format-enumeration"><h5 class="title topictitle5" id="ariaid-title302">DRV_WM8904_AUDIO_DATA_FORMAT Enumeration</h5><div class="body"><p class="p">Identifies the Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Audio data format</p>
<p class="p">This enumeration identifies Serial Audio data interface format.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> { <strong class="ph b">DATA_16_BIT_LEFT_JUSTIFIED</strong>,</p>
<p class="p"><strong class="ph b">DATA_16_BIT_I2S</strong>, <strong class="ph b">DATA_32_BIT_LEFT_JUSTIFIED</strong>,</p>
<p class="p"><strong class="ph b">DATA_32_BIT_I2S</strong></p>
<p class="p">} DRV_WM8904_AUDIO_DATA_FORMAT;</p>
</div>
</div>
<div class="topic nested4" aria-labelledby="ariaid-title303" id="drv-wm8904-buffer-event-enumeration"><h5 class="title topictitle5" id="ariaid-title303">DRV_WM8904_BUFFER_EVENT Enumeration</h5><div class="body"><p class="p">Identifies the possible events that can result from a buffer add request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Events</p>
<p class="p">This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_WM8904_BufferAddWrite() or the DRV_WM8904_BufferAddRead() function.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">One of these values is passed in the "event" parameter of the event handling callback function that the client registered with the driver by calling the DRV_WM8904_BufferEventHandlerSet function when a buffer transfer request is completed.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> { <strong class="ph b">DRV_WM8904_BUFFER_EVENT_COMPLETE</strong>,</p>
<p class="p"><strong class="ph b">DRV_WM8904_BUFFER_EVENT_ERROR</strong>,</p>
<p class="p"><strong class="ph b">DRV_WM8904_BUFFER_EVENT_ABORT</strong></p>
<p class="p">} DRV_WM8904_BUFFER_EVENT;</p>
</div>
</div>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title304" id="drv-wm8904-buffer-event-handler-type"><h2 class="title topictitle2" id="ariaid-title304"><em class="ph i">DRV_WM8904_BUFFER_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a WM8904 Driver Buffer Event handler function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Buffer Event Handler Function</p>
<p class="p">This data type defines the required function signature for the WM8904 driver buffer event handling callback function. A client must register a pointer to a buffer event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18156"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18159"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18156 "><span>event</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18159 "><span>Identifies the type of event</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18156 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18159 "><span>Handle identifying the buffer to which the event relates</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18156 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18159 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the event is DRV_WM8904_BUFFER_EVENT_COMPLETE, this means that the data was transferred successfully.</p>
<p class="p">If the event is DRV_WM8904_BUFFER_EVENT_ERROR, this means that the data was not transferred successfully. The bufferHandle parameter contains the buffer handle of the buffer that failed. The DRV_WM8904_BufferProcessedSizeGet() function can be called to find out how many bytes were processed.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that associated with the event.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_WM8904_BufferEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The buffer handle in bufferHandle expires after this event handler exits. In that the buffer object that was allocated is deallocated by the driver after the event handler exits.</p>
<p class="p">The event handler function executes in the data driver(i2S) peripheral's interrupt context when the driver is configured for interrupt mode operation. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p">DRV_WM8904_BufferAddWrite function can be called in the event handler to add a buffer to the driver queue.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_MyBufferEventHandler( DRV_WM8904_BUFFER_EVENT event, DRV_WM8904_BUFFER_HANDLE bufferHandle, uintptr_t context ) { MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; <strong class="ph b">switch</strong>(event)</p>
<p class="p">{ <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_COMPLETE: <em class="ph i">// Handle the completed buffer.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_WM8904_BUFFER_EVENT_ERROR: <strong class="ph b">default</strong>: <em class="ph i">// Handle error.</em> <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_WM8904_BUFFER_EVENT_HANDLER</strong>)(DRV_WM8904_BUFFER_EVENT event, DRV_WM8904_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title305" id="drv-wm8904-buffer-handle-type"><h2 class="title topictitle2" id="ariaid-title305"><em class="ph i">DRV_WM8904_BUFFER_HANDLE Type</em></h2><div class="body"><p class="p">Handle identifying a write buffer passed to the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Buffer Handle</p>
<p class="p">A buffer handle value is returned by a call to the DRV_WM8904_BufferAddWrite() or DRV_WM8904_BufferAddRead() function. This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer.</p>
<p class="p">The buffer handle value returned from the "buffer add" function is returned back to the client by the "event handler callback" function registered with the driver.</p>
<p class="p">The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> uintptr_t <strong class="ph b">DRV_WM8904_BUFFER_HANDLE</strong>;</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title306" id="drv-wm8904-channel-enumeration"><h3 class="title topictitle3" id="ariaid-title306">DRV_WM8904_CHANNEL Enumeration</h3><div class="body"><p class="p">Identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Audio Channel</p>
<p class="p">This enumeration identifies Left/Right Audio channel</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> { <strong class="ph b">DRV_WM8904_CHANNEL_LEFT</strong>,</p>
<p class="p"><strong class="ph b">DRV_WM8904_CHANNEL_RIGHT</strong>,</p>
<p class="p"><strong class="ph b">DRV_WM8904_CHANNEL_LEFT_RIGHT</strong>,</p>
<p class="p"><strong class="ph b">DRV_WM8904_NUMBER_OF_CHANNELS</strong></p>
<p class="p">} DRV_WM8904_CHANNEL;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title307" id="drv-wm8904-command-event-handler-type"><h2 class="title topictitle2" id="ariaid-title307"><em class="ph i">DRV_WM8904_COMMAND_EVENT_HANDLER Type</em></h2><div class="body"><p class="p">Pointer to a WM8904 Driver Command Event Handler Function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Command Event Handler Function</p>
<p class="p">This data type defines the required function signature for the WM8904 driver command event handling callback function.</p>
<p class="p">A command is a control instruction to the WM8904 Codec. Example Mute ON/OFF, Zero Detect Enable/Disable etc.</p>
<p class="p">A client must register a pointer to a command event handling function who's function signature (parameter and return value types) match the types specified by this function pointer in order to receive command related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18358"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18361"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18358 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18361 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The occurrence of this call back means that the last control command was transferred successfully.</p>
<p class="p">The context parameter contains a handle to the client context, provided at the time the event handling function was registered using the DRV_WM8904_CommandEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The event handler function executes in the control data driver interrupt context. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_WM8904CommandEventHandler( uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context;</p>
<p class="p"><em class="ph i">// Last Submitted command is completed.</em></p>
<p class="p"><em class="ph i">// Perform further processing here</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_WM8904_COMMAND_EVENT_HANDLER</strong>)(uintptr_t contextHandle);</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title308" id="drv-wm8904-init-structure"><h3 class="title topictitle3" id="ariaid-title308">DRV_WM8904_INIT Structure</h3><div class="body"><p class="p">Defines the data required to initialize or reinitialize the WM8904 driver</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Initialization Data</p>
<p class="p">This data type defines the data required to initialize or reinitialize the WM8904 Codec driver.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">struct</strong> {</p>
<p class="p">SYS_MODULE_INIT <strong class="ph b">moduleInit</strong>;</p>
<p class="p">SYS_MODULE_INDEX <strong class="ph b">i2sDriverModuleIndex</strong>; SYS_MODULE_INDEX <strong class="ph b">i2cDriverModuleIndex</strong>; <strong class="ph b">bool</strong> <strong class="ph b">masterMode</strong>; uint32_t <strong class="ph b">samplingRate</strong>; uint8_t <strong class="ph b">volume</strong>; DRV_WM8904_AUDIO_DATA_FORMAT <strong class="ph b">audioDataFormat</strong>; <strong class="ph b">bool</strong> <strong class="ph b">enableMicInput</strong>; <strong class="ph b">bool</strong> <strong class="ph b">enableMicBias</strong>; } DRV_WM8904_INIT;</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title309" id="drv-wm8904-buffer-handle-invalid-macro"><h2 class="title topictitle2" id="ariaid-title309"><em class="ph i">DRV_WM8904_BUFFER_HANDLE_INVALID Macro</em></h2><div class="body"><p class="p">Definition of an invalid buffer handle.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Invalid Buffer Handle</p>
<p class="p">This is the definition of an invalid buffer handle. An invalid buffer handle is returned by DRV_WM8904_BufferAddWrite() and the DRV_WM8904_BufferAddRead() function if the buffer add request was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_BUFFER_HANDLE_INVALID</strong> ((DRV_WM8904_BUFFER_HANDLE)(-1))</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title310" id="drv-wm8904-count-macro"><h3 class="title topictitle3" id="ariaid-title310">DRV_WM8904_COUNT Macro</h3><div class="body"><p class="p">Number of valid WM8904 driver indices</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Driver Module Count</p>
<p class="p">This constant identifies the maximum number of WM8904 Driver instances that should be defined by the application. Defining more instances than this constant will waste RAM memory space.</p>
<p class="p">This constant can also be used by the application to identify the number of WM8904 instances on this microcontroller.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This value is part-specific.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_COUNT</strong></p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title311" id="drv-wm8904-index-0-macro"><h3 class="title topictitle3" id="ariaid-title311">DRV_WM8904_INDEX_0 Macro</h3><div class="body"><p class="p">WM8904 driver index definitions</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Driver WM8904 Module Index</p>
<p class="p">These constants provide WM8904 driver index definition.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">These constants should be used in place of hard-coded numeric literals. These values should be passed into the DRV_WM8904_Initialize and DRV_WM8904_Open routines to identify the driver instance in use.</p>
<p class="p">Introduction</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_WM8904_INDEX_0</strong> 0</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title312" id="drv-i2c-index-macro"><h3 class="title topictitle3" id="ariaid-title312">DRV_I2C_INDEX Macro</h3><div class="body"><p class="p">This is macro DRV_I2C_INDEX.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_I2C_INDEX</strong> DRV_WM8904_I2C_INSTANCES_NUMBER</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title313" id="files-2"><h3 class="title topictitle3" id="ariaid-title313">Files</h3><div class="body"><p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18602"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18605"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18602 "><span>drv_wm8904.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18605 "><span>WM8904 Codec Driver Interface header file</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18602 "><span>drv_wm8904_config_template.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18605 "><span>WM8904 Codec Driver Configuration Template.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section will list only the library's interface header file(s).</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title314" id="drv-wm8904h"><h3 class="title topictitle3" id="ariaid-title314">drv_wm8904.h</h3><div class="body"><p class="p">drv_wm8904.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">WM8904 Codec Driver Interface header file</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Codec Driver Interface</p>
<p class="p">The WM8904 Codec device driver interface provides a simple interface to manage the WM8904 16/24/32-Bit Codec that can be interfaced to a Microchip microcontroller. This file provides the public interface definitions for the WM8904 Codec device driver.</p>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title315" id="drv-wm8904-config-templateh"><h3 class="title topictitle3" id="ariaid-title315">drv_wm8904_config_template.h</h3><div class="body"><p class="p">drv_wm8904_config_template.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">WM8904 Codec Driver Configuration Template.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">WM8904 Codec Driver Configuration Template</p>
<p class="p">These file provides the list of all the configurations that can be used with the driver. This file should not be included in the driver.</p>
<p class="p"><strong class="ph b">I2S Driver Library Help</strong></p>
<p class="p">This section describes the I2S Driver Library.</p>
<p class="p"><strong class="ph b">Introduction</strong></p>
<p class="p">This library provides an interface to manage the I2S Audio Protocol Interface Modes.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The I2S Driver is connected to a hardware module that provides the actual I2S stream, on some MCUs this is a Serial Peripheral Interface (SPI), on others it may be an I2S Controller (I2SC), or Serial Synchronous Controller (SSC).</p>
<p class="p">The I2S hardware peripheral is then interfaced to various devices such as codecs and Bluetooth modules to provide microcontroller-based audio solutions.</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the I2S Driver Library and provides information and examples on its use.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title316" id="interface-header-file-drv-i2sh"><h2 class="title topictitle2" id="ariaid-title316">Interface Header File: drv_i2s.h</h2><div class="body"><p class="p">The interface to the I2S Driver Library is defined in the drv_i2s.h header file. Any C language source (.c) file that uses the I2S Driver Library should include drv_i2s.h.</p>
<p class="p">Please refer to the What is MPLAB Harmony? section for how the driver interacts with the framework.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/audio_tone_linkeddma</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title317" id="abstraction-model-3"><h2 class="title topictitle2" id="ariaid-title317"><em class="ph i">Abstraction Model</em></h2><div class="body"><p class="p">The I2S Driver provides a high level abstraction of the lower level (SPI/I2SC/SSC) I2S modules with a convenient C language interface. This topic describes how that abstraction is modeled in the software and introduces the I2S Driver Library interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Different types of I2S capable PLIBs are available on various Microchip microcontrollers. Some have an internal buffer mechanism and some do not. The buffer depth varies across part families. The I2S Driver Library abstracts out these differences and provides a unified model for audio data transfer across different types of I2S modules.</p>
<p class="p">Both the transmitter and receiver provide a buffer in the driver, which transmits and receives data to/from the hardware. The I2S Driver Library provides a set of interfaces to perform the read and the write. The following diagrams illustrate the abstraction model used by the I2S Driver Library. The I2SC Peripheral is used as an example of an I2S-capable PLIB. <strong class="ph b">I2S Driver Abstraction Model</strong>
<img class="image" src="GUID-116B9958-209C-4BB0-A9F7-7685360BDD59-low.png" /><br /></p>
<p class="p">The PLIBs currently provided, such as SSC and I2SC, only support an interrupt/DMA mode of operation. Polled mode of operation is not supported.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title318" id="library-overview-4"><h2 class="title topictitle2" id="ariaid-title318"><em class="ph i">Library Overview</em></h2><div class="body"><p class="p">Refer to the Driver Library Overwiew section for information on how the driver operates in a system.</p>
<p class="p">The I2S driver library provides an API interface to transfer/receive digital audio data using supported Audio protocols. The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the I2S Driver Library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18744"><span><strong class="ph b">Library Interface Section</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e18747"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18744 "><span>System Interaction Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18747 "><span>Provides device initialization and status functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18744 "><span>Client Setup Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18747 "><span>Provides open and close functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18744 "><span>Data Transfer Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18747 "><span>Provides data transfer functions.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18744 "><span>Miscellaneous Functions</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18747 "><span>Provides driver miscellaneous functions such as get error functions, L/R clock sync, etc.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18744 "><span>Data Types and Constants</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e18747 "><span>These data types and constants are required while interacting and setting up the I2S Driver Library.</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title319" id="how-the-library-works-4"><h2 class="title topictitle2" id="ariaid-title319"><em class="ph i">How the Library Works</em></h2><div class="body"><p class="p">The library provides interfaces to support:</p>
<ul class="ul"><li class="li"><p class="p">System Functionality</p>
</li>
<li class="li"><p class="p">Client Functionality</p>
</li>
</ul>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> Not all modes are available on all devices. Please refer to the specific device data sheet to determine the supported modes.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title320" id="system-access"><h2 class="title topictitle2" id="ariaid-title320">System Access</h2><div class="body"><p class="p">This section provides information on system access.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title321" id="system-initialization-3"><h2 class="title topictitle2" id="ariaid-title321">System Initialization</h2><div class="body"><p class="p">The system performs the initialization of the device driver with settings that affect only the instance of the device that is being initialized. During system initialization, each instance of the I2S module would be initialized with the following configuration settings (either passed dynamically at run time using DRV_I2S_INIT or by using Initialization Overrides) that are supported by the specific I2S device hardware:</p>
<ul class="ul"><li class="li"><p class="p">Device requested power state: one of the System Module Power States. For specific details please refer to <strong class="ph b">Data Types and Constants</strong> in the Library Interface section.</p>
</li>
<li class="li"><p class="p">The actual peripheral ID enumerated as the PLIB level module ID (e.g., SPI_ID_2)</p>
</li>
<li class="li"><p class="p">Defining the respective interrupt sources for TX, RX, DMA TX Channel, DMA RX Channel and Error Interrupt</p>
</li>
</ul>
<p class="p">The DRV_I2S_Initialize API returns an object handle of the type SYS_MODULE_OBJ. The object handle returned by the Initialize interface would be used by the other system interfaces such as DRV_I2S_Deinitialize, DRV_I2S_Status, DRV_I2S_Tasks, and DRV_I2S_TasksError.</p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Notes:</strong> 1. The system initialization setting only effect the instance of the peripheral that is being initialized.</p>
<p class="p">2. Configuration of the dynamic driver for DMA mode(uses DMA channel for data transfer) or Non DMA mode can be performed by appropriately setting the 'dmaChannelTransmit' and 'dmaChannelReceive' variables of the DRV_I2S_INIT structure. For example the TX will be in DMA mode when 'dmaChannelTransmit' is initialized to a valid supported channel number from the enum DMA_CHANNEL. TX will be in Non DMA mode when 'dmaChannelTransmit' is initialized to 'DMA_CHANNEL_NONE'.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_I2S_INIT init;</p>
<p class="p">SYS_MODULE_OBJ objectHandle;</p>
<p class="p"><em class="ph i">/* I2S Driver Initialization Data */</em></p>
<p class="p">DRV_I2S_INIT drvI2S0InitData =</p>
<p class="p">{</p>
<p class="p">.i2sPlib = &amp;drvI2S0PlibAPI,</p>
<p class="p">.interruptI2S = DRV_I2S_INT_SRC_IDX0,</p>
<p class="p">.numClients = DRV_I2S_CLIENTS_NUMBER_IDX0,</p>
<p class="p">.queueSize = DRV_I2S_QUEUE_SIZE_IDX0,</p>
<p class="p">.dmaChannelTransmit = DRV_I2S_XMIT_DMA_CH_IDX0,</p>
<p class="p">.dmaChannelReceive = DRV_I2S_RCV_DMA_CH_IDX0,</p>
<p class="p">.i2sTransmitAddress = (<strong class="ph b">void</strong> *)&amp;(SSC_REGS-&gt;SSC_THR),</p>
<p class="p">.i2sReceiveAddress = (<strong class="ph b">void</strong> *)&amp;(SSC_REGS-&gt;SSC_RHR),</p>
<p class="p">.interruptDMA = XDMAC_IRQn,</p>
<p class="p">.dmaDataLength = DRV_I2S_DATA_LENGTH_IDX0,</p>
<p class="p">};</p>
<p class="p">sysObj.drvI2S0 = DRV_I2S_Initialize(DRV_I2S_INDEX_0, (SYS_MODULE_INIT *)&amp;drvI2S0InitData); <strong class="ph b">Task Routine</strong></p>
<p class="p">There is no task routine, since polled mode is not currently supported.</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title322" id="client-access-4"><h3 class="title topictitle3" id="ariaid-title322">Client Access</h3><div class="body"><p class="p">This section provides information on general client operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title323" id="general-client-operation"><h2 class="title topictitle2" id="ariaid-title323">General Client Operation</h2><div class="body"><p class="p">For the application to start using an instance of the module, it must call the DRV_I2S_Open function. This provides the settings required to open the I2S instance for operation.</p>
<p class="p">For the various options available for IO_INTENT, please refer to <strong class="ph b">Data Types and Constants</strong> in the Library Interface section.</p>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p">DRV_HANDLE handle; handle = DRV_I2S_Open(drvObj-&gt;i2sDriverModuleIndex, (DRV_IO_INTENT_WRITE | DRV_IO_INTENT_NONBLOCKING)); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em> <em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title324" id="client-operations---buffered"><h3 class="title topictitle3" id="ariaid-title324">Client Operations - Buffered</h3><div class="body"><p class="p">This section provides information on buffered client operations.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title325" id="client-operations---buffered-1"><h4 class="title topictitle4" id="ariaid-title325">Client Operations - Buffered</h4><div class="body"><p class="p">Client buffered operations provide a the typical audio interface. The functions DRV_I2S_BufferAddRead,</p>
<p class="p">DRV_I2S_BufferAddWrite, and DRV_I2S_BufferAddWriteRead are the buffered data operation functions. The buffered functions schedules non-blocking operations. The function adds the request to the hardware instance queues and returns a buffer handle.</p>
<p class="p">The requesting client also registers a callback event with the driver. The driver notifies the client with</p>
<p class="p">DRV_I2S_BUFFER_EVENT_COMPLETE, DRV_I2S_BUFFER_EVENT_ERROR or DRV_I2S_BUFFER_EVENT_ABORT events.</p>
<p class="p">The buffer add requests are processed from the I2S channel ISR in interrupt mode.</p>
<p class="p">The following diagram illustrates the buffered data operations
<img class="image" src="GUID-2033FC7F-0724-4949-94D9-990AF9CEAB56-low.png" /><br /></p>
<p class="p"><img class="image" src="GUID-9DDF134C-2114-431B-9555-E4D0BCA3939D-low.png" /><br /> <strong class="ph b">Note:</strong> It is not necessary to close and reopen the client between multiple transfers.</p>
<p class="p">An application using the buffered functionality needs to perform the following steps:</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p">The system should have completed necessary setup and initializations.</p>
</li>
<li class="li"><span class="indent-level-default">2.</span><p class="p">If DMA mode is desired, the DMA should be initialized by calling SYS_DMA_Initialize.</p>
</li>
<li class="li"><span class="indent-level-default">3.</span><p class="p">The necessary ports setup and remapping must be done for I2S lines: ADCDAT, DACDAT, BCLK, LRCK and MCLK (if required).</p>
</li>
<li class="li"><span class="indent-level-default">4.</span><p class="p">The driver object should have been initialized by calling DRV_I2S_Initialize. If DMA mode is desired, related attributes in the init structure must be set.</p>
</li>
<li class="li"><span class="indent-level-default">5.</span><p class="p">Open the driver using DRV_I2S_Open with the necessary ioIntent to get a client handle.</p>
</li>
<li class="li"><span class="indent-level-default">6.</span><p class="p">The necessary BCLK, LRCK, and MCLK should be set up so as to generate the required media bit rate.</p>
</li>
<li class="li"><span class="indent-level-default">7.</span><p class="p">The necessary Baud rate value should be set up by calling DRV_I2S_BaudrateSet.</p>
</li>
<li class="li"><span class="indent-level-default">8.</span><p class="p">The Register and event handler for the client handle should be set up by calling DRV_I2S_BufferEventHandlerSet.</p>
</li>
<li class="li"><span class="indent-level-default">9.</span><p class="p">Add a buffer to initiate the data transfer by calling</p>
</li>
</ol>
<p class="p">DRV_I2S_BufferAddWrite/DRV_I2S_BufferAddRead/DRV_I2S_BufferAddWriteRead.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p">When the DMA Channel has finished, the callback function registered in step 8 will be called.</p>
</li>
<li class="li"><span class="indent-level-default">2.</span><p class="p">Repeat step 9 through step 10 to handle multiple buffer transmission and reception.</p>
</li>
<li class="li"><span class="indent-level-default">3.</span><p class="p">When the client is done it can use DRV_I2S_Close to close the client handle.</p>
</li>
</ol>
<p class="p"><strong class="ph b">Example:</strong></p>
<p class="p"><em class="ph i">// The following is an example for interrupt mode buffered transmit</em></p>
<p class="p"><strong class="ph b">#define</strong> SYS_I2S_DRIVER_INDEX DRV_I2S_1 <em class="ph i">// I2S Uses SPI Hardware</em></p>
<p class="p"><strong class="ph b">#define</strong> BUFFER_SIZE 1000 <em class="ph i">// I2S initialization structure.</em></p>
<p class="p"><em class="ph i">// This should be populated with necessary settings.</em></p>
<p class="p"><em class="ph i">// attributes dmaChannelTransmit/dmaChannelReceive</em></p>
<p class="p"><em class="ph i">// and dmaInterruptTransmitSource/dmaInterruptReceiveSource // must be set if DMA mode of operation is desired.</em></p>
<p class="p">DRV_I2S_INIT i2sInit;</p>
<p class="p">SYS_MODULE_OBJ sysObj; <em class="ph i">//I2S module object</em> DRV_HANDLE handle; <em class="ph i">//Client handle</em> uint32_t i2sClock; <em class="ph i">//BCLK frequency</em> uint32_t baudrate; <em class="ph i">//baudrate</em></p>
<p class="p">uint16_t myAudioBuffer<span class="xref"></span>; <em class="ph i">//Audio buffer to be transmitted</em> DRV_I2S_BUFFER_HANDLE bufferHandle; APP_DATA_S state; <em class="ph i">//Application specific state</em> uintptr_t contextHandle; <strong class="ph b">void</strong> SYS_Initialize ( <strong class="ph b">void</strong>* data ) { <em class="ph i">// The system should have completed necessary setup and initializations.</em></p>
<p class="p"><em class="ph i">// Necessary ports setup and remapping must be done for I2S lines ADCDAT,</em></p>
<p class="p"><em class="ph i">// DACDAT, BCLK, LRCK and MCLK</em> sysObj = DRV_I2S_Initialize(SYS_I2S_DRIVER_INDEX, (SYS_MODULE_INIT*)&amp;i2sInit); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == sysObj) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">void</strong> App_Task(<strong class="ph b">void</strong>) { <strong class="ph b">switch</strong>(state) { <strong class="ph b">case</strong> APP_STATE_INIT: {</p>
<p class="p">handle = DRV_I2S_Open(SYS_I2S_DRIVER_INDEX, (DRV_IO_INTENT_WRITE | DRV_IO_INTENT_NONBLOCKING)); <strong class="ph b">if</strong>(handle != DRV_HANDLE_INVALID ) { <em class="ph i">/* Update the state */</em> state = APP_STATE_WAIT_FOR_READY; } } <strong class="ph b">break</strong>; <strong class="ph b">case</strong> APP_STATE_WAIT_FOR_READY: {</p>
<p class="p"><em class="ph i">// Necessary clock settings must be done to generate</em></p>
<p class="p"><em class="ph i">// required MCLK, BCLK and LRCK</em></p>
<p class="p">DRV_I2S_BaudrateSet(handle, i2sClock, baudrate);</p>
<p class="p"><em class="ph i">/* Set the Event handler */</em> DRV_I2S_BufferEventHandlerSet(handle,App_BufferEventHandler, contextHandle);</p>
<p class="p"><em class="ph i">/* Add a buffer to write*/</em> DRV_I2S_WriteBufferAdd(handle, myAudioBuffer, BUFFER_SIZE, &amp;bufferHandle);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// Error handling here</em> } state = APP_STATE_IDLE; } <strong class="ph b">break</strong>; <strong class="ph b">case</strong> APP_STATE_WAIT_FOR_DONE: state = APP_STATE_DONE; <strong class="ph b">break</strong>; <strong class="ph b">case</strong> APP_STATE_DONE: {</p>
<p class="p"><em class="ph i">// Close done</em></p>
<p class="p">DRV_I2S_Close(handle); } <strong class="ph b">break</strong>; <strong class="ph b">case</strong> APP_STATE_IDLE: <em class="ph i">// Do nothing</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">void</strong> App_BufferEventHandler(DRV_I2S_BUFFER_EVENT event, DRV_I2S_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle) { uint8_t temp; <strong class="ph b">if</strong>(DRV_I2S_BUFFER_EVENT_COMPLETE == event) {</p>
<p class="p"><em class="ph i">// Can set state = APP_STATE_WAIT_FOR_DONE;</em></p>
<p class="p"><em class="ph i">// Take Action as needed</em> } <strong class="ph b">else</strong> <strong class="ph b">if</strong>(DRV_I2S_BUFFER_EVENT_ERROR == event) {</p>
<p class="p"><em class="ph i">// Take Action as needed</em> } <strong class="ph b">else</strong> <strong class="ph b">if</strong>(DRV_I2S_BUFFER_EVENT_ABORT == event) { <em class="ph i">// Take Action as needed</em> } <strong class="ph b">else</strong> { <em class="ph i">// Do nothing</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">void</strong> SYS_Tasks ( <strong class="ph b">void</strong> ) {</p>
<p class="p"><em class="ph i">/* Call the application's tasks routine */</em></p>
<p class="p">APP_Tasks ( );</p>
<p class="p">}</p>
</div>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title326" id="configuring-the-library-4"><h4 class="title topictitle4" id="ariaid-title326"><em class="ph i">Configuring the Library</em></h4><div class="body"><p class="p">The configuration of the I2S Driver Library is based on the file configurations.h.</p>
<p class="p">This header file contains the configuration selection for the I2S Driver Library. Based on the selections made, the I2S Driver Library may support the selected features. These configuration settings will apply to all instances of the I2S Driver Library.</p>
<p class="p">This header can be placed anywhere; however, the path of this header needs to be present in the include search path for a successful build. Refer to the Applications Help section for more details.</p>
</div>
</div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title327" id="system-configuration-4"><h3 class="title topictitle3" id="ariaid-title327">System Configuration</h3><div class="body"><p class="p">Configurations for driver instances, polled/interrupt mode, etc.</p>
</div>
<div class="topic nested3" aria-labelledby="ariaid-title328" id="configuring-mhc-3"><h4 class="title topictitle4" id="ariaid-title328"><em class="ph i">Configuring MHC</em></h4><div class="body"><p class="p">Provides examples on how to configure the MPLAB Harmony Configurator (MHC) for a specific driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">When building a new application, start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <em class="ph i">File &gt; New Project</em>. Chose the Configuration name the based on the BSP, and select the appropriate processor (such as ATSAME70Q21B).</p>
<p class="p">In MHC, under Available Components select the appropriate BSP, such as SAM E70 Xplained Ultra. Under Audio_-&gt;Templates_, double-click on a codec template such as WM8904. Answer Yes to all questions.</p>
<p class="p">You should end up with a project graph that looks like this, after rearranging the boxes:
<img class="image" src="GUID-773CF642-1091-455F-9FF2-FB072398BC6F-low.png" /><br /></p>
<p class="p">Click on the I2S Driver component, Instance 0, and the following menu will be displayed in the Configurations Options:
<img class="image" src="GUID-404447BF-96F0-4991-9CA0-F9CBE04E4890-low.png" /><br /></p>
<p class="p"><strong class="ph b">PLIB Used</strong> will display the hardware peripheral instance connected to the I2S Driver, such as SPI0, SSC, or I2SC1.</p>
<p class="p"><strong class="ph b">Number of Clients</strong> indicates the maximum number of clients that can be connected to the I2S Driver.</p>
<p class="p"><strong class="ph b">Transfer Queue Size</strong> indicates number of buffers, of each transfer queue (transmit/receive).</p>
<p class="p"><strong class="ph b">I2S Data Length</strong> is the number of bits for one channel of audio (left or right). It must match the size of the PLIB.</p>
<p class="p"><strong class="ph b">Use DMA for Transmit and Receive</strong> should always be checked if using DMA, which is currently the only supported mode.</p>
<p class="p"><strong class="ph b">Use DMA for Transmit</strong> should be checked if sending data to a codec or Bluetooth module.</p>
<p class="p"><strong class="ph b">DMA Channel for Transmit</strong> indicates the DMA channel # assigned (done automatically when you connect the PLIB).</p>
<p class="p"><strong class="ph b">Use DMA for Receive</strong> should be checked if receiving data from a codec or Bluetooth module.However if you are only writing to the I2S stream, leaving this checked won't harm anything.</p>
<p class="p"><strong class="ph b">DMA Channel for Receive</strong> indicates the DMA channel # assigned (done automatically when you connect the PLIB).</p>
<p class="p"><strong class="ph b">Included Linked List DMA Functions</strong> should be checked if using the Linked DMA feature of some MCUs.</p>
<p class="p">You can also bring in the I2S Driver by itself, by double clicking I2S under Harmony_-&gt;Drivers_ in the Available Components list. You will then need to add any additional needed components manually and connect them together.</p>
<p class="p"><strong class="ph b">Building the Library</strong></p>
<p class="p">This section lists the files that are available in the I2S Driver Library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The following three tables list and describe the header (.h) and source (.c) files that implement this library. The parent folder for these files is core/driver/i2s.</p>
</div>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title329" id="interface-files-3"><h2 class="title topictitle2" id="ariaid-title329">Interface File(s)</h2><div class="body"><p class="p">This table lists and describes the header files that must be included (i.e., using #include) by any code that uses this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><col style="width:" /><col style="width:" /><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19339"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19342"><span><strong class="ph b">Description</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19345"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19347"><span> </span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19348"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19350"><span> </span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19351"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19353"><span> </span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19339 "><span>drv_i2s.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19342 "><span>This file provides the interface definitions of audio/driver/i2s/templates/drv_i2s.h.ftl)</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19345 "><span>the</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19347 "><span>I2S</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19348 "><span>driver</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19350 "><span>(generated</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19351 "><span>via</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19353 "><span>template</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title330" id="required-files-4"><h2 class="title topictitle2" id="ariaid-title330">Required File(s)</h2><div class="body"><p class="p"><img class="image" src="GUID-B924D07A-0D74-453B-BCDE-8190A195C55D-low.png" /><br /> <strong class="ph b"><em class="ph i">All of the required files listed in the following table are automatically added into the MPLAB X IDE project by the MHC when the library is selected for use.</em></strong></p>
<p class="p">This table lists and describes the source and header files that must <em class="ph i">always</em> be included in the MPLAB X IDE project to build this library.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19393"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19396"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19393 "><span>/src/drv_i2s.c</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19396 "><span>This file contains the core implementation of the I2S driver with DMA support (generated via template audio/driver/i2s/templates/drv_i2s.c.ftl)</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title331" id="optional-files-4"><h2 class="title topictitle2" id="ariaid-title331">Optional File(s)</h2><div class="body"><p class="p">This table lists and describes the source and header files that may optionally be included if required for the desired implementation.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19417"><span><strong class="ph b">Source File Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19420"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19417 "><span>N/A</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19420 "><span>-</span></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title332" id="module-dependencies-4"><h2 class="title topictitle2" id="ariaid-title332">Module Dependencies</h2><div class="body"><p class="p">The I2S Driver Library depends on the following modules:</p>
<ul class="ul"><li class="li"><p class="p">I2S Peripheral Library, <em class="ph i">or</em></p>
</li>
<li class="li"><p class="p">SSC Peripheral Library</p>
</li>
<li class="li"><p class="p">I2SC Peripheral Library</p>
</li>
</ul>
<p class="p"><strong class="ph b">Library Interface</strong></p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">System Interaction Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19462"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19464"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19467"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19464 "><span>DRV_I2S_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19467 "><span>Initializes the I2S instance for the specified driver index.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19462 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19464 "><span>DRV_I2S_Status</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19467 "><span>Gets the current status of the I2S driver module.</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Client Setup Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19497"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19499"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19502"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19497 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19499 "><span>DRV_I2S_Open</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19502 "><span>Opens the specified I2S driver instance and returns a handle to it.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19497 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19499 "><span>DRV_I2S_Close</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19502 "><span>Closes an opened-instance of the I2S driver.</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Data Transfer Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19532"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19534"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19537"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_ReadBufferAdd</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Queues a read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_WriteBufferAdd</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Queues a write operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_WriteReadBufferAdd</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Queues a write/read operation.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_BufferEventHandlerSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_ReadQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Removes all buffer requests from the read queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_WriteQueuePurge</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Removes all buffer requests from the write queue.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_BufferStatusGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Returns the transmit/receive request status.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19532 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19534 "><span>DRV_I2S_BufferCompletedBytesGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19537 "><span>Returns the number of bytes that have been processed for the specified buffer request.</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Miscellaneous Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19609"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19611"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19614"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19609 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19611 "><span>DRV_I2S_ErrorGet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19614 "><span>Gets the I2S hardware errors associated with the client.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19609 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19611 "><span>DRV_I2S_LRCLK_Sync</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19614 "><span>Synchronize to the start of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19609 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19611 "><span>DRV_I2S_SerialSetup</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19614 "><span>Sets the I2S serial communication settings dynamically.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19609 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19611 "><span>DRV_I2S_ClockGenerationSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19614 "><span>Set the clock(PLLA and I2SC GCLK clock) generation values</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19609 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19611 "><span>DRV_I2S_ProgrammableClockSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19614 "><span>Set the Programmable Clock</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Data Types and Constants</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19666"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19668"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19671"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19666 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19668 "><span>DRV_I2S_BUFFER_EVENT</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19671 "><span>Identifies the possible events that can result from a buffer add request.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19666 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19668 "><span>DRV_I2S_BUFFER_EVENT_HANDLER</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19671 "><span>Pointer to a I2S Driver Buffer Event handler function</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19666 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19668 "><span>DRV_I2S_BUFFER_HANDLE</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19671 "><span>Handle identifying a read or write buffer passed to the driver.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19666 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19668 "><span>DRV_I2S_SERIAL_SETUP</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19671 "><span>Defines the data required to dynamically set the serial settings.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19666 "><span>-</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19668 "><span>DRV_I2S_BUFFER_HANDLE_INVALID</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19671 "><span>Definition of an invalid buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This section describes the Application Programming Interface (API) functions of the I2S Driver Library.</p>
<p class="p">Refer to each section for a detailed description.</p>
<p class="p"><strong class="ph b"><em class="ph i">a) System Interaction Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title333" id="drv-i2s-initialize-function"><h2 class="title topictitle2" id="ariaid-title333">DRV_I2S_Initialize Function</h2><div class="body"><p class="p">SYS_MODULE_OBJ DRV_I2S_Initialize</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes the I2S instance for the specified driver index.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine initializes the I2S driver instance for the specified driver index, making it ready for clients to open and use it. The initialization data is specified by the init parameter. The initialization may fail if the number of driver objects allocated are insufficient or if the specified driver instance is already initialized. The driver instance index is independent of the I2S module ID. For example, driver instance 0 can be assigned to I2S2.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19758"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19761"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19758 "><span>index</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19761 "><span>Identifier for the instance to be initialized</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19758 "><span>init</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19761 "><span>Pointer to the init data structure containing any data necessary to initialize the driver.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, returns a valid handle to a driver instance object. Otherwise, returns SYS_MODULE_OBJ_INVALID.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This routine must be called before any other I2S routine is called.</p>
<p class="p">This routine should only be called once during system initialization. This routine will NEVER block for hardware access.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// The following code snippet shows an example I2S driver initialization.</em></p>
<p class="p">SYS_MODULE_OBJ objectHandle;</p>
<p class="p">I2S_PLIB_API drvUsart0PlibAPI = {</p>
<p class="p">{ .readCallbackRegister = I2S1_ReadCallbackRegister,</p>
<p class="p">.read = I2S1_Read,</p>
<p class="p">.readIsBusy = I2S1_ReadIsBusy,</p>
<p class="p">.readCountGet = I2S1_ReadCountGet, .writeCallbackRegister = I2S1_WriteCallbackRegister,</p>
<p class="p">.write = I2S1_Write,</p>
<p class="p">.writeIsBusy = I2S1_WriteIsBusy,</p>
<p class="p">.writeCountGet = I2S1_WriteCountGet,</p>
<p class="p">.errorGet = I2S1_ErrorGet</p>
<p class="p">}</p>
<p class="p">};</p>
<p class="p">DRV_I2S_INIT drvUsart0InitData =</p>
<p class="p">{</p>
<p class="p">.i2sPlib = &amp;drvUsart0PlibAPI,</p>
<p class="p">.interruptI2S = I2S1_IRQn,</p>
<p class="p">.queueSizeTransmit = DRV_I2S_XMIT_QUEUE_SIZE_IDX0,</p>
<p class="p">.queueSizeReceive = DRV_I2S_RCV_QUEUE_SIZE_IDX0,</p>
<p class="p">.dmaChannelTransmit = SYS_DMA_CHANNEL_NONE,</p>
<p class="p">.dmaChannelReceive = SYS_DMA_CHANNEL_NONE,</p>
<p class="p">.i2sTransmitAddress = I2S1_TRANSMIT_ADDRESS,</p>
<p class="p">.i2sReceiveAddress = I2S1_RECEIVE_ADDRESS,</p>
<p class="p">.interruptDMA = XDMAC_IRQn</p>
<p class="p">}; objectHandle = DRV_I2S_Initialize(DRV_I2S_INDEX_1, (SYS_MODULE_INIT*)&amp;drvUsart0InitData); <strong class="ph b">if</strong> (SYS_MODULE_OBJ_INVALID == objectHandle) {</p>
<p class="p"><em class="ph i">// Handle error</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_MODULE_OBJ <strong class="ph b">DRV_I2S_Initialize</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">index</strong>, <strong class="ph b">const</strong> SYS_MODULE_INIT * <strong class="ph b">const</strong> <strong class="ph b">init</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title334" id="drv-i2s-status-function"><h2 class="title topictitle2" id="ariaid-title334">DRV_I2S_Status Function</h2><div class="body"><p class="p">SYS_STATUS DRV_I2S_Status( SYS_MODULE_OBJ object )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the current status of the I2S driver module.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine provides the current status of the I2S driver module.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_I2S_Initialize should have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19906"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e19909"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19906 "><span>object</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e19909 "><span>Driver object handle, returned from the DRV_I2S_Initialize routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">SYS_STATUS_READY - Initialization have succeeded and the I2S is ready for additional operations</p>
<p class="p">SYS_STATUS_DEINITIALIZED - Indicates that the driver has been deinitialized</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">A driver can opened only when its status is SYS_STATUS_READY.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SYS_MODULE_OBJ object; <em class="ph i">// Returned from DRV_I2S_Initialize</em></p>
<p class="p">SYS_STATUS i2sStatus; i2sStatus = DRV_I2S _Status(object); <strong class="ph b">if</strong> (SYS_STATUS_READY == i2sStatus) {</p>
<p class="p"><em class="ph i">// This means the driver can be opened using the</em> <em class="ph i">// DRV_I2S_Open() function.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">SYS_STATUS <strong class="ph b">DRV_I2S_Status</strong>(SYS_MODULE_OBJ <strong class="ph b">object</strong>);</p>
<p class="p"><strong class="ph b"><em class="ph i">b) Client Setup Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title335" id="drv-i2s-open-function"><h2 class="title topictitle2" id="ariaid-title335">DRV_I2S_Open Function</h2><div class="body"><p class="p">DRV_HANDLE DRV_I2S_Open</p>
<p class="p">(</p>
<p class="p">const SYS_MODULE_INDEX index, const DRV_IO_INTENT ioIntent</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Opens the specified I2S driver instance and returns a handle to it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine opens the specified I2S driver instance and provides a handle that must be provided to all other client-level operations to identify the caller and the instance of the driver. The ioIntent parameter defines how the client interacts with this driver instance.</p>
<p class="p">Specifying a DRV_IO_INTENT_EXCLUSIVE will cause the driver to provide exclusive access to this client. The driver cannot be opened by any other client.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">Function DRV_I2S_Initialize must have been called before calling this function.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20005"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20008"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20005 "><span>index</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20008 "><span>Identifier for the object instance to be opened</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20005 "><span>intent</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20008 "><span>Zero or more of the values from the enumeration DRV_IO_INTENT "ORed" together to indicate the intended useof the driver. See function description for details.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">If successful, the routine returns a valid open-instance handle (a number identifying both the caller and the module instance).</p>
<p class="p">If an error occurs, the return value is DRV_HANDLE_INVALID. Error can occur</p>
<ul class="ul"><li class="li"><p class="p">if the number of client objects allocated via DRV_I2S_CLIENTS_NUMBER is insufficient.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver but driver has been opened exclusively by another client.</p>
</li>
<li class="li"><p class="p">if the driver peripheral instance being opened is not initialized or is invalid.</p>
</li>
<li class="li"><p class="p">if the client is trying to open the driver exclusively, but has already been opened in a non exclusive mode by another client.</p>
</li>
<li class="li"><p class="p">if the driver is not ready to be opened, typically when the initialize routine has not completed execution.</p>
</li>
</ul>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">The handle returned is valid until the DRV_I2S_Close routine is called. This routine will NEVER block waiting for hardware. If the requested intent flags are not supported, the routine will return DRV_HANDLE_INVALID. This function is thread safe in a RTOS application.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">DRV_HANDLE handle; handle = DRV_I2S_Open(DRV_I2S_INDEX_0, DRV_IO_INTENT_EXCLUSIVE); <strong class="ph b">if</strong> (DRV_HANDLE_INVALID == handle) {</p>
<p class="p"><em class="ph i">// Unable to open the driver</em></p>
<p class="p"><em class="ph i">// May be the driver is not initialized or the initialization</em> <em class="ph i">// is not complete.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_HANDLE <strong class="ph b">DRV_I2S_Open</strong>(<strong class="ph b">const</strong> SYS_MODULE_INDEX <strong class="ph b">index</strong>, <strong class="ph b">const</strong> DRV_IO_INTENT <strong class="ph b">ioIntent</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title336" id="drv-i2s-close-function"><h2 class="title topictitle2" id="ariaid-title336">DRV_I2S_Close Function</h2><div class="body"><p class="p">void DRV_I2S_Close( DRV_Handle handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Closes an opened-instance of the I2S driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This routine closes an opened-instance of the I2S driver, invalidating the handle. Any buffers in the driver queue that were submitted by this client will be removed. A new handle must be obtained by calling DRV_I2S_Open before the caller may use the driver again.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20120"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20123"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20120 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20123 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// 'handle', returned from the DRV_I2S_Open</em></p>
<p class="p">DRV_I2S_Close(handle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_I2S_Close</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
<p class="p"><strong class="ph b"><em class="ph i">c) Data Transfer Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title337" id="drv-i2s-readbufferadd-function"><h2 class="title topictitle2" id="ariaid-title337">DRV_I2S_ReadBufferAdd Function</h2><div class="body"><p class="p">void DRV_I2S_ReadBufferAdd</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">void * buffer, const size_t size,</p>
<p class="p">DRV_I2S_BUFFER_HANDLE * bufferHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Queues a read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking read operation. The function returns with a valid buffer handle in the bufferHandle argument if the read request was scheduled successfully. The function adds the request to the hardware instance receive queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_I2S_BUFFER_HANDLE_INVALID in the bufferHandle argument:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the read queue size is full or queue depth is insufficient.</p>
</li>
<li class="li"><p class="p">if the driver handle is invalid</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_I2S_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_I2S_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20232"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20235"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20232 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20235 "><span>Handle of the communication channel as returned by the DRV_I2S_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20232 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20235 "><span>Buffer where the received data will be stored.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20232 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20235 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20232 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20235 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The buffer handle is returned in the bufferHandle argument. This is DRV_I2S_BUFFER_HANDLE_INVALID if the request was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the I2S Driver Buffer Event Handler that is registered by the client. It should not be called in the event handler associated with another I2S driver instance. It should not be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_I2S_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned // by the DRV_I2S_Open function.</em></p>
<p class="p">DRV_I2S_ReadBufferAdd(myI2Shandle, myBuffer, MY_BUFFER_SIZE,</p>
<p class="p">&amp;bufferHandle);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle) { <em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when the buffer is processed.</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_I2S_ReadBufferAdd</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, <strong class="ph b">const</strong> size_t <strong class="ph b">size</strong>, DRV_I2S_BUFFER_HANDLE * <strong class="ph b">const</strong> <strong class="ph b">bufferHandle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title338" id="drv-i2s-writebufferadd-function"><h2 class="title topictitle2" id="ariaid-title338">DRV_I2S_WriteBufferAdd Function</h2><div class="body"><p class="p">void DRV_I2S_WriteBufferAdd</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">void * buffer, size_t size,</p>
<p class="p">DRV_I2S_BUFFER_HANDLE * bufferHandle</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Queues a write operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write operation. The function returns with a valid buffer handle in the bufferHandle argument if the write request was scheduled successfully. The function adds the request to the driver instance transmit queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. On returning, the bufferHandle parameter may be DRV_I2S_BUFFER_HANDLE_INVALID for the following reasons:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read-only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the transmit queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_I2S_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully or a DRV_I2S_BUFFER_EVENT_ERROR event if the buffer was not processed successfully. <strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20393"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20396"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20393 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20396 "><span>Handle of the communication channel as return by the DRV_I2S_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20393 "><span>buffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20396 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20393 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20396 "><span>Buffer size in bytes.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20393 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20396 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_I2S_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the I2S Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another I2S driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_I2S_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned // by the DRV_I2S_Open function.</em></p>
<p class="p">DRV_I2S_WriteBufferAdd(myI2Shandle, myBuffer, MY_BUFFER_SIZE,</p>
<p class="p">&amp;bufferHandle);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_I2S_WriteBufferAdd</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">buffer</strong>, <strong class="ph b">const</strong> size_t <strong class="ph b">size</strong>, DRV_I2S_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title339" id="drv-i2s-writereadbufferadd-function"><h2 class="title topictitle2" id="ariaid-title339">DRV_I2S_WriteReadBufferAdd Function</h2><div class="body"><p class="p">void DRV_I2S_BufferAddWriteRead(const DRV_HANDLE handle, void *transmitBuffer, void *receiveBuffer,</p>
<p class="p">size_t size, DRV_I2S_BUFFER_HANDLE *bufferHandle)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Queues a write/read operation.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function schedules a non-blocking write-read operation. The function returns with a valid buffer handle in the bufferHandle argument if the write-read request was scheduled successfully. The function adds the request to the hardware instance queue and returns immediately. While the request is in the queue, the application buffer is owned by the driver and should not be modified. The function returns DRV_I2S_BUFFER_HANDLE_INVALID:</p>
<ul class="ul"><li class="li"><p class="p">if a buffer could not be allocated to the request</p>
</li>
<li class="li"><p class="p">if the input buffer pointer is NULL</p>
</li>
<li class="li"><p class="p">if the client opened the driver for read only or write only</p>
</li>
<li class="li"><p class="p">if the buffer size is 0</p>
</li>
<li class="li"><p class="p">if the queue is full or the queue depth is insufficient</p>
</li>
</ul>
<p class="p">If the requesting client registered an event callback with the driver, the driver will issue a</p>
<p class="p">DRV_I2S_BUFFER_EVENT_COMPLETE event if the buffer was processed successfully of DRV_I2S_BUFFER_EVENT_ERROR event if the buffer was not processed successfully.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20545"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20548"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20545 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20548 "><span>Handle of the communication channel as return by the DRV_I2S_Open function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20545 "><span>transmitBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20548 "><span>Data to be transmitted.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20545 "><span>receiveBuffer</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20548 "><span>Will hold data that is received.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20545 "><span>size</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20548 "><span>Buffer size in bytes (same for both buffers)</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20545 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20548 "><span>Pointer to an argument that will contain the return buffer handle.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The bufferHandle parameter will contain the return buffer handle. This will be DRV_I2S_BUFFER_HANDLE_INVALID if the function was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe in a RTOS application. It can be called from within the I2S Driver Buffer Event Handler that is registered by this client. It should not be called in the event handler associated with another I2S driver instance. It should not otherwise be called directly in an ISR.</p>
<p class="p">This function is useful when there is valid read expected for every I2S write. The transmit and receive size must be same.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_I2S_WriteReadBufferAdd</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">void</strong> * <strong class="ph b">transmitBuffer</strong>, <strong class="ph b">void</strong> * <strong class="ph b">receiveBuffer</strong>, size_t <strong class="ph b">size</strong>, DRV_I2S_BUFFER_HANDLE * <strong class="ph b">bufferHandle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title340" id="drv-i2s-buffereventhandlerset-function"><h2 class="title topictitle2" id="ariaid-title340">DRV_I2S_BufferEventHandlerSet Function</h2><div class="body"><p class="p">void DRV_I2S_BufferEventHandlerSet</p>
<p class="p">(</p>
<p class="p">const DRV_HANDLE handle,</p>
<p class="p">const DRV_I2S_BUFFER_EVENT_HANDLER eventHandler, const uintptr_t context</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Allows a client to identify a buffer event handling function for the driver to call back when queued buffer transfers have finished.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function allows a client to register a buffer event handling function with the driver to call back when queued buffer transfers have finished. When a client calls either the DRV_I2S_ReadBufferAdd or DRV_I2S_WriteBufferAdd function, it is provided with a handle identifying the buffer that was added to the driver's buffer queue. The driver will pass this handle back to the client by calling "eventHandler" function when the buffer transfer has completed.</p>
<p class="p">The event handler should be set before the client performs any "buffer add" operations that could generate events. The event handler once set, persists until the client closes the driver or sets another event handler (which could be a "NULL" pointer to indicate no callback).</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20666"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20669"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20666 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20669 "><span>A valid open-instance handle, returned from the driver's open routine.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20666 "><span>eventHandler</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20669 "><span>Pointer to the event handler function.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20666 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20669 "><span>The value of parameter will be passed back to the client unchanged, when the eventHandler function is called. It can be used to identify any client specific data object that identifies the instance of the client module (for example, it may be a pointer to the client module's state structure).</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the client does not want to be notified when the queued buffer transfer has completed, it does not need to register a callback. This function is thread safe when called in a RTOS application.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific state data object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_I2S_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned // by the DRV_I2S_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver. This is done once</em></p>
<p class="p">DRV_I2S_BufferEventHandlerSet( myI2SHandle, APP_I2SBufferEventHandler,</p>
<p class="p">(uintptr_t)&amp;myAppObj );</p>
<p class="p">DRV_I2S_ReadBufferAdd(myI2Shandle, myBuffer, MY_BUFFER_SIZE,</p>
<p class="p">&amp;bufferHandle);</p>
<p class="p"><strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event is received when the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_I2SBufferEventHandler(DRV_I2S_BUFFER_EVENT event, DRV_I2S_BUFFER_HANDLE handle, uintptr_t context)</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// The context handle was set to an application specific</em> <em class="ph i">// object. It is now retrievable easily in the event handler.</em></p>
<p class="p">MY_APP_OBJ myAppObj = (MY_APP_OBJ *) context; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em> <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">DRV_I2S_BufferEventHandlerSet</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> DRV_I2S_BUFFER_EVENT_HANDLER <strong class="ph b">eventHandler</strong>, <strong class="ph b">const</strong> uintptr_t <strong class="ph b">context</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title341" id="drv-i2s-readqueuepurge-function"><h2 class="title topictitle2" id="ariaid-title341">DRV_I2S_ReadQueuePurge Function</h2><div class="body"><p class="p">bool DRV_I2S_ReadQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the read queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the read queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20842"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20845"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20842 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20845 "><span>Handle of the communication channel as returned by the DRV_I2S_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Read queue purge is successful. False - Read queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned by the DRV_I2S_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_I2S_ReadBufferAdd to queue read requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em> <strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) { <strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_I2S_ReadQueuePurge(myI2Shandle)) { <em class="ph i">//Couldn't purge the read queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_ReadQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title342" id="drv-i2s-writequeuepurge-function"><h2 class="title topictitle2" id="ariaid-title342">DRV_I2S_WriteQueuePurge Function</h2><div class="body"><p class="p">bool DRV_I2S_WriteQueuePurge( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Removes all buffer requests from the write queue.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function removes all the buffer requests from the write queue. The client can use this function to purge the queue on timeout or to remove unwanted stalled buffer requests or in any other use case.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20949"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e20952"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20949 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e20952 "><span>Handle of the communication channel as returned by the DRV_I2S_Open function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">True - Write queue purge is successful. False - Write queue purge has failed.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is thread safe when used in an RTOS environment. Avoid this function call from within the callback.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned by the DRV_I2S_Open function.</em></p>
<p class="p"><em class="ph i">// Use DRV_I2S_WriteBufferAdd to queue write requests</em></p>
<p class="p"><em class="ph i">// Application timeout function, where remove queued buffers.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_TimeOut(<strong class="ph b">void</strong>) {</p>
<p class="p"><strong class="ph b">if</strong>(<strong class="ph b">false</strong> == DRV_I2S_WriteQueuePurge(myI2Shandle)) { <em class="ph i">//Couldn't purge the write queue, try again.</em> } <strong class="ph b">else</strong> { <em class="ph i">//Queue purge successful.</em></p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_WriteQueuePurge</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title343" id="drv-i2s-bufferstatusget-function"><h2 class="title topictitle2" id="ariaid-title343">DRV_I2S_BufferStatusGet Function</h2><div class="body"><p class="p">DRV_I2S_BUFFER_EVENT DRV_I2S_BufferStatusGet</p>
<p class="p">(</p>
<p class="p">const DRV_I2S_BUFFER_HANDLE bufferHandle</p>
<p class="p">)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Returns the transmit/receive request status.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function can be used to poll the status of the queued buffer request if the application doesn't prefer to use the event handler (callback) function to get notified.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">Either the DRV_I2S_ReadBufferAdd or DRV_I2S_WriteBufferAdd function must have been called and a valid buffer handle returned.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21066"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21069"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21066 "><span>bufferhandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21069 "><span>Handle for the buffer of which the processed number of bytes to be obtained.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">The success or error event of the buffer.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function returns error event if the buffer handle is invalid.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em></p>
<p class="p">MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_I2S_BUFFER_HANDLE bufferHandle;</p>
<p class="p">DRV_I2S_BUFFER_EVENT event;</p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned</em> <em class="ph i">// by the DRV_I2S_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver. This is done once</em></p>
<p class="p">DRV_I2S_BufferEventHandlerSet( myI2SHandle, APP_I2SBufferEventHandle,</p>
<p class="p">(uintptr_t)&amp;myAppObj );</p>
<p class="p">DRV_I2S_ReadBufferAdd( myI2Shandle, myBuffer, MY_BUFFER_SIZE, bufferHandle); <strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle) {</p>
<p class="p"><em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">//Check the status of the buffer</em> <em class="ph i">//This call can be used to wait until the buffer is processed.</em></p>
<p class="p">event = DRV_I2S_BufferStatusGet(bufferHandle);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_I2S_BUFFER_EVENT <strong class="ph b">DRV_I2S_BufferStatusGet</strong>(<strong class="ph b">const</strong> DRV_I2S_BUFFER_HANDLE <strong class="ph b">bufferHandle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title344" id="drv-i2s-buffercompletedbytesget-function"><h2 class="title topictitle2" id="ariaid-title344">DRV_I2S_BufferCompletedBytesGet Function</h2><div class="body"><p class="p">size_t DRV_I2S_BufferCompletedBytesGet</p>
<p class="p">(</p>
<p class="p">DRV_I2S_BUFFER_HANDLE bufferHandle</p>
<p class="p">);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Returns the number of bytes that have been processed for the specified buffer request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The client can use this function, in a case where the buffer is terminated due to an error, to obtain the number of bytes that have been processed. Or in any other use case. This function can be used for non-DMA buffer transfers only. It cannot be used when the I2S driver is configured to use DMA.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p">Either the DRV_I2S_ReadBufferAdd or DRV_I2S_WriteBufferAdd function must have been called and a valid buffer handle returned.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21188"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21191"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21188 "><span>bufferhandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21191 "><span>Handle for the buffer of which the processed number of bytes to be obtained.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Returns the number of bytes that have been processed for this buffer.</p>
<p class="p">Returns DRV_I2S_BUFFER_HANDLE_INVALID for an invalid or an expired buffer handle.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function is expected to work in non-DMA mode only. This function is thread safe when used in a RTOS application. If called from the callback, it must not call an OSAL mutex or critical section.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myAppObj is an application specific object.</em> MY_APP_OBJ myAppObj;</p>
<p class="p">uint8_t mybuffer<span class="xref"></span>; DRV_I2S_BUFFER_HANDLE bufferHandle;</p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned // by the DRV_I2S_Open function.</em></p>
<p class="p"><em class="ph i">// Client registers an event handler with driver. This is done once</em></p>
<p class="p">DRV_I2S_BufferEventHandlerSet( myI2SHandle, APP_I2SBufferEventHandle,</p>
<p class="p">(uintptr_t)&amp;myAppObj );</p>
<p class="p">DRV_I2S_ReadBufferAdd( myI2Shandle, myBuffer, MY_BUFFER_SIZE, bufferHandle); <strong class="ph b">if</strong>(DRV_I2S_BUFFER_HANDLE_INVALID == bufferHandle) { <em class="ph i">// Error handling here</em></p>
<p class="p">}</p>
<p class="p"><em class="ph i">// Event Processing Technique. Event is received when // the buffer is processed.</em></p>
<p class="p"><strong class="ph b">void</strong> APP_I2SBufferEventHandler( DRV_I2S_BUFFER_EVENT event, DRV_I2S_BUFFER_HANDLE bufferHandle, uintptr_t contextHandle )</p>
<p class="p">{</p>
<p class="p"><em class="ph i">// The context handle was set to an application specific</em> <em class="ph i">// object. It is now retrievable easily in the event handler.</em> MY_APP_OBJ myAppObj = (MY_APP_OBJ *) contextHandle; size_t processedBytes; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_COMPLETE: <em class="ph i">// This means the data was transferred.</em> <strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_ERROR: <em class="ph i">// Error handling here.</em></p>
<p class="p"><em class="ph i">// We can find out how many bytes have been processed in this</em> <em class="ph i">// buffer request prior to the error.</em></p>
<p class="p">processedBytes= DRV_I2S_BufferCompletedBytesGet(bufferHandle); <strong class="ph b">break</strong>; <strong class="ph b">default</strong>: <strong class="ph b">break</strong>; }</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">size_t <strong class="ph b">DRV_I2S_BufferCompletedBytesGet</strong>(DRV_I2S_BUFFER_HANDLE <strong class="ph b">bufferHandle</strong>);</p>
<p class="p"><strong class="ph b"><em class="ph i">d) Miscellaneous Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title345" id="drv-i2s-errorget-function"><h2 class="title topictitle2" id="ariaid-title345">DRV_I2S_ErrorGet Function</h2><div class="body"><p class="p">DRV_I2S_ERROR DRV_I2S_ErrorGet( const DRV_HANDLE handle )</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Gets the I2S hardware errors associated with the client.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function returns the errors associated with the given client. The call to this function also clears all the associated error flags.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21343"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21346"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21343 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21346 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">Errors occurred as listed by DRV_I2S_ERROR. This function reports multiple I2S errors if occurred.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">I2S errors are normally associated with the receiver. The driver clears all the errors internally and only returns the occurred error information for the client.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// 'handle', returned from the DRV_I2S_Open</em> <strong class="ph b">if</strong> (DRV_I2S_ERROR_OVERRUN &amp; DRV_I2S_ErrorGet(handle)) {</p>
<p class="p"><em class="ph i">//Errors are cleared by the driver, take respective action</em> <em class="ph i">//for the overrun error case.</em></p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">DRV_I2S_ERROR <strong class="ph b">DRV_I2S_ErrorGet</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title346" id="drv-i2s-lrclk-sync-function"><h2 class="title topictitle2" id="ariaid-title346">DRV_I2S_LRCLK_Sync Function</h2><div class="body"><p class="p">uint32_t DRV_I2S_LRCLK_Sync (const DRV_HANDLE handle, const uint32_t sample_rate);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Synchronize to the start of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function waits until low-tohigh transition of the I2S LRCLK (left/right clock) signal (high-low if Left-Jusitified format, this is determined by the PLIB). In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize calls to the DMA with the LRCLK signal so the left/right channel association is valid.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned</em> <em class="ph i">// by the DRV_I2S_Open function.</em></p>
<p class="p">DRV_I2S_LRCLK_Sync(myI2SHandle, 48000);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_LRCLK_Sync</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, <strong class="ph b">const</strong> uint32_t <strong class="ph b">sample_rate</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title347" id="drv-i2s-serialsetup-function"><h2 class="title topictitle2" id="ariaid-title347">DRV_I2S_SerialSetup Function</h2><div class="body"><p class="p">bool DRV_I2S_SerialSetup(const DRV_HANDLE handle,</p>
<p class="p">DRV_I2S_SERIAL_SETUP * setup)</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Sets the I2S serial communication settings dynamically.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function sets the I2S serial communication settings dynamically.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">DRV_I2S_Open must have been called to obtain a valid opened device handle. The I2S transmit or receive transfer status should not be busy.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21495"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21498"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21495 "><span>handle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21498 "><span>A valid open-instance handle, returned from the driver's open routine</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21495 "><span>setup</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21498 "><span>Pointer to the structure containing the serial setup.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true - Serial setup was updated successfully. false - Failure while updating serial setup.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// 'handle', returned from the DRV_I2S_Open</em></p>
<p class="p">DRV_I2S_SERIAL_SETUP setup = {</p>
<p class="p">115200,</p>
<p class="p">DRV_I2S_DATA_8_BIT,</p>
<p class="p">DRV_I2S_PARITY_ODD,</p>
<p class="p">DRV_I2S_STOP_1_BIT</p>
<p class="p">};</p>
<p class="p">DRV_I2S_SerialSetup(handle, &amp;setup);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_SerialSetup</strong>(<strong class="ph b">const</strong> DRV_HANDLE <strong class="ph b">handle</strong>, DRV_I2S_SERIAL_SETUP * <strong class="ph b">setup</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title348" id="drv-i2s-clockgenerationset-function"><h2 class="title topictitle2" id="ariaid-title348">DRV_I2S_ClockGenerationSet Function</h2><div class="body"><p class="p">bool DRV_I2S_ClockGenerationSet(DRV_HANDLE handle, uint8_t div, uint8_t mul, uint8_t div2);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Set the clock(PLLA and I2SC GCLK clock) generation values</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Set the clock(PLLA and I2SC GCLK clock) generation values</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned</em> <em class="ph i">// by the DRV_I2S_Open function.</em></p>
<p class="p">DRV_I2S_ClockGenerationSet(myI2SHandle, 2, 40, 5);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_ClockGenerationSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint8_t <strong class="ph b">div</strong>, uint8_t <strong class="ph b">mul</strong>, uint8_t <strong class="ph b">div2</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title349" id="drv-i2s-programmableclockset-function"><h2 class="title topictitle2" id="ariaid-title349">DRV_I2S_ProgrammableClockSet Function</h2><div class="body"><p class="p">bool DRV_I2S_ProgrammableClockSet(DRV_HANDLE handle, uint8_t pClkNum, uint8_t div2);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Set the Programmable Clock</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Set the Programmable Clock ignoring glitch control</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">true if the function was successful, false if a timeout occurred (no transitions seen)</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><em class="ph i">// myI2SHandle is the handle returned</em> <em class="ph i">// by the DRV_I2S_Open function.</em></p>
<p class="p">DRV_I2S_ProgrammableClockSet(myI2SHandle, 2, 7);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">bool</strong> <strong class="ph b">DRV_I2S_ProgrammableClockSet</strong>(DRV_HANDLE <strong class="ph b">handle</strong>, uint8_t <strong class="ph b">pClkNum</strong>, uint8_t <strong class="ph b">div2</strong>);</p>
<p class="p"><strong class="ph b"><em class="ph i">e) Data Types and Constants</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title350" id="drv-i2s-buffer-event-enumeration"><h2 class="title topictitle2" id="ariaid-title350">DRV_I2S_BUFFER_EVENT Enumeration</h2><div class="body"><p class="p">Identifies the possible events that can result from a buffer add request.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Buffer Events</p>
<p class="p">This enumeration identifies the possible events that can result from a buffer add request caused by the client calling either the DRV_I2S_ReadBufferAdd or DRV_I2S_WriteBufferAdd functions.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">One of these values is passed in the "event" parameter of the event handling callback function that the client registered with the driver by calling the DRV_I2S_BufferEventHandlerSet function when a buffer transfer request is completed.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">enum</strong> { <strong class="ph b">DRV_I2S_BUFFER_EVENT_COMPLETE</strong>,</p>
<p class="p"><strong class="ph b">DRV_I2S_BUFFER_EVENT_ERROR</strong>,</p>
<p class="p"><strong class="ph b">DRV_I2S_BUFFER_EVENT_ABORT</strong></p>
<p class="p">} DRV_I2S_BUFFER_EVENT;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title351" id="drv-i2s-buffer-event-handler-type"><h2 class="title topictitle2" id="ariaid-title351">DRV_I2S_BUFFER_EVENT_HANDLER Type</h2><div class="body"><p class="p">Pointer to a I2S Driver Buffer Event handler function</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Buffer Event Handler Function Pointer</p>
<p class="p">This data type defines the required function signature for the I2S driver buffer event handling callback function. A client must register a pointer using the buffer event handling function whose function signature (parameter and return value types) match the types specified by this function pointer in order to receive buffer related event calls back from the driver.</p>
<p class="p">The parameters and return values are described here and a partial example implementation is provided.</p>
<p class="p"><strong class="ph b">Parameters</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21759"><span><strong class="ph b">Parameters</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21762"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21759 "><span>event</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21762 "><span>Identifies the type of event</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21759 "><span>bufferHandle</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21762 "><span>Handle identifying the buffer to which the vent relates</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21759 "><span>context</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21762 "><span>Value identifying the context of the application that registered the event handling function.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">If the event is DRV_I2S_BUFFER_EVENT_COMPLETE, it means that the data was transferred successfully.</p>
<p class="p">If the event is DRV_I2S_BUFFER_EVENT_ERROR, it means that the data was not transferred successfully. The DRV_I2S_BufferCompletedBytesGet function can be called to find out how many bytes were processed.</p>
<p class="p">The bufferHandle parameter contains the buffer handle of the buffer that associated with the event. And bufferHandle will be valid while the buffer request is in the queue and during callback, unless an error occurred. After callback returns, the driver will retire the buffer handle.</p>
<p class="p">The context parameter contains the a handle to the client context, provided at the time the event handling function was registered using the DRV_I2S_BufferEventHandlerSet function. This context handle value is passed back to the client as the "context" parameter. It can be any value necessary to identify the client context or instance (such as a pointer to the client's data) instance of the client that made the buffer add request.</p>
<p class="p">The event handler function executes in the peripheral's interrupt context when the driver is configured for interrupt mode operation. It is recommended of the application to not perform process intensive or blocking operations with in this function.</p>
<p class="p">The DRV_I2S_ReadBufferAdd and DRV_I2S_WriteBufferAdd functions can be called in the event handler to add a buffer to the driver queue. These functions can only be called to add buffers to the driver whose event handler is running. For example, I2S2 driver buffers cannot be added in I2S1 driver event handler.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p"><strong class="ph b">void</strong> APP_MyBufferEventHandler( DRV_I2S_BUFFER_EVENT event, DRV_I2S_BUFFER_HANDLE bufferHandle, uintptr_t context ) {</p>
<p class="p">MY_APP_DATA_STRUCT pAppData = (MY_APP_DATA_STRUCT) context; <strong class="ph b">switch</strong>(event) { <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_COMPLETE: <em class="ph i">// Handle the completed buffer.</em></p>
<p class="p"><strong class="ph b">break</strong>; <strong class="ph b">case</strong> DRV_I2S_BUFFER_EVENT_ERROR:</p>
<p class="p"><strong class="ph b">default</strong>: <em class="ph i">// Handle error.</em></p>
<p class="p"><strong class="ph b">break</strong>;</p>
<p class="p">Files</p>
<p class="p">}</p>
<p class="p">}</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">void</strong> (* <strong class="ph b">DRV_I2S_BUFFER_EVENT_HANDLER</strong>)(DRV_I2S_BUFFER_EVENT event, DRV_I2S_BUFFER_HANDLE bufferHandle, uintptr_t context);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title352" id="drv-i2s-buffer-handle-type"><h2 class="title topictitle2" id="ariaid-title352">DRV_I2S_BUFFER_HANDLE Type</h2><div class="body"><p class="p">Handle identifying a read or write buffer passed to the driver.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Buffer Handle</p>
<p class="p">A buffer handle value is returned by a call to the DRV_I2S_ReadBufferAdd or DRV_I2S_WriteBufferAdd functions. This handle is associated with the buffer passed into the function and it allows the application to track the completion of the data from (or into) that buffer. The buffer handle value returned from the "buffer add" function is returned back to the client by the "event handler callback" function registered with the driver.</p>
<p class="p">The buffer handle assigned to a client request expires when the client has been notified of the completion of the buffer transfer (after event handler function that notifies the client returns) or after the buffer has been retired by the driver if no event handler callback was set.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> uintptr_t <strong class="ph b">DRV_I2S_BUFFER_HANDLE</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title353" id="drv-i2s-serial-setup-type"><h2 class="title topictitle2" id="ariaid-title353">DRV_I2S_SERIAL_SETUP Type</h2><div class="body"><p class="p">Defines the data required to dynamically set the serial settings.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Serial Setup Data</p>
<p class="p">This data type defines the data required to dynamically set the serial settings for the specific I2S driver instance.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This structure is implementation specific. It is fully defined in drv_i2s_definitions.h.</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">typedef</strong> <strong class="ph b">struct</strong> _DRV_I2S_SERIAL_SETUP <strong class="ph b">DRV_I2S_SERIAL_SETUP</strong>;</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title354" id="drv-i2s-buffer-handle-invalid-macro"><h2 class="title topictitle2" id="ariaid-title354">DRV_I2S_BUFFER_HANDLE_INVALID Macro</h2><div class="body"><p class="p">Definition of an invalid buffer handle.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Invalid Buffer Handle</p>
<p class="p">This is the definition of an invalid buffer handle. An invalid buffer handle is returned by DRV_I2S_ReadBufferAdd and DRV_I2S_WriteBufferAdd functions if the buffer add request was not successful.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">#define</strong> <strong class="ph b">DRV_I2S_BUFFER_HANDLE_INVALID</strong></p>
<p class="p">Files</p>
<p class="p"><strong class="ph b">Files</strong></p>
<p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21959"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e21962"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21959 "><span>drv_i2s.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21962 "><span>I2S Driver Interface Header File</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21959 "><span>drv_i2s_config_template.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e21962 "><span>I2S Driver Configuration Template.</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title355" id="drv-i2sh"><h2 class="title topictitle2" id="ariaid-title355"><em class="ph i">drv_i2s.h</em></h2><div class="body"><p class="p">drv_i2s.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">I2S Driver Interface Header File</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Interface Header File</p>
<p class="p">The I2S device driver provides a simple interface to manage the I2S or SSC modules on Microchip PIC32 microcontrollers. This file provides the interface definition for the I2S driver.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title356" id="drv-i2s-config-templateh"><h2 class="title topictitle2" id="ariaid-title356"><em class="ph i">drv_i2s_config_template.h</em></h2><div class="body"><p class="p">drv_i2s_config_template.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">I2S Driver Configuration Template.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2S Driver Configuration Template</p>
<p class="p">These file provides the list of all the configurations that can be used with the driver. This file should not be included in the driver.</p>
<p class="p">Introduction</p>
<p class="p"><strong class="ph b">Peripheral Libraries Help</strong></p>
<p class="p">This topic provides help for the peripheral libraries that are available in the audio repo.</p>
<p class="p">For additional information on Harmony 3 peripheral libraries (PLIBs), refer to the documentation in the csp repository.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The MPLAB Harmony Configurator (MHC) is a Graphical User Interface (GUI) plug-in tool for MPLAB X IDE to configures a rich set of peripherals and functions specific to your application and generate the corresponding peripheral library code. The generated code directly accesses the Peripheral registers without any abstraction layers and it is easy to understand.</p>
<p class="p"><strong class="ph b">I2S Peripheral Library Help</strong></p>
<p class="p">This section provides an interface to use the I2S peripheral.</p>
<p class="p"><strong class="ph b">Introduction</strong></p>
<p class="p">This library provides a brief overview of the I2S peripheral.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The I2S module implements an I2S (Inter-IC Sound) interface, for connection between an MCU and an audio peripheral such as a codec or Bluetooth module.</p>
<p class="p">The I2S module provides support to the audio protocol functionality via four standard I/O pins. The four pins that make up the audio protocol interface modes are:</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">SDI:</strong> Serial Data Input for receiving sample digital audio data (ADCDAT as output from the codec)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">SDO:</strong> Serial Data Output for transmitting digital audio data (DACDAT as input to the codec)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">SCKn:</strong> Serial Clock, also known as bit clock (BCLK)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">FSn:</strong> Frame Select, also known as Word Select or Left/Right Channel Clock (LRCK)</p>
</li>
</ul>
<p class="p">In addition, there is a fifth line, called <strong class="ph b">MCKn</strong> (Master Clock), which can be used to drive the codec.</p>
<p class="p">There are two clock units in the I2S module, so <strong class="ph b">n</strong>=1 or 2 depending on which is used. However there are only two data lines (SDO/SDI), one for each serializer (transmit/receive).</p>
<p class="p">The SCK provides the clock required to drive the data out or into the module, while FS provides the synchronization of the frame based on the protocol mode selected. In I2S mode, the leading edge of audio data is driven out one SCK period of starting the frame.</p>
<p class="p">In Master mode, the module generates both the SCK and FS.</p>
<p class="p">In Slave mode, the peripheral generates the BCLK and LRCLK signals, driving the SCK and FS pins of the I2S module. When in Slave mode, the I2S cannot generate a master clock (MCK), so a generic clock (GCLKn) must be used.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title357" id="master-mode"><h2 class="title topictitle2" id="ariaid-title357">Master Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title358" id="master-generating-its-own-clock--output-bclk-and-lrck"><h3 class="title topictitle3" id="ariaid-title358">Master Generating its Own Clock – Output BCLK and LRCK</h3><div class="body"><br /><img class="image" src="GUID-0EAF3BD6-20B2-4761-A19A-D9E8C8DD14D9-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title359" id="slave-mode"><h2 class="title topictitle2" id="ariaid-title359">Slave Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title360" id="codec-device-as-master-derives-mclk-from-mcu-reference-clock-out"><h3 class="title topictitle3" id="ariaid-title360">Codec Device as Master Derives MCLK from MCU Reference Clock Out</h3><div class="body"><p class="p">Configuring the Library
<img class="image" src="GUID-DB11C543-871D-405A-9F39-15BC9DDB4514-low.png" /><br /></p>
<p class="p"><strong class="ph b">Configuring the Library</strong></p>
<p class="p">This section describes how to configure the peripheral library using the MHC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The library is configured for the supported processor when the processor is chosen in MPLAB X IDE, using the Microchip Harmony Configurator (MHC).</p>
<p class="p">Choose the I2S peripheral by clicking on the appropriate instance under <em class="ph i">Peripherals-&gt;I2S</em> in the Available Components section of MHC. (The I2S component may also be added automatically as a result of using a BSP Template, such as one for a codec or Bluetooth module).</p>
<p class="p">When the I2S peripheral is clicked on in the Project Graph, the following menu is displayed in the Configurations Options:
<img class="image" src="GUID-EB4BD32D-6DBB-4C6E-9B43-BC917603F923-low.png" /><br /></p>
<p class="p">Typical values are shown for working in Slave mode, with a codec such as the WM8904 in Master mode. <strong class="ph b">DMA</strong> and <strong class="ph b">Interrupt Mode</strong> are always enabled.</p>
<p class="p">For each of the two Clock Units (0 and 1, only the first is shown):</p>
<p class="p"><strong class="ph b">Clock Unit n Enable --</strong> if checked, the clock unit is enabled</p>
<p class="p"><strong class="ph b">Master/Slave Mode</strong> can be either Master -- the I2S peripheral supplies the I2S clocks, or Slave -- the peripheral such as a codec or Bluetooth module supplies the I2S clocks.</p>
<p class="p">Using the Library</p>
<p class="p"><strong class="ph b">Master Clock Output Divisor</strong> -- the Generic I2S Clock (GCLK_I2S_n) is divided by this number to generate the Master Clock (MCKn)</p>
<p class="p"><strong class="ph b">Master Clock Division Factor</strong> -- the Master Clock (MCKn) is divided by this number to generate a serial clock SCKn</p>
<p class="p"><strong class="ph b">Frame Sync Output Invert</strong> -- the FSn signal is output with or without inversion</p>
<p class="p"><strong class="ph b">Frame Sync Input Invert</strong> -- the FSn signal is used with or without inversion on input</p>
<p class="p"><strong class="ph b">Data Delay from Frame Sync</strong> -- either 1 bit for I2S format, or 0 for left/right adjusted format</p>
<p class="p"><strong class="ph b">Slot Size</strong> selects the number of bits per slot: 8, 16, 24 or 32</p>
<p class="p">For each of the Serializers (TX/RX):</p>
<p class="p"><strong class="ph b">Stereo/Mono</strong> selects stereo or mono (left channel is duplicated to the right)</p>
<p class="p"><strong class="ph b">Data Word Formatting Adjust</strong> selects left or right adjustment of data samples within the word</p>
<p class="p"><strong class="ph b">Data Word Size</strong> selects the number of bits per sample: 8, 16, 18, 20, 24 or 32 (or 8-bit compact stereo or 16-bit compact stereo)</p>
<p class="p"><strong class="ph b">Data Slot Formatting Adjust</strong> selects left or right adjustment of data samples within the slot</p>
<p class="p"><strong class="ph b">Clock Unit Selection</strong> selects which clock unit to use for this serializer, 0 or 1</p>
<p class="p"><strong class="ph b">Frame Select Pin</strong> specifies which pin is used as the FSn output as selected in the Pin Diagram</p>
<p class="p"><strong class="ph b">Invert</strong> selects whether the output of the I2S_LRCLK_Get function returns the true value or inverted one.</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the I2S Peripheral Library and provides information and examples on how to use it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title361" id="abstraction-model-4"><h2 class="title topictitle2" id="ariaid-title361">Abstraction Model</h2><div class="body"><p class="p">The I2S module sits between the I2S Driver, and the actual hardware.
<img class="image" src="GUID-116B9958-209C-4BB0-A9F7-7685360BDD59-low.png" /><br /></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title362" id="interface-header-file-plib-i2sch"><h3 class="title topictitle3" id="ariaid-title362">Interface Header File: plib_i2sc.h</h3><div class="body"><p class="p">The interface to the I2S Peripheral Library is defined in the plib_i2sc.h header file. Any C language source (.c) file that uses the I2S Peripheral Library should include plib_i2sc.h.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The I2S Peripheral Library library source files are provided in the audio/peripheral/i2s_xxxx/src or audio/peripheral/i2s_xxxx/templates directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features.</p>
<p class="p">Introduction</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title363" id="usage-model"><h2 class="title topictitle2" id="ariaid-title363">Usage Model</h2><div class="body"><p class="p">The only usage model for the I2S Peripheral Library is to use a Interrupt/DMA model. Therefore the remaining functions normally associated with a PLIB like this (handling write or read requests, or returning transfer status), will be accomplished by the I2S driver directly communicating with the appropriate DMA functions, which is why they are not provided here.</p>
<p class="p">The one function provided besides initialization is one for synchronizing with the left/right clock (LRCLK) for the I2S stream.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/audio_tone_linkeddma</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
<p class="p"><strong class="ph b">Library Interface</strong></p>
<p class="p">This section describes the Application Programming Interface (API) functions of the Peripheral Library.</p>
<p class="p">Refer to each section for a detailed description.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b"><em class="ph i">Initialization Function</em></strong></p>
</li>
<li class="li"><span class="indent-level-default">2.</span><p class="p"><strong class="ph b"><em class="ph i">Transaction Functions</em></strong></p>
</li>
</ol>
<p class="p"><strong class="ph b">Files</strong></p>
<p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22286"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22289"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22286 "><span>plib_i2s_u2224.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22289 "><span>I2S PLIB Header File for documentation</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title364" id="plib-i2s-u2224h"><h2 class="title topictitle2" id="ariaid-title364"><em class="ph i">plib_i2s_u2224.h</em></h2><div class="body"><p class="p">plib_i2s_u2224.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">I2S PLIB Header File for documentation</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2SC PLIB</p>
<p class="p">This library provides documentation of all the interfaces which can be used to control and interact with an instance of an Inter-IC Sound Controller (I2S). This file must not be included in any MPLAB Project.</p>
<p class="p"><strong class="ph b">I2SC Peripheral Library Help</strong></p>
<p class="p">This section provides an interface to use the Inter-IC Sound Controller (I2SC) peripheral.</p>
<p class="p">Configuring the Library</p>
<p class="p"><strong class="ph b">Introduction</strong></p>
<p class="p">This library provides a brief overview of the I2SC peripheral.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The I2SC module implements an I2S (Inter-IC Sound) interface, for connection between an MCU and an audio peripheral such as a codec or Bluetooth module.</p>
<p class="p">The I2SC module provides support to the audio protocol functionality via four standard I/O pins. The four pins that make up the audio protocol interface modes are:</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">DI:</strong> Serial Data Input for receiving sample digital audio data (ADCDAT)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">DO:</strong> Serial Data Output for transmitting digital audio data (DACDAT)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">CK:</strong> Serial Clock, also known as bit clock (BCLK)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">WS:</strong> Word Select, also known as Left/Right Channel Clock (LRCK)</p>
</li>
</ul>
<p class="p">The BCLK provides the clock required to drive the data out or into the module, while the LRCK provides the synchronization of the frame based on the protocol mode selected.</p>
<p class="p">In Master mode, the module generates both the BCLK on the CK pin and the LRCK on the WS pin. In certain devices, while in Slave mode, the module receives these two clocks from its I2S partner, which is operating in Master mode.</p>
<p class="p">When configured in Master mode, the leading edge of CK and the LRCK are driven out within one SCK period of starting the audio protocol. Serial data is shifted in or out with timings determined by the protocol mode set.</p>
<p class="p">In Slave mode, the peripheral drives zeros out DO, but does not transmit the contents of the transmit FIFO until it sees the leading edge of the LRCK, after which time it starts receiving data.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title365" id="master-mode-1"><h2 class="title topictitle2" id="ariaid-title365">Master Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title366" id="master-generating-its-own-clock--output-bclk-and-lrck-1"><h3 class="title topictitle3" id="ariaid-title366">Master Generating its Own Clock – Output BCLK and LRCK</h3><div class="body"><br /><img class="image" src="GUID-CE2DE0EB-4569-46ED-8C1E-BB30E8C319B9-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title367" id="slave-mode-1"><h2 class="title topictitle2" id="ariaid-title367">Slave Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title368" id="codec-device-as-master-derives-mclk-from-mcu-reference-clock-out-1"><h3 class="title topictitle3" id="ariaid-title368">Codec Device as Master Derives MCLK from MCU Reference Clock Out</h3><div class="body"><br /><img class="image" src="GUID-BF9BC1C9-632E-415D-AD19-4D18FEF2DEC3-low.png" /><br /></div>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title369" id="audio-formats"><h3 class="title topictitle3" id="ariaid-title369">Audio Formats</h3><div class="body"><p class="p">The I2SC Module supports just one audio format, I2S. Left Justified format is not available.</p>
<p class="p">Using the Library</p>
<p class="p"><strong class="ph b">Configuring the Library</strong></p>
<p class="p">This section describes how to configure the peripheral library using the MHC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The library is configured for the supported processor when the processor is chosen in MPLAB X IDE, using the Microchip Harmony Configurator (MHC).</p>
<p class="p">Choose the I2SC peripheral by clicking on the appropriate instance under <em class="ph i">Peripherals-&gt;I2SC</em> in the Available Components section of MHC. (The I2SC component may also be added automatically as a result of using a BSP Template, such as one for a codec or Bluetooth module).</p>
<p class="p">When the I2SCx peripheral is clicked on in the Project Graph, the following menu is displayed in the Configurations Options (example shown for instance I2SC1):
<img class="image" src="GUID-0C25CC5D-A012-4E12-98B8-09D800BD1068-low.png" /><br /></p>
<p class="p">Default values are shown. The <strong class="ph b">DMA</strong> and <strong class="ph b">Interrupt Mode</strong> are always enabled.</p>
<p class="p"><strong class="ph b">Master/Slave Mode</strong> can be either Master -- the I2SC peripheral supplies the I2S clocks, or Slave -- the peripheral such as a codec or Bluetooth module supplies the I2S clocks.</p>
<p class="p"><strong class="ph b">Data Word Length</strong> can be selected from 8 to 32-bits.</p>
<p class="p"><strong class="ph b">Data Format</strong> is currently always I2S.</p>
<p class="p"><strong class="ph b">Receiver Stereo/Mono</strong> can be either Stereo or Mono (left channel duplicated to right).</p>
<p class="p"><strong class="ph b"># of DMA Channels for Receiver</strong> can either Single or Multiple (1/channel).</p>
<p class="p"><strong class="ph b">Loopback Test Mode</strong> can be Normal or Loop mode.</p>
<p class="p"><strong class="ph b">Transmitter Stereo/Mono</strong> can be either Stereo or Mono (left channel duplicated to right).</p>
<p class="p"><strong class="ph b">Transmit Data When Underrun</strong> can be Transmit 0 or Transmit previous.</p>
<p class="p"><strong class="ph b">Slot Width</strong> can be 24 or 32-bits wide.</p>
<p class="p">The following options are only shown if the Master/Slave mode is Master:</p>
<p class="p">• <strong class="ph b">Selected Clock for IMCK Ratio</strong> is selectable as any integer</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title370" id="-master-clock-to-sample-rate-ratio-can-be-set-from-32-to-2048"><h2 class="title topictitle2" id="ariaid-title370">• Master Clock to Sample Rate Ratio can be set from 32 to 2048</h2><div class="body"><p class="p">• <strong class="ph b">Master Clock Mode</strong> can be either Master Clock Generated or not</p>
<p class="p">Library Interface</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the I2SC Peripheral Library and provides information and examples on how to use it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title371" id="abstraction-model-5"><h2 class="title topictitle2" id="ariaid-title371">Abstraction Model</h2><div class="body"><p class="p">The I2SC module sits between the I2S Driver, and the actual hardware.
<img class="image" src="GUID-7FFA68F8-05F4-4557-A74E-B01D2423AA60-low.png" /><br /></p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title372" id="interface-header-file-plib-i2sch-1"><h3 class="title topictitle3" id="ariaid-title372">Interface Header File: plib_i2sc.h</h3><div class="body"><p class="p">The interface to the I2SC Peripheral Library is defined in the plib_i2sc.h header file. Any C language source (.c) file that uses the I2SC Peripheral Library should include plib_i2sc.h.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The I2SC Peripheral Library library source files are provided in the csp/peripheral/i2sc_xxxx/src or csp/peripheral/i2sc_xxxx/templates directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title373" id="usage-model-1"><h2 class="title topictitle2" id="ariaid-title373">Usage Model</h2><div class="body"><p class="p">The only usage model for the I2SC Peripheral Library is to use a Interrupt/DMA model. Therefore the remaining functions normally associated with a PLIB like this (handling write or read requests, or returning transfer status), will be accomplished by the I2S driver directly communicating with the appropriate DMA functions, which is why they are not provided here.</p>
<p class="p">The one function provided besides initialization is one for synchronizing with the left/right clock (LRCLK) for the I2S stream.</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/audio_tone_linkeddma</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
<p class="p">Library Interface</p>
<p class="p"><strong class="ph b">Library Interface</strong></p>
<p class="p">This section describes the Application Programming Interface (API) functions of the Peripheral Library.</p>
<p class="p">Refer to each section for a detailed description.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Initialization Function</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22550"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22552"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22555"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22550 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22552 "><span>I2SCx_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22555 "><span>Initializes I2SCx module of the device</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Transaction Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22579"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22581"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22584"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22579 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22581 "><span>I2SCx_LRCLK_Get</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22584 "><span>Get the level of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b"><em class="ph i">a) Initialization Function</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title374" id="i2scx-initialize-function"><h2 class="title topictitle2" id="ariaid-title374">I2SCx_Initialize Function</h2><div class="body"><p class="p">void I2SCx_Initialize (void);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes I2SCx module of the device</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function initializes I2SCx module of the device with the values configured in MHC GUI. Once the peripheral is initialized, transfer APIs can be used to transfer the data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">MHC GUI should be configured with the right values.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function must be called only once and before any other I2SC function is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">I2SC0_Initialize();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">I2SCx_Initialize</strong>();</p>
<p class="p"><strong class="ph b"><em class="ph i">b) Transaction Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title375" id="i2scx-lrclk-get-function"><h2 class="title topictitle2" id="ariaid-title375">I2SCx_LRCLK_Get Function</h2><div class="body"><p class="p">uint32_t I2SCx_LRCLK_Get(void);</p>
<p class="p">Introduction</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the level of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function returns the state of the I2S LRCLK (left/right clock) signal. In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize itself to the LRCLK signal.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">State of the LRCLK pin for the I2SCx module -- 1 if high, 0 if low</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">I2SC1_LRCLK_Get();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">I2SCx_LRCLK_Get</strong>();</p>
<p class="p"><strong class="ph b"><em class="ph i">c) Data Types and Constants</em></strong></p>
<p class="p"><strong class="ph b">Files</strong></p>
<p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22713"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22716"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22713 "><span>plib_i2sc_11241.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22716 "><span>I2SC PLIB Header File for documentation</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title376" id="plib-i2sc-11241h"><h2 class="title topictitle2" id="ariaid-title376"><em class="ph i">plib_i2sc_11241.h</em></h2><div class="body"><p class="p">plib_i2sc_11241.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">I2SC PLIB Header File for documentation</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">I2SC PLIB</p>
<p class="p">This library provides documentation of all the interfaces which can be used to control and interact with an instance of an Inter-IC Sound Controller (I2SC). This file must not be included in any MPLAB Project.</p>
<p class="p"><strong class="ph b">SPI-I2S Peripheral Library Help</strong></p>
<p class="p">This section provides an interface to use the Inter-IC Sound (I2S) peripheral.</p>
<p class="p">Configuring the Library</p>
<p class="p"><strong class="ph b">Introduction</strong></p>
<p class="p">This library provides a brief overview of the I2S peripheral. On PIC32MX/MZ processors, this peripheral is shared with the SPI (Serial Peripheral Interface) hardware.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The I2S module implements an I2S (Inter-IC Sound) interface, for connection between an MCU and an audio peripheral such as a codec or Bluetooth module.</p>
<p class="p">The I2S module provides support to the audio protocol functionality via four standard I/O pins. The four pins that make up the audio protocol interface modes are:</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">SDI:</strong> Serial Data Input for receiving sample digital audio data (ADCDAT as output from the codec)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">SDO:</strong> Serial Data Output for transmitting digital audio data (DACDAT as input to the codec)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">SCK:</strong> Serial Clock, also known as bit clock (BCLK)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">FS:</strong> Frame Select, also known as Word Select or Left/Right Channel Clock (LRCK)</p>
</li>
</ul>
<p class="p">In addition, there is a fifth line, called REFCLKO (Reference CLock Output, or Master Clock), which can be used to drive the codec.</p>
<p class="p">The SCK provides the clock required to drive the data out or into the module, while FS provides the synchronization of the frame based on the protocol mode selected. In I2S mode, the leading edge of audio data is driven out one SCK period of starting the frame.</p>
<p class="p">In Master mode, the module generates both the SCK and FS.</p>
<p class="p">In Slave mode, the peripheral generates the BCLK and LRCLK signals, driving the SCK and FS pins of the I2S module.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title377" id="master-mode-master-generating-its-own-clock--output-bclk-and-lrck"><h2 class="title topictitle2" id="ariaid-title377">Master Mode Master Generating its Own Clock – Output BCLK and LRCK</h2><div class="body"><br /><img class="image" src="GUID-F0A6B110-F34A-42BF-A2A0-819FEFCF049E-low.png" /><br /></div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title378" id="slave-mode-codec-device-as-master-derives-mclk-from-mcu-reference-clock-out"><h2 class="title topictitle2" id="ariaid-title378">Slave Mode Codec Device as Master Derives MCLK from MCU Reference Clock Out</h2><div class="body"><br /><img class="image" src="GUID-84A5D851-9E27-43F3-8708-45BFDC894028-low.png" /><br /><p class="p"><strong class="ph b">Configuring the Library</strong></p>
<p class="p">This section describes how to configure the peripheral library using the MHC.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The library is configured for the supported processor when the processor is chosen in MPLAB X IDE, using the Microchip</p>
<p class="p">Library Interface</p>
<p class="p">Harmony Configurator (MHC).</p>
<p class="p">Choose the I2S peripheral by clicking on the appropriate instance under <em class="ph i">Peripherals-&gt;I2S</em> in the Available Components section of MHC. (The I2S component may also be added automatically as a result of using a BSP Template, such as one for a codec or Bluetooth module).</p>
<p class="p">When the I2S peripheral is clicked on in the Project Graph, the following menu is displayed in the Configurations Options:
<img class="image" src="GUID-4EFBB190-7FC4-45B2-B197-85DEAB8F0055-low.png" /><br /></p>
<p class="p">Note: DMA and Interrupt Mode are always enabled.</p>
<p class="p"><strong class="ph b">Master Mode Enable Bit --</strong> only Master Mode is currently supported.</p>
<p class="p"><strong class="ph b">Clock Polarity Select Bit</strong> -- determines whether idle state of clock is high (default) or vice versa.</p>
<p class="p"><strong class="ph b">SPI Clock Edge Select Bit</strong> -- selects whether output chamges on transistion from active to idle (default) or vice versa.</p>
<p class="p"><strong class="ph b">32/16 Bit Communication Select Bits</strong> -- selects the data, FIFO, channel, and frame sizes.</p>
<p class="p"><strong class="ph b">Master CLock Enable Bit</strong> -- always selects REFCLK to be used by the baud rate generator.</p>
<p class="p"><strong class="ph b">Audio Protocol Mode</strong> -- I2S, left or right justified, or PCM.</p>
<p class="p"><strong class="ph b">Transmit Audio Data Format</strong> -- stereo or mono.</p>
<p class="p"><strong class="ph b">Frame Select Pin</strong> -- specifies which pin is used for the frame select (aka L/R clock or word select) <strong class="ph b">Invert</strong> -- indicates whether the output of the LRCLK_Get function is inverted or not</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This section explains how to use the peripheral library.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">Library Source Files: The I2S Peripheral Library library source files are provided in the</p>
<p class="p">audio/peripheral/i2s_xxxx/src or audio/peripheral/i2s_xxxx/templates directory. This folder may contain optional files and alternate implementations. Please refer to Configuring the Library <strong class="ph b">for</strong> instructions on how to select optional features.</p>
<p class="p">Usage Model The only usage model <strong class="ph b">for</strong> the I2S Peripheral Library is to use a Interrupt/DMA model. Therefore the remaining functions normally associated with a PLIB like <strong class="ph b">this</strong> (handling write or read requests, or returning transfer status), will be accomplished by the I2S driver directly communicating with the appropriate DMA functions, which is why they are not provided here. The one function provided besides initialization is one <strong class="ph b">for</strong> synchronizing with the left/right clock (LRCLK) <strong class="ph b">for</strong> the I2S stream. Example Applications:</p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/microphone_loopback</p>
</li>
</ul>
<p class="p">Library Interface</p>
<p class="p"><strong class="ph b">Library Interface</strong></p>
<p class="p">This section describes the Application Programming Interface (API) functions of the Peripheral Library.</p>
<p class="p">Refer to each section for a detailed description.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Initialization Function</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22926"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22928"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22931"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22926 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22928 "><span>I2Sx_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22931 "><span>Initializes I2S x module of the device</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Status Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22955"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22957"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e22960"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22955 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22957 "><span>I2Sx_LRCLK_Get</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e22960 "><span>Get LRCLK state</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b"><em class="ph i">a) Initialization Function</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title379" id="i2sx-initialize-function"><h2 class="title topictitle2" id="ariaid-title379">I2Sx_Initialize Function</h2><div class="body"><p class="p">void I2Sx_Initialize (void);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes I2S x module of the device</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function initializes I2S x module of the device with the values configured in MHC GUI. Once the peripheral is initialized, transfer APIs can be used to transfer the data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">MHC GUI should be configured with the right values.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function must be called only once and before any other SPI function is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">I2S1_Initialize();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">I2Sx_Initialize</strong>();</p>
<p class="p"><strong class="ph b"><em class="ph i">b) Status Functions</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title380" id="i2sx-lrclk-get-function"><h2 class="title topictitle2" id="ariaid-title380">I2Sx_LRCLK_Get Function</h2><div class="body"><p class="p">uint32_t I2Sx_LRCLK_Get (void);</p>
<p class="p">Introduction</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get LRCLK state <strong class="ph b">Description</strong></p>
<p class="p">This function returns the state of the LRCLK (left/right clock, aka word select line) of the I2S peipheral.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">MHC GUI should be configured with the right values.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong> lrclkState = I2Sx_LRCLK_Get();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">I2Sx_LRCLK_Get</strong>();</p>
<p class="p"><strong class="ph b">Files</strong></p>
<p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23079"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23082"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23079 "><span>plib_spi_01329.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23082 "><span>SPI PLIB Header File for documentation</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title381" id="plib-spi-01329h"><h2 class="title topictitle2" id="ariaid-title381"><em class="ph i">plib_spi_01329.h</em></h2><div class="body"><p class="p">plib_spi_01329.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">SPI PLIB Header File for documentation</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">SPI-I2S PLIB</p>
<p class="p">This library provides documentation of all the interfaces which can be used to control and interact with an instance of a Serial Peripheral Interface (SPI) controller used for I2S. This file must not be included in any MPLAB Project.</p>
<p class="p"><strong class="ph b">SSC Peripheral Library Help</strong></p>
<p class="p">This section provides an interface to use the Serial Synchronous Controller (SSC) peripheral.</p>
<p class="p"><strong class="ph b">Introduction</strong></p>
<p class="p">This section provides a brief overview of the SSC peripheral.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">The SSC module implements an I2S (Inter-IC Sound) interface, for connection between an MCU and an audio peripheral such as a codec or Bluetooth module. The SSC hardware also provides for other protocols, which can be configured manually.</p>
<p class="p">The SSC module provides support to the audio protocol functionality via four standard I/O pins. The four pins that make up the audio protocol interface modes are:</p>
<p class="p">Configuring the Library</p>
<ul class="ul"><li class="li"><p class="p"><strong class="ph b">RD:</strong> Serial Data Input for receiving sample digital audio data (ADCDAT)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">TD:</strong> Serial Data Output for transmitting digital audio data (DACDAT)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">TK/RK:</strong> Transmit/Receive Serial Clock, also known as bit clock (BCLK)</p>
</li>
<li class="li"><p class="p"><strong class="ph b">TF/RF:</strong> Transmit/Receive Frame Clock, also known as Left/Right Channel Clock (LRCK)</p>
</li>
</ul>
<p class="p">BCLK provides the clock required to drive the data out or into the module, while LRCK provides the synchronization of the frame based on the protocol mode selected.</p>
<p class="p">In Master mode, the module generates both the BCLK on the TK pin and the LRCK on the TF pin. In certain devices, while in Slave mode, the module receives these two clocks from its I2S partner, which is operating in Master mode.</p>
<p class="p">When configured in Master mode, the leading edge of BCLK and the LRCK are driven out within one SCK period of starting the audio protocol. Serial data is shifted in or out with timings determined by the protocol mode set.</p>
<p class="p">In Slave mode, the peripheral drives zeros out TD, but does not transmit the contents of the transmit FIFO until it sees the leading edge of the LRCK, after which time it starts receiving data.</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title382" id="master-mode-2"><h2 class="title topictitle2" id="ariaid-title382">Master Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title383" id="master-generating-its-own-clock--output-bclk-and-lrck-2"><h3 class="title topictitle3" id="ariaid-title383">Master Generating its Own Clock – Output BCLK and LRCK</h3><div class="body"><br /><img class="image" src="GUID-79AC79AC-C2CA-4A50-9E4F-504E63A728B4-low.png" /><br /></div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title384" id="slave-mode-2"><h2 class="title topictitle2" id="ariaid-title384">Slave Mode</h2><div class="body"></div>
<div class="topic nested2" aria-labelledby="ariaid-title385" id="codec-device-as-master-derives-mclk-from-mcu-reference-clock-out-2"><h3 class="title topictitle3" id="ariaid-title385">Codec Device as Master Derives MCLK from MCU Reference Clock Out</h3><div class="body"><br /><img class="image" src="GUID-DF62A4EF-7C79-4EC1-B67D-C7E42E2EAB8E-low.png" /><br /><p class="p">Default values are shown. The <strong class="ph b">DMA</strong> and <strong class="ph b">Interrupt Mode</strong> are always enabled.</p>
<p class="p"><strong class="ph b">Usage Mode</strong> can be either Master -- the SSC peripheral supplies the I2S clocks, or Slave -- the peripheral such as a codec or Bluetooth module supplies the I2S clocks.</p>
<p class="p"><strong class="ph b">Audio Protocol Mode</strong> can be either I2S, Left Justified, or Custom. In the latter case, a number of other options are then available, which allows the SSC peripheral to be used for a number of protocols (not currently supported by existing drivers).</p>
<p class="p"><strong class="ph b">Data Length</strong> is set to the number of data bits per channel.</p>
<p class="p"><strong class="ph b">Using the Library</strong></p>
<p class="p">This topic describes the basic architecture of the SSC Peripheral Library and provides information and examples on how to use it.</p>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title386" id="abstraction-model-6"><h2 class="title topictitle2" id="ariaid-title386">Abstraction Model</h2><div class="body"><p class="p">The SSC module sits between the I2S Driver, and the actual hardware.
<img class="image" src="GUID-9D52156A-2B78-409E-A603-C95968F1D8C0-low.png" /><br /></p>
<p class="p">Note: Some devices may have only one instance of an SSC interface (SSC0 only).</p>
</div>
<div class="topic nested2" aria-labelledby="ariaid-title387" id="interface-header-file-plib-ssch"><h3 class="title topictitle3" id="ariaid-title387">Interface Header File: plib_ssc.h</h3><div class="body"><p class="p">The interface to the SSC Peripheral Library is defined in the plib_ssc.h header file. Any C language source (.c) file that uses the SSC Peripheral Library should include plib_ssc.h.</p>
<p class="p"><strong class="ph b">Library Source Files:</strong></p>
<p class="p">The SSC Peripheral Library library source files are provided in the audio/peripheral/ssc_xxxx/src or audio/peripheral/ssc_xxxx/templates directory. This folder may contain optional files and alternate implementations. Please refer to <strong class="ph b">Configuring the Library</strong> for instructions on how to select optional features.</p>
</div>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title388" id="usage-model-2"><h2 class="title topictitle2" id="ariaid-title388">Usage Model</h2><div class="body"><p class="p">The only usage model for the SSC Peripheral Library is to use a Interrupt/DMA model. Therefore many functions normally associated with a PLIB like this (handling write or read requests, or returning transfer status), will be accomplished by the I2S driver directly communicating with the appropriate DMA functions, which is why they are not provided here.</p>
<p class="p">Library Interface</p>
<p class="p"><strong class="ph b">Example Applications:</strong></p>
<p class="p">This library is used by the following applications, among others:</p>
<ul class="ul"><li class="li"><p class="p">audio/apps/audio_tone</p>
</li>
<li class="li"><p class="p">audio/apps/audio_tone_linkeddma</p>
</li>
</ul>
<p class="p"><strong class="ph b">Library Interface</strong></p>
<p class="p">This section describes the Application Programming Interface (API) functions of the Peripheral Library.</p>
<p class="p">Refer to each section for a detailed description.</p>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Initialization Function</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23270"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23272"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23275"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23270 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23272 "><span>SSC_Initialize</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23275 "><span>Initializes SSC module of the device</span></td>
</tr>
</tbody>
</table>
</div>
<ol class="ol"><li class="li"><span class="indent-level-default">1.</span><p class="p"><strong class="ph b">Transaction Functions</strong></p>
</li>
</ol>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23299"><span>-</span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23301"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23304"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23299 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23301 "><span>SSC_BaudSet</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23304 "><span>Changes the baud rate (samples/second) of the interface.</span></td>
</tr>
<tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23299 "><span> </span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23301 "><span>SSC_LRCLK_Get</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23304 "><span>Get the level of the I2S LRCLK (left/right clock) signal</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b"><em class="ph i">a) Initialization Function</em></strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title389" id="ssc-initialize-function"><h2 class="title topictitle2" id="ariaid-title389">SSC_Initialize Function</h2><div class="body"><p class="p">void SSC_Initialize (void);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Initializes SSC module of the device</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function initializes SSC module of the device with the values configured in MHC GUI. Once the peripheral is initialized, transfer APIs can be used to transfer the data.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">MHC GUI should be configured with the right values.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">This function must be called only once and before any other SSC function is called.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SSC_Initialize();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">SSC_Initialize</strong>();</p>
<p class="p"><strong class="ph b"><em class="ph i">b) Transaction Functions</em></strong></p>
<p class="p">Files</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title390" id="ssc-baudset-function"><h2 class="title topictitle2" id="ariaid-title390">SSC_BaudSet Function</h2><div class="body"><p class="p">void SSC_BaudSet (const uint32_t baud);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Changes the baud rate (samples/second) of the interface.</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function Cchanges the baud rate, or samples/second of the interface.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SSC_BaudSet(44100);</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p"><strong class="ph b">void</strong> <strong class="ph b">SSC_BaudSet</strong>(<strong class="ph b">const</strong> uint32_t <strong class="ph b">baud</strong>);</p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title391" id="ssc-lrclk-get-function"><h2 class="title topictitle2" id="ariaid-title391">SSC_LRCLK_Get Function</h2><div class="body"><p class="p">uint32_t SSC_LRCLK_Get(void);</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">Get the level of the I2S LRCLK (left/right clock) signal</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">This function returns the state of the I2S LRCLK (left/right clock) signal. In the case where this signal is generated from a codec or other external source, this allows the caller to synchronize itself to the LRCLK signal.</p>
<p class="p"><strong class="ph b">Preconditions</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Returns</strong></p>
<p class="p">State of the LRCLK pin for the SSC module -- 1 if high, 0 if low if the audio format is I2S, and 0 if high, 1 if low if the format is Left Jusutifed</p>
<p class="p"><strong class="ph b">Remarks</strong></p>
<p class="p">None.</p>
<p class="p"><strong class="ph b">Example</strong></p>
<p class="p">SSC_LRCLK_Get();</p>
<p class="p"><strong class="ph b">C</strong></p>
<p class="p">uint32_t <strong class="ph b">SSC_LRCLK_Get</strong>();</p>
<p class="p">Files</p>
<p class="p"><strong class="ph b">Files</strong></p>
<p class="p"><strong class="ph b">Files</strong></p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><col style="width:" /><col style="width:" /><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23491"><span><strong class="ph b">Name</strong></span></th>
<th class="entry cellrowborder" style="vertical-align:middle;" id="d656e23494"><span><strong class="ph b">Description</strong></span></th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23491 "><span>plib_ssc_6078.h</span></td>
<td class="entry cellrowborder" style="vertical-align:middle;" headers="d656e23494 "><span>SSC PLIB Header File for documentation</span></td>
</tr>
</tbody>
</table>
</div>
<p class="p"><strong class="ph b">Description</strong></p>
</div>
</div>
<div class="topic nested1" aria-labelledby="ariaid-title392" id="plib-ssc-6078h"><h2 class="title topictitle2" id="ariaid-title392"><em class="ph i">plib_ssc_6078.h</em></h2><div class="body"><p class="p">plib_ssc_6078.h</p>
<p class="p"><strong class="ph b">Summary</strong></p>
<p class="p">SSC PLIB Header File for documentation</p>
<p class="p"><strong class="ph b">Description</strong></p>
<p class="p">SSC PLIB</p>
<p class="p">This library provides documentation of all the interfaces which can be used to control and interact with an instance of a Serial Synchronous Controller (SSC). This file must not be included in any MPLAB Project.</p>
</div>
</div>
</body>
</html>