<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<title>Creating Your First Audio Application from Scratch</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Doc-O-Matic" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <link rel="STYLESHEET" href="default.css" type="text/css" />

<script type="text/javascript" src="scripts.js"></script>
</head>
<body class="Element700" onload="onBodyLoadEx('frames.html', 'topic', '00055.html');" onmousedown="onBodyMouseDown();">

<!-- Begin Popups -->

<!-- End Popups -->

<!-- Begin Page Header -->
<div class="Element710" id="areafixed">
<div class="Element94">
<a href="00054.html" target="topic">Audio Overview</a> &gt; <a href="00055.html" target="topic">Creating Your First Audio Application from Scratch</a></div>
<div class="Element92">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element1">
MPLAB Harmony Audio Help</div>
</td><td width="25%">
<div class="Element2">
<a href="contents.html" target="tocidx">Contents</a> | <a href="00054.html" target="topic">Home</a></div>
</td><td width="25%">
<div class="Element90">
<a href="00056.html" target="topic">Previous</a> | <a href="00054.html" target="topic">Up</a> | <a href="00057.html" target="topic">Next</a></div>
</td><td width="25%">
<div class="Element96">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: AUDIO_OVR Creating an Audio Porject from Scratch Topic Title: Creating Your First Audio Application from Scratch)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com" target="_blank">Microchip Support</a></div>
</td></tr></table><div class="Element5">
Creating Your First Audio Application from Scratch</div>
</div>
</div>

<!-- End Page Header -->

<!-- Begin Client Area -->
<div class="Element720" id="areascroll">
<div class="Element721">

<!-- Begin Page Content -->
<a name="PageContent"></a><div class="Element58">
<a name="4465736372697074696F6E"></a><div class="Element11">
<div class="Element10">
<p class="Element10">
This tutorial provides information on how to create an audio project using MPLAB Harmony 3. To keep the application as simple as possible, no graphics or other UI are included. It simply outputs a 1000 Hz sine wave over the I2S interface at 48,000 samples/sec that generates a 1 kHz sine tone. The sine tone is generated internally using math functions (no audio inputs).&nbsp;</p>
<p class="Element10">
The following hardware setup is supported:</p>
<ul class="Element630">
<li class="Element600">SAM E70 Xplained Ultra Evaluation Kit</li>
<li class="Element600">PIC32 Audio Codec Daughter Card</li>
<li class="Element600">Typical 3.5 mm stereo headphones (purchased separately)</li>
</ul><p class="Element10">
&nbsp;</p>
<div class="Element15">
Getting Started</div>
<p class="Element10">
Before beginning this tutorial, ensure that the MPLAB X IDE is installed and necessary language tools as described in Getting Started With MPLAB Harmony. In addition, ensure that the MPLAB Harmony dependent repos are installed on a local hard drive and that the correct version of MHC plug-in is installed within the MPLAB X IDE.&nbsp;</p>
<p class="Element10">
Follow the tutorial found in MPLAB Harmony Core Library Help &gt; Creating Your First Project to first learn about the basics of software development using MPLAB Harmony. Successfully completing the tutorial can serve as a confirmation of the software setup.&nbsp;</p>
<p class="Element10">
&nbsp;</p><div class="Element15">
Configuring the Hardware</div>
<p class="Element10">
<strong>SAM E70 Xplained Ultra board</strong>&nbsp;</p>
<p class="Element10">
The board is programmed via an Embedded Debugger (EDBG) interface via a USB cable, connected on one end to your computer using a USB-A plug, and to the E70 XULT board using a Micro-B plug as shown below: </p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS e70_xult_wm8904.jpg" border="0" alt="" title=""></p><p class="Element10">
In order to hear the audio, a codec is required. In this example, we are using a Wolfson WM8904 codec, mounted on a daughter board that plugs into the XC32 header of the E70 XULT board. A headphone is then plugged into the headphone jack of the daughter board.&nbsp;</p>
<p class="Element10">
Make sure the jumpers on headers J6-J9 are positioned as shown (towards the front of the board).&nbsp;</p>
<p class="Element10">
&nbsp;</p><div class="Element15">
Tutorial Steps</div>
<p class="Element10">
<strong>Creating a New Project</strong></p>
<ol class="Element630">
<li value="1" class="Element600">Launch the MPLAB X IDE. From the File pull-down menu, select New Project. (This will bring up the New Project dialog window.)</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_new_project.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="2" class="Element600">On the New Project dialog window, be sure the project type is 32-bit MPLAB Harmony Project, then hit the Next &gt; button.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_new_project2.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="3" class="Element600">In the New Project dialog window, be sure the Harmony Path is pointing to the MPLAB Harmony framework installation.</li>
</ol><p class="Element10">
&nbsp;</p>
<p class="Element10">
The New Project dialog should show the following: </p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_new_project3.jpg" border="0" alt="" title=""></p><p class="Element10">
Hit the <strong>Next &gt; </strong>button&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<ol class="Element630">
<li value="4" class="Element600">For the project name, type in MyAudioProject or some other name.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_new_project_audio4.jpg" border="0" alt="" title=""></p><p class="Element10">
Hit the <strong>Next &gt;</strong> button&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<ol class="Element630">
<li value="5" class="Element600">For the SAM E70 Xplained Ultra board, select the ATSAME70Q21B as the target device.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_new_project_audio5.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
Select <strong>Finish</strong> when done.&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<ol class="Element630">
<li value="6" class="Element600">In the MPLAB Harmony Launcher dialog window select the Launch Path that corresponds to the Harmony installation to be used. In the example below, both MPLAB X IDE’s default configuration and the project’s path point to the same MPLAB Harmony installation:</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_launcher.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
then select the <strong>Launch</strong> button.&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<ol class="Element630">
<li value="7" class="Element600">When the “Configuration Database Setup” dialog window appears, make sure <strong>audio</strong>, <strong>bsp</strong>, <strong>core</strong> and <strong>csp</strong> are selected:</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_launcher_audio2.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
then select the <strong>Launch</strong> button. MHC’s component graph should appear: </p><p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_graph_default.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="8" class="Element600">In the MHC’s Available Components panel drag and drop the SAM E70 Xplained Ultra BSP onto the project’s Component Graph</li>
</ol><p class="Element10">
&nbsp;</p>
<p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_graph_bsp.jpg" border="0" alt="" title=""></p><p class="Element10">
&nbsp;</p>

<ol class="Element630">
<li value="9" class="Element600">In Available Components, under Audio&gt;Templates, double-click on the desired codec, e.g. WM8904. Answer Yes to all questions except for the one regarding FreeRTOS; answer No to that one.</li>
</ol><p class="Element10">
&nbsp;</p>
<p class="Element10">
Besides instantiating all the necessary components (drivers and PLIBs), picking a base BSP plus an audio template also configures all the pins for that board needed by the application.&nbsp;</p>
<p class="Element10">
The result will be a project graph that looks like this, after rearranging the boxes,&nbsp;</p>
<p class="Element10">
&nbsp;</p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_graph_audio.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<ol class="Element630">
<li value="10" class="Element600">In the menu bar, select Tools&gt;Clock Configuration. In the Clock Diagram that pops up, set MOSCEL to Main Crystal, check the Bypass checkbox, and uncheck the RC Crystal Oscillator and Main Crystal Oscillator boxes, to make use the 12 MHz resonator on the board:</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_e70_clock.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="11" class="Element600">Also in the Clock Diagram, in the PCK2 tab of the Programmable Clock Controller section, check the On checkbox, and set CSS to MAINCLK (12 MHz).</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_e70_clock2.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="12" class="Element600">Then check the SSC checkbox in the Peripheral Clock Controller section.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_e70_clock3.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="13" class="Element600">Click on the Code button.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_code.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
On the next screen, click <strong>Don’t Save</strong>. </p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_code2.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
On the Generate Project Screen, click <strong>Generate</strong>: </p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mhc_code3.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
This completes the MHC configuration. The final step is to create the application code. Return to the MPLAB X GUI screen.&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<ol class="Element630">
<li value="14" class="Element600">Right-click on the Project Name and select Properties.</li>
</ol><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_properties_audio.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>
<p class="Element10">
On the next screen, select a compiler and debugger. </p><p class="Element10" style="text-align: center;">
<img src="AUDIO QS mplab_properties_audio2.jpg" border="0" alt="" title="">&nbsp;</p>
<p class="Element10" style="text-align: center;">
&nbsp;</p>

<ol class="Element630">
<li value="15" class="Element600">Click on the Clean and Build Project button.</li>
</ol><p class="Element10">
&nbsp;</p>
<p class="Element10">
You should get a BUILD SUCCESSFUL message (if not, go back and click on the Code button again).&nbsp;</p>
<p class="Element10">
&nbsp;</p><div class="Element15">
Adding code</div>
<p class="Element10">
Under MyAudioProject, expand Header Files, and open app.h. Under Included Files, at around line 35, add:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> #include &quot;definitions.h&quot;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
In the Type Definitions section, around line 51, add the following lines:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">#define MAX_AUDIO_NUM_SAMPLES 9600 // number of samples in buffer</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">#define FREQUENCY 1000 // 1 kHz</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">typedef struct // data structure to contain one left-right sample</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Left channel data</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> int16_t leftData;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Right channel data</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> int16_t rightData;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">} DRV_I2S_DATA16;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
Under Application States, around line 75, changes the APP_STATES enum to:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">typedef enum</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> /* Application's state machine's initial state. */</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> APP_STATE_CODEC_OPEN,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> APP_STATE_CODEC_SET_BUFFER_HANDLER,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> APP_STATE_CODEC_ADD_BUFFER,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> APP_STATE_CODEC_WAIT_FOR_BUFFER_COMPLETE,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">} APP_STATES;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
Under application data, around line 97, add the following struct:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">typedef struct</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_HANDLE handle;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BUFFER_HANDLE writeBufHandle1, writeBufHandle2;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BUFFER_EVENT_HANDLER bufferHandler;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uintptr_t context;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint8_t *txbufferObject1;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint8_t *txbufferObject2;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> size_t bufferSize1, bufferSize2;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">} AUDIO_CODEC_DATA;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
And changes the APP_DATA struct to:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">typedef struct</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> /* The application's current state */</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> APP_STATES state;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint8_t pingPong;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint32_t sampleRate;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint32_t frequency;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> AUDIO_CODEC_DATA codecData;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">} APP_DATA;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
Under MyAudioProject, expand Source Files, and open app.c. In the Included Files section, around line 31, add the following line:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">#include &lt;math.h&gt; // for sin &amp; M_PI</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
In the Global Data Definitions section, around line 56, add the lines:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">// audio buffers</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">DRV_I2S_DATA16 __attribute__ ((aligned (32)))</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> App_Tone_Lookup_Table_tone1[MAX_AUDIO_NUM_SAMPLES];</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">DRV_I2S_DATA16 __attribute__ ((aligned (32)))</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> App_Tone_Lookup_Table_tone2[MAX_AUDIO_NUM_SAMPLES];</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
which define the two audio buffers which we will use in a ping-pong fashion, back and forth, each containing up to 9600 samples.&nbsp;</p>
<p class="Element10">
In the Application Callback Functions, around line 70, add the lines:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">void _codecTxBufferComplete()</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> //Next State -- after the buffer complete interrupt.</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_ADD_BUFFER;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">}</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
In the Application Local Functions section, around line 86, add the following function:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">uint32_t _sineTableInit(DRV_I2S_DATA16* buffer, uint32_t frequency,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint32_t sampleRate)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint32_t i,j,k, maxNumCycles;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> uint32_t numSamplesPerCycle;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // generate sine table</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // # of samples for one cycle, e.g. 48 for 1 kHz @ 48,000 samples/sec</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> numSamplesPerCycle = sampleRate / frequency;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // max # of cycles we can fit in buffer</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> maxNumCycles = MAX_AUDIO_NUM_SAMPLES / numSamplesPerCycle;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> k = 0;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> for (j=0; j &lt; maxNumCycles; j++)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> for (i=0; i &lt; numSamplesPerCycle; i++)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // radians = degrees × pi / 180°</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> double radians = (M_PI*(double)(360.0/</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> (double)numSamplesPerCycle)*(double)i)/180.0;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> buffer[i+k].leftData = (int16_t)(0x7FFF*sin(radians));</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> buffer[i+k].rightData = buffer[i+k].leftData;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> k += numSamplesPerCycle;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> return sizeof(DRV_I2S_DATA16)*k; // return size of filled-in buffer</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">}</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
In the Application Initialization and State Machine Functions, around line 123, add the following function:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">void _audioCodecInitialize (AUDIO_CODEC_DATA* codecData)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;handle = DRV_HANDLE_INVALID;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;context = 0;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;bufferHandler =</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> (DRV_CODEC_BUFFER_EVENT_HANDLER) _codecTxBufferComplete;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;txbufferObject1 = (uint8_t *) App_Tone_Lookup_Table_tone1;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;txbufferObject2 = (uint8_t *) App_Tone_Lookup_Table_tone2;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;bufferSize1 = 0;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> codecData-&gt;bufferSize2 = 0;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">}</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
At around line 143, change the APP_Initialize function to:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">void APP_Initialize ( void )</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> /* TODO: Initialize your application's state machine and other</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> * parameters.</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> */</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_OPEN;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> _audioCodecInitialize (&amp;appData.codecData);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.frequency = FREQUENCY; // e.g. 1 kHz</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.pingPong = 1;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">}</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
At around line 163, replace the APP_Tasks function with the following:&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146">void APP_Tasks ( void )</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">{</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Check the application's current state</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> switch ( appData.state )</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Application's initial state</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> case APP_STATE_CODEC_OPEN:</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // See if codec is done initializing</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> SYS_STATUS status = DRV_CODEC_Status(sysObjdrvCodec0);</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> if (SYS_STATUS_READY == status)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // This means the driver can now be opened.</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Open the driver object to get a handle</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.handle = DRV_CODEC_Open(DRV_CODEC_INDEX_0,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_IO_INTENT_WRITE | DRV_IO_INTENT_EXCLUSIVE);</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> if(appData.codecData.handle != DRV_HANDLE_INVALID)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Get sampling rate set up in MHC (e.g. 48000)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.sampleRate =</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_SamplingRateGet(appData.codecData.handle);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_SET_BUFFER_HANDLER;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> break;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Set a handler for the audio buffer completion event</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> case APP_STATE_CODEC_SET_BUFFER_HANDLER:</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BufferEventHandlerSet(appData.codecData.handle,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferHandler,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.context);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Initialize the first buffer with sine wave data</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferSize1 = _sineTableInit(</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> (DRV_I2S_DATA16*)appData.codecData.txbufferObject1,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.frequency, appData.sampleRate);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.pingPong = 1; // indicate buffer 1 to be used first</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_ADD_BUFFER;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> break;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> case APP_STATE_CODEC_ADD_BUFFER:</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Will ping-pong back and forth between buffer 1 and 2</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> if (appData.pingPong==1)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // hand off first buffer to DMA</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BufferAddWrite(appData.codecData.handle,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> &amp;appData.codecData.writeBufHandle1,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.txbufferObject1,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferSize1);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> if (appData.codecData.writeBufHandle1 !=</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BUFFER_HANDLE_INVALID)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // just sent buffer 1 to DMA,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // so fill in buffer 2 for next time</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferSize2 = _sineTableInit(</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> (DRV_I2S_DATA16*)appData.codecData.txbufferObject2,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.frequency, appData.sampleRate);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.pingPong = 2; // switch to second buffer</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_WAIT_FOR_BUFFER_COMPLETE;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> else</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // hand off second buffer to DMA</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BufferAddWrite(appData.codecData.handle,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> &amp;appData.codecData.writeBufHandle2,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.txbufferObject2,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferSize2);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> if (appData.codecData.writeBufHandle2 !=</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> DRV_CODEC_BUFFER_HANDLE_INVALID)</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // just sent buffer 2 to DMA,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> // so fill in buffer 1 for next time</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.codecData.bufferSize1 = _sineTableInit(</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> (DRV_I2S_DATA16*)appData.codecData.txbufferObject1,</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.frequency, appData.sampleRate);</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.pingPong = 1; // back to first buffer</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> appData.state = APP_STATE_CODEC_WAIT_FOR_BUFFER_COMPLETE;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> break;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> // Audio data Transmission under process, wait for callback</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> case APP_STATE_CODEC_WAIT_FOR_BUFFER_COMPLETE:</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> break;</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<span class="Element146"> default:</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> {</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> /* TODO: Handle error in application's state machine. */</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> break;</span>&nbsp;</p>
<p class="Element10">
<span class="Element146"> }</span>&nbsp;</p>
<p class="Element10">
<span class="Element146">}</span>&nbsp;</p>
<p class="Element10">
&nbsp;</p><div class="Element15">
Discussion</div>
<p class="Element10">
We want to output a 1 kHz sine wave audio tone at 48,000 samples/sec, using 16-bit quantization, or 48 samples per millisecond. A struct <span class="Element146">DRV_I2S_DATA16</span> is created with two 16-bit members, one for each channel (left/right) of the audio stream. Two tables are then declared, A<span class="Element146">pp_Tone_Lookup_Table_tone1</span> and<span class="Element146"> 2</span> each with 9600 of these structs, enough to hold 200 ms of audio.&nbsp;</p>
<p class="Element10">
These two buffers are then used, back and forth (ping-pong fashion) to output the tone. The first buffer is filled initially, and then while that is being output via DMA (without the CPU being directly involved), the processor can fill up the second one.&nbsp;</p>
<p class="Element10">
The application starts off by calling <span class="Element146">SYS_Initialize</span> in the file initialization.c, to initialize the various peripherals that were selected in MHC (clocks, timer, I2C, I2S, audio codec, etc.). Near the end of that routine, the application initialization routine <span class="Element146">APP_Initialize</span> is called, where a number of variables are initialized in the structures <span class="Element146">appData</span> and <span class="Element146">appData.codecData</span>.&nbsp;</p>
<p class="Element10">
After initialization, control passes into the routine <span class="Element146">SYS_Tasks</span> in tasks.c, which is just a tight while loop calling either the task routine for the code (e.g. <span class="Element146"><a href="00112.html" target="topic">DRV_WM8904_Tasks</a></span>) or the one for the application (<span class="Element146">APP_Tasks</span>). Both are implemented as state machines.&nbsp;</p>
<p class="Element10">
The initial state in <span class="Element146">APP_Tasks</span> is <span class="Element146">APP_STATE_CODEC_OPEN</span>, where it waits until the codec reports that its initialization is complete. Once the driver is ready, it is opened via a call to <span class="Element146">DRV_CODEC_Open</span> with an intention to write (<span class="Element146">DRV_IO_INTENT_WRITE</span>). If the open call is successful, the application queries the codec driver to get the sampling rate setup in MHC and saves it away.&nbsp;</p>
<p class="Element10">
The application state machine then advances to the state <span class="Element146">APP_STATE_CODEC_SET_BUFFER_HANDLER</span>, where it registers the DMA callback by calling the routine <span class="Element146">DRV_CODEC_BufferEventHandlerSet</span> with the name of the callback function <span class="Element146">_codecTxBufferComplete</span>. The first buffer is then filled by calling the function <span class="Element146">_sineTableInit</span>. It divides the sampling rate (e.g. 48,000) by the frequency (e.g. 1000) to get the number of samples for one cycle (e.g. 48). It then divides this result into the array size <span class="Element146">MAX_AUDIO_NUM_SAMPLE</span> to determine how many cycles can fit into the buffer (e.g. 200).&nbsp;</p>
<p class="Element10">
For each cycle, _sineTableInit calculates the angular displacement in radians for each sample, and then calls the sin function in the C math library to generate a singed value for the buffer. When done, the function returns the size of the filled-in buffer in bytes, since if the frequency was changed, or the sampling rate, the calculated number of cycles might not completely fill the buffer.&nbsp;</p>
<p class="Element10">
The state machine then advances to the state <span class="Element146">APP_STATE_CODEC_ADD_BUFFER</span>, where it makes a call to the routine <span class="Element146">DRV_CODEC_BufferAddWrite</span>, passing the address of the first buffer along with its size, among other parameters. This initiates a DMA function, transferring the contents of the buffer to the I2S peripheral without processor intervention. After a successful return from the <span class="Element146">BufferAddWrite</span> routine, the app calls the function <span class="Element146">_sineTableInit</span> again, this time passing the address of the second buffer, the desired frequency and sampling rate. On return, the next state executed is <span class="Element146">APP_STATE_CODEC_WAIT_FOR_BUFFER_COMPLETE</span>, which is a dummy state (no code) where the state machine waits for the DMA transfer to finish.&nbsp;</p>
<p class="Element10">
When the DMA transfer is finished, the registered callback function <span class="Element146">_codecTxBufferComplete</span> is executed, which tells the state machine it is time to transfer the second buffer to the I2S peripheral. By changing the state back to <span class="Element146">APP_STATE_CODEC_ADD_BUFFER</span>. After initiating DMA transfer of the second buffer, it fills up the first buffer again. This cycle just continues.&nbsp;</p>
<p class="Element10">
Since the same tone is always being output, one could get away with using just one buffer, filling it up initially just once, and keep transferring the same contents over and over via DMA. However with real applications this is seldom the case; rather the audio keeps changing since it will either be coming off of a live source (e.g. microphone), or internal (flash) or external (SD card or USB) storage, in which case during each DMA transfer period the next buffer to be output is being refreshed with new data.&nbsp;</p>
<p class="Element10">
So the ping-pong buffer case is a better model to start with in most cases. If one cannot guarantee how fast audio might be arriving, such as when it comes in via USB from a PC, then sometimes it is necessary to have even more buffers, arranged in a circular fashion, with a pointer to the buffer being filled, and another to the buffer being output.&nbsp;</p>
<p class="Element10">
&nbsp;</p>
<p class="Element10">
<u>For projects using the I2SC interface and the codec as a Slave (the MCU generates the I<sup>2</sup>S clocks):</u>&nbsp;</p>
<p class="Element10">
Start by creating a 32-bit MPLAB Harmony 3 project in MPLAB X IDE by selecting <i>File &gt; New Project</i>. Chose the Configuration name the based on the BSP. Select the appropriate processor (e.g. ATSAME70Q21B).&nbsp;</p>
<p class="Element10">
In the MHC, under Available Components select an appropriate BSP (e.g. SAM E70 Xplained Ultra). Under <i>Audio&gt;Templates</i>, double-click on the desired codec, e.g. WM8904. Answer Yes to all the questions. Click on the Codec component (<i>not</i> the Codec Driver). In the Configuration Options, select I2SC instead of SSC. Answer Yes to all of the questions.&nbsp;</p>
<p class="Element10">
The result will be a project graph that looks like this, after rearranging the boxes: </p><p class="Element10" style="text-align: center;">
<img src="APPS AUDIO audio_tone_E70_i2sc_project_graph.png" border="0" alt="" title=""></p><p class="Element10">
Click on the Codec Driver. In the Configurations Options, under Usage Mode, change Master to Slave. Set the desired Sample Rate if different from the default (48,000) under Sampling Rate.&nbsp;</p>
<p class="Element10">
If using the SAM E70 Xplained Ultra board, in the Clock Diagram, set MOSCEL to Main Crystal, check the Bypass checkbox, and uncheck the RC Crystal Oscillator and Main Crystal Oscillator boxes, to make use the 12 MHz resonator on the board: </p><p class="Element10" style="text-align: center;">
<img src="APPS AUDIO E70 clock diagram main bypass.png" border="0" alt="" title=""></p><p class="Element10">
In the Clock Diagram, in the PCK2 tab of the <strong>Programmable Clock Controller </strong>section, check the On checkbox, and set CSS to MAINCLK (12 MHz).&nbsp;</p>
<p class="Element10">
The following tables show suggested settings for various sample rates in the Clock Diagram when using the I2SC Peripheral in Master mode. Make sure <strong>PLLA Clock</strong> checkbox is checked, and fill in the values for the PLLA Multiplier and Divider boxes. Select the I2S1 tab under <strong>Generic Clock Controller</strong>, set GCLKCSS to PLLACK, fill in the Divider value as shown, and check the checkbox next to it. </p><p class="Element10" style="text-align: center;">
<img src="APPS AUDIO E70 clock diagram I2SC clocks.png" border="0" alt="" title=""></p><p class="Element10">
The values in the first table give the lowest error rate, but have varying PLLACK values so it is best to use the UPPCLKDIV selection for CSS under <strong>Master Clock Controller</strong>, for a Processor Clock of 240 MHz. </p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table2">
<tr>
<td class="Element65" valign="top" width="17%">
<div class="Element66">
Desired Sample Rate&nbsp;</div></td><td class="Element65" valign="top" width="8%">
<div class="Element66">
PLLA Multipler&nbsp;</div></td><td class="Element65" valign="top" width="9%">
<div class="Element66">
PLLA Divider&nbsp;</div></td><td class="Element65" valign="top" width="16%">
<div class="Element66">
PLLACK&nbsp;</div></td><td class="Element65" valign="top" width="15%">
<div class="Element66">
I2SC Generic Clock Divider&nbsp;</div></td><td class="Element65" valign="top" width="18%">
<div class="Element66">
Calculated Sample Rate&nbsp;</div></td><td class="Element65" valign="top" width="18%">
<div class="Element66">
Error&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
8000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
43&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
258 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
126&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
7998&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.025%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
16000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
43&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
258 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
63&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
15997&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.0187%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
44100&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
1&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
16&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
192 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
17&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
41117&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
0.0385%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
48000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
43&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
258 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
21&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
47991&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.0187%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
96000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
3&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
43&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
172 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
7&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
95982&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.0187%&nbsp;</div></td></tr></table></div></div>
<p class="Element10">
The values in the second table have somewhat higher error rates, but use a PLLACK value of 294 MHz which is suitable to be used as a Processor Clock (using the PLLACK selection for CSS) which is closer to the maximum of 300 MHz. </p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table2">
<tr>
<td class="Element65" valign="top" width="17%">
<div class="Element66">
Desired Sample Rate&nbsp;</div></td><td class="Element65" valign="top" width="8%">
<div class="Element66">
PLLA Multipler&nbsp;</div></td><td class="Element65" valign="top" width="9%">
<div class="Element66">
PLLA Divider&nbsp;</div></td><td class="Element65" valign="top" width="16%">
<div class="Element66">
PLLACK&nbsp;</div></td><td class="Element65" valign="top" width="15%">
<div class="Element66">
I2SC Generic Clock Divider&nbsp;</div></td><td class="Element65" valign="top" width="18%">
<div class="Element66">
Calculated Sample Rate&nbsp;</div></td><td class="Element65" valign="top" width="18%">
<div class="Element66">
Error&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
8000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
49&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
294 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
144&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
7975&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.3125%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
16000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
49&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
294 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
72&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
15950&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.3125%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
44100&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
49&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
294 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
26&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
41170&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
0.1587%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
48000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
2&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
49&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
294 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
24&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
47851&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.3104%&nbsp;</div></td></tr><tr>
<td class="Element67" valign="top" width="17%">
<div class="Element68">
96000&nbsp;</div></td><td class="Element67" valign="top" width="8%">
<div class="Element68">
3&nbsp;</div></td><td class="Element67" valign="top" width="9%">
<div class="Element68">
49&nbsp;</div></td><td class="Element67" valign="top" width="16%">
<div class="Element68">
294 MHz&nbsp;</div></td><td class="Element67" valign="top" width="15%">
<div class="Element68">
12&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
95703&nbsp;</div></td><td class="Element67" valign="top" width="18%">
<div class="Element68">
-0.3094%&nbsp;</div></td></tr></table></div></div>
<p class="Element10">
It is also possible to change the audio format from 16 to 32-bits. This changes need to be done in the MHC in both the Codec Driver and I2SC Peripheral.</p></div>
</div>
</div>
<!-- End Page Content -->

<!-- Begin Page Footer -->
<div class="Element95">
<a href="00054.html" target="topic">Audio Overview</a> &gt; <a href="00055.html" target="topic">Creating Your First Audio Application from Scratch</a></div>
<div class="Element93">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element3">
MPLAB Harmony Audio Help</div>
</td><td width="25%">
<div class="Element4">
<a href="contents.html" target="tocidx">Contents</a> | <a href="00054.html" target="topic">Home</a></div>
</td><td width="25%">
<div class="Element91">
<a href="00056.html" target="topic">Previous</a> | <a href="00054.html" target="topic">Up</a> | <a href="00057.html" target="topic">Next</a></div>
</td><td width="25%">
<div class="Element97">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: AUDIO_OVR Creating an Audio Porject from Scratch Topic Title: Creating Your First Audio Application from Scratch)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com" target="_blank">Microchip Support</a></div>
</td></tr></table></div>

<!-- End Page Footer -->
</div>
</div>

<!-- End Client Area -->
</body></html>