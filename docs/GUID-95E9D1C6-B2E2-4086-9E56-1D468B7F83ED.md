# Math Libraries Help

## Introduction

This section provides descriptions of the Math libraries that are available in MPLAB-X Harmony 3.

### Description

The fixed point math libraries use fractional value represented in &quot;Q&quot; format as described below

**Integer Representation of Fractions**

Fractional representation of a real number is given by:

_Qn.m_ where:

• _n_ is the number of data bits to the left of the radix point

• _m_ is the number of data bits to the right of the radix point

• a signed bit is implied, and takes one bit of resolution

• Shorthand may eliminate the leading 0, such as in Q0.15, which may be shortened to Q15, and similarly Q0.31, which is shortened to Q31

_Qn.m_ numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. Therefore, the range of the numerical value is:

<center>-2<sup>(n-1)</sup> to [2<sup>(n-1)</sup>) - 2<sup>(-m)</sup>]; with a resolution of 2<sup>(-m)</sup>.</center>

A Q16 format number (Q15.16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259 (or 2<sup>(-16)</sup>). For example, a numerical representation of the number 3.14159 in Q2.13 notation would be:

<center>3.14159 \* 213<sup>(13)</sup> = 25735.9 =\\&gt; 0x6488</center>

And converting from the Q7.8 format with the value 0x1D89 would be:

<center>0x1D89 / 2<sup>(8)</sup> = 7561 / 256 =\\&gt; 29.5316, accurate to 0.00391</center>

The majority of the math libraries uses functions with variables in Q15 or Q31 format. This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary. All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution. Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.

Usually, a Q16, Q31 and version of each function is available. Floating point versions are also available for CMSIS-DSP.

## CMSIS-DSP

### CMSIS-DSP Library

### Introduction

This topic describes the CMSIS-DSP Library.

### Description

The Cortex Microcontroller System Interface Standard-DSP (CMSIS-DSP) Library is the ARM® DSP Math Library integrated with MPLAB Harmony. It can only be used for ARM Cortex cores M0 through M7.

The CMSIS-DSP Library contains functions implementing 16-bit (Q15) and 32-bit (Q31) fixed-point math, as well as 32-bit floating point (F32) math.

Functions included in the CMSIS-DSP Library include complex math, vector math, matrix math, digital filters, adaptive filters, control and transforms. In many cases, these functions require specific data structures to operate, which are detailed in the header file.

### Using the Library

This topic describes the basic architecture of the CMSIS-DSP Library and provides information and examples on its use.

### Description

**Interface Header File:**  **arm_math.h**

The interface to the DSP Fixed-Point library is defined in the arm_math.h header file. Any C language source (.c) file that uses the DSP Fixed-Point library must include arm_math.h.

### Library Source Files

The CMSIS-DSP Library source files are provided in the dev_packs repo under:

packs\\arm\\CMSIS\\\&lt;Version Number\\&gt;\\CMSIS\\DSP\\Source

The source is not generated to the Harmony 3 project but will give the implementation details and the ability to rebuild the library.

### Library Files

The CMSIS-DSP Library archive file is generated by MHC to the following project directory:

firmware\\src\\packs\\CMSIS\\CMSIS\\DSP\\Lib\\GCC

The following prebuilt versions of the library are available:

libarm_cortexM0l_math.a

libarm_cortexM3l_math.a

libarm_cortexM4l_math.a

libarm_cortexM4lf_math.a

libarm_cortexM7l_math.a

libarm_cortexM7lfdp_math.a

libarm_cortexM7lfsp_math.a

The naming convention is as follows:

libarm_\\&lt;ARM,cortex\\&gt;\\&lt;core\\&gt;\\&lt;codes\\&gt;_math.a

The cores are: M0,M3,M4, or M7,

The codes are as follows:

\\&lt;l,b\\&gt; - little or big endian byte order

\\&lt;dp,sp\\&gt; – double or single precision

\\&lt;f\\&gt; - Floating Point Unit on

### Configuring the Library using MHC

Provides information on using MPLAB Harmony Configurator (MHC) to configure the library.

### Description

The library can be generated by the MPLAB Harmony Configurator to any MPLAB® Harmony 3 project that has the CMSIS Pack component, i.e. only MPLAB® Harmony 3 projects that target ARM processors. Select the CMSIS Pack component highlighted in from the Project Graph.

The Configuration Options window looks like the following, with the selection for the CMSIS-DSP Library

The speed optimized library for the given processor will be generated to the project.

### Library Overview

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the CMSIS-DSP Library.

### Library Interface

### Section

### Description

**Basic Math Functions**

Basic vector math functions.

**Fast Math Functions**

This set of functions provides a fast approximation to sine, cosine, and square root.

**Complex Math Functions**

This set of functions operates on complex data vectors. The data in the complex arrays is stored in an interleaved fashion (real, imaginary, real, imaginary, ...). In the API functions, the number of samples in a complex array refers to the number of complex values; the array contains twice this number of real values.

**Filter**

Implementation of biquad cascade, IIR Direct Form I and II Transposed, convolution, correlation, FIR, IIR Lattice, LMS, and Normalized LMS filter functions

**Matrix Functions**

This set of functions provides basic matrix math operations. The functions operate on matrix data 
structures.

**Transforms**

FFT, DCT Type IV, and Real FFT functions.

**Statistical Functions**

Maximum, Minimum, Mean, Power, RMS, Standard Deviation and Variance calculations.

**Support Functions**

Vector Copy, Vector Fill, and conversion between F32, Q15, Q32 and Q7 values.

**Interpolation Functions**

Linear and Bilinear interpolation functions.

**Motor Control Functions**
 
PID Motor Control and Vector Clark, Vector Park, and Vector Inverse

The CMSIS-DSP Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.

Floating point versions of the function are also available.

### Library Interface

Provides information on the list of available functions and interfaces.

### Description

Documentation of the available CMSIS-DSP Library functions and interfaces and their descriptions can be found at:

https://arm-software.github.io/CMSIS_5/DSP/html/modules.html

## DSP

### DSP Fixed-Point Math Libraries

### Introduction

This topic describes the DSP Fixed-Point Math Libraries.

### Description

The DSP Fixed-Point Library are available for the PIC32MZ family of microcontrollers. This library was created from optimized 
assembly routines written specifically for devices with microAptiv™ core features that utilize DSP ASE.

_ **The LIBQ library is required to use the DSP library.** _

The DSP Fixed-Point Library contains building block functions for developing digital signal processing algorithms. The library supports the Q15 and Q31 fractional data formats. The functions are implemented in efficient assembly specifically targeted at the DSP extensions in this core family.

The library makes these functions available in a simple C-callable structure.

Functions included in the DSP Fixed-Point Library include complex math, vector math, matrix math, digital filters, and transforms.

In many cases, these functions require specific data structures to operate, which are detailed in the header file and examples.

**Using the Library**

This topic describes the basic architecture of the DSP Fixed-Point Library and provides information and examples on its use.

### Description

**Interface Header File:**  **dsp.h,**

The interface to the DSP Fixed-Point library is defined in the dsp.h header file. Any C language source (.c) file that uses the DSP

Fixed-Point library must include dsp.h. This file is automatically included by definitions.h when the library is generated using MHC.

Some functions make special use of the optimized fixed-point math library libq.h. For use of those functions, the libq.h file 
must also be included in a project. The libq.h file is also installed with MPLAB Harmony. Specific notes within each function will describe if the function is dependent on the LibQ Fixed-Point Math Library.

Library Files:

The DSP Fixed-Point library archive (.a) files are installed with MPLAB Harmony. Although there are two PIC32 DSP files, the linker will only utilize one of these depending on your device usage.

This library is only available in prebuilt binary form, with prototypes for each function described in the dsp.h file. The available

library versions are:

• dsp_mips32_mz_ef_nfO3.a

• dsp_mips32_mz_ef_nfOs.a

The naming convention for these libraries is as follows:

\\&lt;name\\&gt;_\\&lt;arch\\&gt;_\\&lt;core\\&gt;_\\&lt;fpu\\&gt;_\\&lt;codes\\&gt;.a

where, &quot;name&quot; is the name of the library (DSP); &quot;arch&quot; is the 32 MIPS architecture (MIPS32); &quot;core&quot; is the microAptive core with

DSP ASE extensions (MZ); and &quot;fpu&quot; indicates that a Floating Point Unit(FPU) is available. The &quot;codes&quot; are as follows:

• \\&lt;nf, fpu\\&gt; - FPU disabled or enabled

• \\&lt;O3,OS\\&gt; - Fully optimized for speed or optimized for size.

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries.

The project configuration should now contain the Math Libraries block.

Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.

NOTE: LIBQ is also required to be selected.

### Library Overview

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the

DSP Fixed-Point Math Library.

**Library Interface Section Description**

**Complex Math Functions**

General mathematical operations using a complex structure with the form (a + bi)

**Vector Math Functions**

Mathematical operations on a array of numbers or vector

**Matrix Math Functions**

Mathematical operations on a matrix

**Digital Filter Functions**

FIR and IIR filtering functions with various architectures

**Transform Functions**

FFT, Windows and related transform elements

**Support Functions**

Quick support functions for numerical transform

The DSP Fixed-Point Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.

A majority of the DSP Fixed-Point Library uses functions with variables in Q15 or Q31 format. Representations of these numbers are given in **Data Types and Constants** in the Library Interface section, and generally are int16_t (for Q15 fractional representation) and int32_t (for Q31 fractional representation). This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary.

All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution.

Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.

### Library Interface

**Functions**

**Name Description**

DSP_ComplexAdd32 Calculates the sum of two complex numbers.

DSP_ComplexConj16 Calculates the complex conjugate of a complex number.

DSP_ComplexConj32 Calculates the complex conjugate of a complex number.

DSP_ComplexDotProd32 Calculates the dot product of two complex numbers.

DSP_ComplexMult32 Multiplies two complex numbers.

DSP_ComplexScalarMult32 Multiplies a complex number and a scalar number.

DSP_ComplexSub32 Calculates the difference of two complex numbers.

DSP_FilterFIR32 Performs a Finite Infinite Response (FIR) filter on a vector.

DSP_FilterFIRDecim32 Performs a decimating FIR filter on the input array.

DSP_FilterFIRInterp32 Performs an interpolating FIR filter on the input array.

DSP_FilterIIR16 Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.

DSP_FilterIIRBQ16 Performs a single-pass IIR Biquad Filter.

DSP_FilterIIRBQ16_cascade8 Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

DSP_FilterIIRBQ16_cascade8_fast Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

DSP_FilterIIRBQ16_fast Performs a single-pass IIR Biquad Filter.

DSP_FilterIIRBQ16_parallel8 Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

DSP_FilterIIRBQ16_parallel8_fast Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

DSP_FilterIIRBQ32 Performs a high resolution single-pass IIR Biquad Filter.

DSP_FilterIIRSetup16 Converts biquad structure to coeffs array to set up IIR filter.

DSP_FilterLMS16 Performs a single sample Least Mean Squares FIR Filter.

DSP_MatrixAdd32 Addition of two matrices C = (A + B).

DSP_MatrixEqual32 Equality of two matrices C = (A).

DSP_MatrixInit32 Initializes the first N elements of a Matrix to the value num.

DSP_MatrixMul32 Multiplication of two matrices C = A x B.

DSP_MatrixScale32 Scales each element of an input buffer (matrix) by a fixed number.

DSP_MatrixSub32 Subtraction of two matrices C = (A - B).

DSP_MatrixTranspose32 Transpose of a Matrix C = A (T).

DSP_TransformFFT16 Creates an Fast Fourier Transform (FFT) from a time domain input.

DSP_TransformFFT16_setup Creates FFT coefficients for use in the FFT16 function.

DSP_TransformFFT32 Creates an Fast Fourier Transform (FFT) from a time domain input.

DSP_TransformFFT32_setup Creates FFT coefficients for use in the FFT32 function.

DSP_TransformIFFT16 Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.

DSP_TransformWindow_Bart16 Perform a Bartlett window on a vector.

DSP_TransformWindow_Bart32 Perform a Bartlett window on a vector.

DSP_TransformWindow_Black16 Perform a Blackman window on a vector.

DSP_TransformWindow_Black32 Perform a Blackman window on a vector.

DSP_TransformWindow_Cosine16 Perform a Cosine (Sine) window on a vector.

DSP_TransformWindow_Cosine32 Perform a Cosine (Sine) window on a vector.

DSP_TransformWindow_Hamm16 Perform a Hamming window on a vector.

DSP_TransformWindow_Hamm32 Perform a Hamming window on a vector.

DSP_TransformWindow_Hann16 Perform a Hanning window on a vector.

DSP_TransformWindow_Hann32 Perform a Hanning window on a vector.

DSP_TransformWindow_Kaiser16 Perform a Kaiser window on a vector.

DSP_TransformWindow_Kaiser32 Perform a Kaiser window on a vector.

DSP_TransformWinInit_Bart16 Create a Bartlett window.

DSP_TransformWinInit_Bart32 Create a Bartlett window.

DSP_TransformWinInit_Black16 Create a Blackman window.

DSP_TransformWinInit_Black32 Create a Blackman window.

DSP_TransformWinInit_Cosine16 Create a Cosine (Sine) window.

DSP_TransformWinInit_Cosine32 Create a Cosine (Sine) window.

DSP_TransformWinInit_Hamm16 Create a Hamming window.

DSP_TransformWinInit_Hamm32 Create a Hamming window.

DSP_TransformWinInit_Hann16 Create a Hanning window.

DSP_TransformWinInit_Hann32 Create a Hanning window.

DSP_TransformWinInit_Kaiser16 Create a Kaiser window.

DSP_TransformWinInit_Kaiser32 Create a Kaiser window.

DSP_VectorAbs16 Calculate the absolute value of a vector.

DSP_VectorAbs32 Calculate the absolute value of a vector.

DSP_VectorAdd16 Calculate the sum of two vectors.

DSP_VectorAdd32 Calculate the sum of two vectors.

DSP_VectorAddc16 Calculate the sum of a vector and a constant.

DSP_VectorAddc32 Calculate the sum of a vector and a constant.

DSP_VectorAutocorr16 Computes the Autocorrelation of a Vector.

DSP_VectorBexp16 Computes the maximum binary exponent of a vector.

DSP_VectorBexp32 Computes the maximum binary exponent of a vector.

DSP_VectorChkEqu32 Compares two input vectors, returns an integer &#39;1&#39; if equal, and &#39;0&#39; if not equal.

DSP_VectorCopy Copies the elements of one vector to another.

DSP_VectorCopyReverse32 Reverses the order of elements in one vector and copies them into another.

DSP_VectorDivC Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.

DSP_VectorDotp16 Computes the dot product of two vectors, and scales the output by a binary factor.

DSP_VectorDotp32 Computes the dot product of two vectors, and scales the output by a binary factor

DSP_VectorExp Computes the EXP (e\^x) of the first N elements of inVector, and stores the result in outVector.

DSP_VectorFill Fills an input vector with scalar data.

DSP_VectorLn Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.

DSP_VectorLog10 Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.

DSP_VectorLog2 Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.

DSP_VectorMax32 Returns the maximum value of a vector.

DSP_VectorMaxIndex32 Returns the index of the maximum value of a vector.

DSP_VectorMean32 Calculates the mean average of an input vector.

DSP_VectorMin32 Returns the minimum value of a vector.

DSP_VectorMinIndex32 Returns the index of the minimum value of a vector.

DSP_VectorMul16 Multiplication of a series of numbers in one vector to another vector.

DSP_VectorMul32 Multiplication of a series of numbers in one vector to another vector.

DSP_VectorMulc16 Multiplication of a series of numbers in one vector to a scalar value.

DSP_VectorMulc32 Multiplication of a series of numbers in one vector to a scalar value.

DSP_VectorNegate Inverses the sign (negates) the elements of a vector.

DSP_VectorRecip Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.

DSP_VectorRMS16 Computes the root mean square (RMS) value of a vector.

DSP_VectorShift Shifts the data index of an input data vector.

DSP_VectorSqrt Computes the square root of the first N elements of inVector, and stores the result in outVector.

DSP_VectorStdDev16 Computes the Standard Deviation of a Vector.

DSP_VectorSub16 Calculate the difference of two vectors.

DSP_VectorSub32 Calculate the difference of two vectors.

DSP_VectorSumSquares16 Computes the sum of squares of a vector, and scales the output by a binary factor.

DSP_VectorSumSquares32 Computes the sum of squares of a vector, and scales the output by a binary factor.

DSP_VectorVari16 Computes the variance of N elements of a Vector.

DSP_VectorVariance Computes the variance of N elements of inVector.

DSP_VectorZeroPad Fills an input vector with zeros.

mul16 multiply and shift integer

mul16r multiply and shift Q15

mul32 multiply and shift Q31

SAT16 saturate both positive and negative Q15

SAT16N saturate negative Q15

SAT16P saturate positive Q15

**Description**

_ **Functions** _

**DSP_ComplexAdd32 Function**

Calculates the sum of two complex numbers.

**Description**

Function DSP_ComplexAdd32:

void DSP_ComplexAdd32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the sum of two complex numbers, indata1 and indata2, and stores the complex result in Output. Complex numbers must be in the structural form that includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. All values are in Q31 fractional data format. (a + bi) + (c + di) =\\&gt; (a + c) + (b + d)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

int32c test_complex_2 = {0x73333333,0xB3333334};

_// (0.9 - 0.6i)_

res=&amp;result;

input1=&amp;test_complex_1;

input2=&amp;test_complex_2;

DSP_ComplexAdd32(input1, input2, res);

_// result = {0x73333333, 0xC0000000} = (0.9 - 0.5i)_

**C**

**void**  **DSP_ComplexAdd32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP_ComplexConj16 Function**

Calculates the complex conjugate of a complex number.

**Description**

DSP_ComplexConj16:

void DSP_ComplexConj16(int16c \*indata, int16c \*Output);

CCalculates the complex conjugate of Indata, and stores the result in Outdata. Both numbers must be in the complex number data structure which includes real and imaginary components. Values are in Q15 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =\\&gt; (a - bi)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata pointer to input complex number (int16c)

**Returns**

pointer to result complex numbers (int16c)

None.

**Remarks**

None.

**Example**

int16c \*res, result;

int16c \*input1;

int16c test_complex_1 = {0x4000,0x0CCC};

_// (0.5 + 0.1i)_

res=&amp;result;

input1=&amp;test_complex_1;

DSP_ComplexConj16(input1, res);

_// result = {0x4000, 0xF334} = (0.5 - 0.1i)_

**C**

**void**  **DSP_ComplexConj16** (int16c \* **indata** , int16c \* **Output** );

**DSP_ComplexConj32 Function**

Calculates the complex conjugate of a complex number.

**Description**

Function DSP_ComplexConj32:

void DSP_ComplexConj32(int32c \*indata, int32c \*Output);

Calculates the complex conjugate of indata, and stores the result in Output. Both numbers must be in the complex number data structure, which includes real and imaginary components. Values are in Q31 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =\\&gt; (a - bi)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1;

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

res=&amp;result;

input1=&amp;test_complex_1;

DSP_ComplexConj32(input1, res);

_// result = {0x40000000, 0xF3333334} = (0.5 - 0.1i)_

**C**

**void**  **DSP_ComplexConj32** (int32c \* **indata** , int32c \* **Output** );

**DSP_ComplexDotProd32 Function**

Calculates the dot product of two complex numbers.

**Description**

Function DSP_ComplexDotProd32:

void DSP_ComplexDotProd32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the dot product of two complex numbers, indata1 and indata2, and stores the result in Output. All numbers must be in complex structural format that includes real and imaginary components, and the numbers are in fractional Q31 format. The function will saturate the output if it exceeds maximum or minimum ratings. The formula for the dot product is as follows:

Output(real) = (Input1.re \* Input2.re) + (Input1.im \* Input2.im); Output(img) = [(Input1.re \* Input2.im) - (Input1.im \* Input2.re)]i (a +

bi) dot (c + di) =\\&gt; (a \* c + b \* d) + (a \* d - b \* c)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

int32c test_complex_2 = {0x73333333,0xB3333334};

_// (0.9 - 0.6i)_

res=&amp;result;

input1=&amp;test_complex_1;

input2=&amp;test_complex_2;

DSP_ComplexDotProd32(input1, input2, res);

_// result = {0x31EB851E, 0xCE147AE3} = (0.39 - 0.39i)_

**C**

**void**  **DSP_ComplexDotProd32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP_ComplexMult32 Function**

Multiplies two complex numbers.

**Description**

Function DSP_ComplexMult32:

void DSP_ComplexMult32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Multiplies two complex numbers, indata1 and indata2, and stores the complex result in Output. All numbers must be in the int32c complex data structure. All data is in Q31 fractional format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re \* Input2.re) - (Input1.im \* Input2.im); Output(img) = [(Input1.re \* Input2.im) + (Input1.im \*

Input2.re)]i (a + bi) x (c + di) =\\&gt; (a \* c - b \* d) + (a \* d + b \* c)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

int32c test_complex_2 = {0x73333333,0xB3333334};

_// (0.9 - 0.6i)_

res=&amp;result;

input1=&amp;test_complex_1;

input2=&amp;test_complex_2;

DSP_ComplexMult32(input1, input2, res);

_// result = {0x4147AE14, 0xE51EB8551} = (0.51 - 0.21i)_

**C**

**void**  **DSP_ComplexMult32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP_ComplexScalarMult32 Function**

Multiplies a complex number and a scalar number.

**Description**

Function DSP_ComplexScalarMult32:

void DSP_ComplexScalarMult32(int32c \*indata, int32_t Scalar, int32c \*Output);

Multiplies a complex number, indata, by a scalar number, Scalar, and stores the result in Output. indata and Output must be in

int32c structure with real and imaginary components. All data must be in the fractional Q31 format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re \* Scalar); Output(img) = [(Input1.im \* Scalar)]i (a + bi) \* C =\\&gt;

(a \* C + b \* Ci)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata pointer to input complex number (int32c)

Scalar fractional scalar input value (int32_t)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1;

int32_t scalarInput = 0x20000000; _// 0.25_

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

res=&amp;result;

input1=&amp;test_complex_1;

DSP_ComplexScalarMult32(input1, scalarInput, res);

_// result = {0x10000000, 0x03333333} = (0.125 + 0.025i)_

**C**

**void**  **DSP_ComplexScalarMult32** (int32c \* **indata** , int32_t **Scalar** , int32c \* **Output** );

**DSP_ComplexSub32 Function**

Calculates the difference of two complex numbers.

**Description**

Function DSP_ComplexSub32:

void DSP_ComplexSub32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the difference of two complex numbers, indata1 less indata2, and stores the complex result in Output. Both numbers must be in a complex data structure, which includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. Real and imaginary components are in the Q31 fractional data format. (a + bi) - (c + di) =\\&gt; (a

- c) + (b - d)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test_complex_1 = {0x40000000,0x0CCCCCCC};

_// (0.5 + 0.1i)_

int32c test_complex_2 = {0x73333333,0xB3333334};

_// (0.9 - 0.6i)_

res=&amp;result;

input1=&amp;test_complex_1;

input2=&amp;test_complex_2;

DSP_ComplexSub32(input1, input2, res);

_// result = {0xCCCCCCCD, 0x59999998} = (-0.4 + 0.7i)_

**C**

**void**  **DSP_ComplexSub32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP_FilterFIR32 Function**

Performs a Finite Infinite Response (FIR) filter on a vector.

**Description**

Function DSP_FilterFIR32:

void DSP_FilterFIR32(int32_t \*outdata, int32_t \*indata, int32_t \*coeffs2x, int32_t \*delayline, int N, int K, int scale);

Performs an FIR filter on the vector indata, and stores the output in the vector outdata. The number of samples processed in the array is given by N. The number of filter taps is given by K. The values are scaled upon input by the binary scaling factor (right shift), scale. The array of 2\*K coefficients is contained in the array coeffs2x, where the values are in order b0, b1, b2... and repeated. Lastly the delayline is an array of K values that are initialized to zero and represent previous values. All values are in fractional Q31 data format. The function will saturate results if minimum or maximum values are exceeded.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four. K must be greater than 2 and a multiple of 2. delayline must have K elements, and be initialized to zero. coeffs2x must have 
2\*K elements.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32_t)

indata pointer to source array of elements (int32_t)

coeffs2x pointer to an array of coefficients (int32_t)

delayline pointer to an array of delay variables (int32_t)

N number of points in the array to process (int) number of samples (int)

K number of filter taps

scale binary scaler divisor (1 / 2\^scale) (int)

**Returns**

None.

**Remarks**

Filter coefs must be repeated within the array. The array is twice as large as the number of taps, and the values are repeated in order b0, b1, b2,...bn, b0, b1, b2,... bn. The function updates the delayline array, which must be K elements long. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.

**Example**

**#define** TAPS 4

**#define** numPOINTS 256

int filterN = numPOINTS;

int filterK = TAPS;

int filterScale = 1; _// scale output by 1/2\^1 =\\&gt; output \* 0.5_

int32_t FilterCoefs[TAPS\*2] = {0x40000000, 0x20000000, 0x20000000, 0x20000000,

0x40000000, 0x20000000, 0x20000000, 0x20000000};

_// note repeated filter coefs, A B C D A B C D_

_// 0.5, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25_

int32_t outFilterData[numPOINTS]={0};

int32_t inFilterData[numPOINTS];

int filterDelayLine[TAPS]={0};

while ( **true** )

{

_// put some data into input array, inFilterData, here //_

DSP_FilterFIR32(outFilterData, inFilterData, FilterCoefs, filterDelayLine,

filterN, filterK, filterScale);

}

**C**

**void**  **DSP_FilterFIR32** (int32_t \* **outdata** , int32_t \* **indata** , int32_t \* **coeffs2x** , int32_t \*

**delayline** , int  **N** , int  **K** , int  **scale** );

**DSP_FilterFIRDecim32 Function**

Performs a decimating FIR filter on the input array.

**Description**

Function DSP_FilterFIRDecim32:

void DSP_FilterFIRDecim32(int32_t \*outdata, int32_t \*indata, int32_t \*coeffs, int32_t \*delayline, int N, int K, int scale, int rate);

Compute a FIR decimation filter on the input vector indata, and store the results to the vector outdata. The total number of output elements is set by N, and therefore the outdata array must be at least N in length. The decimation ratio is given by rate. The input is sampled every integer value of rate, skipping every (rate-1) input samples. The input array must therefore be (rate\*N) samples long. The amount of filter taps is specified by K. Coeffs specifies the coefficients array. The delayline array holds delay inputs for 
calculation, and must be initialized to zero prior to calling the filter. Both coeffs and delayline must be K in length. Scale divides the input by a scaling factor by right shifting the number of bits (1/2\^scale). All values of input, output, and coeffs are given in Q31 fractional data format. The function will saturate if the output value exceeds the maximum or minimum value.

Y = b0 \* X0 + (b1 \* X(-1)) + (b2 \* X(-2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have K elements, and be initialized to zero.

coeffs must have K elements. outdata must have N elements indata must have (N\*rate) elements

**Parameters**

**Parameters Description**

outdata pointer to output array of elements (int32_t)

indata pointer to input array of elements (int32_t)

coeffs pointer to an array of coefficients (int32_t)

delayline pointer to an array of delay variables (int32_t)

N number of output elements to be processed (int)

K number of filter taps and coeffs (int)

scale binary scaler divisor (1 / 2\^scale) (int)

rate decimation ratio (int)

**Returns**

None.

**Remarks**

Coefs are loaded into the array with corresponding to the least delay first (C0, C(-1), C(-2)). K must be greater than rate. Even while decimating the input stream, every input passes through the delayline. So FIR filters of arbitrary length will give the same

output as a non-decimating FIR, just with fewer responses.

**Example**

**#define** N 8 _// number of output samples_

**#define** TAPS 5

**#define** SKIP 3

int testFilterN = N; _// number of output elements_

int testFilterK = TAPS; _// number of taps_

int testFilterRate = SKIP; _// decimation rate R_

int32_t outFiltDataDec[N]={0};

int32_t \*inTestFilter[N\*SKIP];

int filtScaleNum = 1; _// scale output (1 /2\^n) =\\&gt; Y \* 0.5_

int32_t filtDelayTest[8]={0}; _// always initialize to zero_

_// get pointer to input buffer here //_

inTestFilter = &amp;inputBuffer;

DSP_FilterFIRDecim32(outFiltDataDec, inTestFilter, inTestCoefs,

filtDelayTest, testFilterN, testFilterK, filtScaleNum, testFilterRate);

**C**

**void**  **DSP_FilterFIRDecim32** (int32_t \* **outdata** , int32_t \* **indata** , int32_t \* **coeffs** , int32_t \*

**delayline** , int  **N** , int  **K** , int  **scale** , int  **rate** );

**DSP_FilterFIRInterp32 Function**

Performs an interpolating FIR filter on the input array.

**Description**

Function DSP_FilterFIRInterp32:

void DSP_FilterFIRInterp32(int32_t \*outdata, int32_t \*indata, int32_t \*coeffs, int32_t \*delayline, int N, int K, int scale, int rate);

Perform an interpolating FIR filter on the first N samples of indata, and stores the result in outdata. The number of output elements is N\*rate. The number of filter taps, K, must be an even multiple of N. The coefficients array, Coeffs, must be K elements long. The delay line array, delayline, must be K/R elements long, and be initialized to zero. All data elements must be in Q31 fractional data format. Scaling is performed via binary shift on the input equivalent to (1/2\^shift). The function will saturate the output if it exceeds maximum or minimum values. The function creates R output values for each input value processed. The delayline of previous values is processed with R elements of the coefficient array. Numerically:

Y(1,0) = X(0)\*C(0) + X(-1)\*C(rate) + X(-2)\*C(2\*rate) ... Y(1,1) = X(0)\*C(1) + X(-1)\*C(rate+1) + X(-2)\*C(2\*rate + 1) ... Y(1,rate) =

X(0)\*C(N) + X(-1)\*C(rate+N) + X(-2)\*C(2\*rate + N) ...

where output Y corresponds to (input,rate) different outputs, input X has (M/rate) sample delays and C is the coefficient array.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K/R) elements, and be initialized to zero. K (taps) must be an even multiple of R (rate). outdata must have R\*N elements.

**Parameters**

**Parameters Description**

outdata pointer to output array of elements (int32_t)

indata pointer to input array of elements (int32_t)

coeffs pointer to an array of coefficients (int32_t)

delayline pointer to an array of delay variables (int32_t)

N number of output elements to be processed (int)

K number of filter taps and coeffs (int)

scale binary scaler divisor (1 / 2\^scale) (int)

rate decimation ratio (int)

**Returns**

None.

**Remarks**

The function processes each input (rate) times. With each pass, coefficients are offset so that (K/rate) multiply accumulate cycles

occur.

**Example**

_// interpret evenly 1/3 spaced values_

**#define** N 4 _// number of output samples_

**#define** TAPS 6

**#define** INTERP 3

int ifiltN = N;

int ifiltK = TAPS; _// k must be an even multiple of R_

int ifiltR = INTERP;

int32_t ifiltOut[N\*INTERP]={0};

int32_t ifiltDelay[2]={0}; _// must be initialized to zero_

int ifiltScale = 0; _// no scaling_

int32_t ifiltCoefsThirds[TAPS]={0x2AAAAAA9, 0x55555555,0x7FFFFFFE,

0x55555555,0x2AAAAAA9,0x00000000};

_// 0.333333, 0.6666667, 0.99999999, 0.6666667, 0.33333333, 0_

int32_t ifiltInput[N]={0x0CCCCCCD, 0x19999999, 0x26666666, 0x33333333};

_// 0.1, 0.2, 0.3, 0.4_

DSP_FilterFIRInterp32(ifiltOut, ifiltInput, ifiltCoefsThirds, ifiltDelay,

ifiltN, ifiltK, ifiltScale, ifiltR);

_// ifiltOut = {0x04444444, 0x08888889, 0x0CCCCCCD, 0x11111111, 0x15555555, 0x19999999,_

_// 0x1DDDDDDD, 0x22222221, 0x26666665, 0x2AAAAAAA,0x2EEEEEEE, 0x33333332}_

_// = 0.0333, 0.0667, 0.1, 0.1333, 0.1667, 0.2, 0.2333, 0.2667, 0.3, 0.3333, 0.3667, 0.4_

**C**

**void**  **DSP_FilterFIRInterp32** (int32_t \* **outdata** , int32_t \* **indata** , int32_t \* **coeffs** , int32_t \*

**delayline** , int  **N** , int  **K** , int  **scale** , int  **rate** );

**DSP_FilterIIR16 Function**

Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.

**Description**

Function DSP_FilterIIR16:

int16_t DSP_FilterIIR16(int16_t in, int16_t \*coeffs, int16_t \*delayline, int B, int scale);

Performs a single element cascaded biquad IIR filter on the input, in. The filter contains B number of biquad sections, and cascades the output of one to the input of the next. B must be greater than 2 and a multiple of 2. The int16_t output generated by the function is the computation from the final biquad stage. Delay pipeline array delayline must contain 2\*B values and be initialized to zero prior to use. The coefficient array must contain 4\*B elements, and must be set up in order of biquad a1, a2, b1, b2. A binary (right shift) factor, scale, will scale the output equivalent to (1/2\^scale). All numerical values must be in Q15 fractional data format. The function will saturate values if maximum or minimum values are exceeded.

Y = X0 + (b1 \* X(-1)) + (b2 \* X(-2) + (a1 \* Y(-1)) + (a2 \* Y(-2))

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. B must be greater than 2 and a multiple of 2. delayline

must have 2\*B elements, and be initialized to zero. coeffs must have 4\*B elements.

**Parameters**

**Parameters Description**

in input data element X (int16_t)

coeffs pointer to an array of coefficients (int16_t)

delayline pointer to an array of delay variables (int16_t)

B number of cascaded biquad filter groups to process (int)

scale binary scaler divisor (1 / 2\^scale) (int)

**Returns**

Sample output Y (int16_t)

**Example**

**#define** B 8 _// use \* biquad filters in cascade_

int dataSamples = 256;

int i, j;

biquad16 bquad[B];

int16_t coefs[4\*B]= {0};

int16_t delaylines[2\*B]= {0};

int16_t Y, X;

int scaleBquad = 1; _// scale output (1 /2\^n) =\\&gt; Y \* 0.5_

_// do something to set up coefs, for instance this example //_

for (j=0; jRemarks:Filter coefs must be stored within the array as a1, a2, b1, b2, a1, a2, b1, b2, in order of biquads form input to output. A function to translate the coeffs from biquad structure to coeffs is available in DSP_FilterIIRSetup16. The function updates the delayline array, which must be 2\*B elements **long**. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.

**C**

int16_t **DSP_FilterIIR16** (int16_t **in** , int16_t \* **coeffs** , int16_t \* **delayline** , int  **B** , int  **scale** );

**DSP_FilterIIRBQ16 Function**

Performs a single-pass IIR Biquad Filter.

**Description**

Function DSP_FilterIIRBQ16:

int16_t DSP_FilterIIRBQ16(int16_t Xin, PARM_EQUAL_FILTER \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.

All values are fractional Q15 and Q31, see data structure for specifics.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER \*ptrFilterEQ;

PARM_EQUAL_FILTER FilterEQ;

uint16_t DataIn, DataOut;

ptrFilterEQ = &amp;FilterEQ;

_// 48KHz sampling; 1 KHz bandpass filter; Q=0.9_

_// divide by 2 and convert to Q15_

_// b0 = 0.06761171785499065_

_// b1 = 0_

_// b2 = -0.06761171785499065_

_// a1 = -1.848823142275648_

_// a2 = 0.8647765642900187_

_// note all coefs are half value of original design, gain handled in algorithm_

ptrFiltEQ32-\\&gt;b[0]=0x0453; _// feed forward b0 coef_

ptrFiltEQ32-\\&gt;b[1]=0; _// feed forward b1 coef_

ptrFiltEQ32-\\&gt;b[2]=0xFBAD; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

ptrFiltEQ32-\\&gt;a[0]=0x89AD; _// feedback a1 coef_

ptrFiltEQ32-\\&gt;a[1]=0x3758; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get some input data here_

DataIn32 = three_hundred_hz[i];

DataOut = DSP_FilterIIRBQ16(DataIn, ptrFilterEQ);

_// \*\*\* do something with the DataOut here_

}

**C**

int16_t **DSP_FilterIIRBQ16** (int16_t **Xin** , PARM_EQUAL_FILTER \* **pFilter** );

**DSP_FilterIIRBQ16_cascade8 Function**

Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

**Description**

Function DSP_FilterIIRBQ16_cascade8:

int16_t DSP_FilterIIRBQ16_cascade8(int16_t Xin, PARM_EQUAL_FILTER \*pFilter_Array);

Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 32 bit delay lines are maintained for each. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. Global gain values are available on the output. Fracgain is a Q15 fractional gain value and expgain is a binary shift gain value. The combination of the two can be utilized to normalize the output as desired. All values 
are fractional Q15 and Q31, see data structure for specifics.

Y = Y7 \\&lt;- Y6 \\&lt;- Y5 \\&lt;- Y4 \\&lt;- Y3 \\&lt;- Y2 \\&lt;- Y1 \\&lt;- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)\*b0 +

(b1 \* Y(n-2)) + (b2 \* Y(n-3)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2)) and: for Y0; Y(n-1) = Xin(0)

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER filtArray[8];

uint16_t dataY, dataX;

_// example to use 2 filter blocks as notch filters_

_// fill entire Filter Array with coefs_

for (i=0;i\\&lt;8;i++)

{

filtArray[i].Z[0]=0;

filtArray[i].Z[1]=0;

_// note all coefs are half value of original design, gain handled in algorithm_

_// all pass_

filtArray[i].b[0]=0x4000;

filtArray[i].b[1]=0; _// feed forward b1 coef_

filtArray[i].b[2]=0; _// feed forward b2 coef_

filtArray[i].a[0]=0; _// feedback a1 coef_

filtArray[i].a[1]=0; _// feedback a2 coef_

}

_// Unique filters for example_

_// 10KHz notch filter -- divide coefs by 2_

b0 = 0.5883783602332997

b1 = -0.17124071441396285

b2 = 0.5883783602332997

a1 = -0.17124071441396285

a2 = 0.1767567204665992

_// note all coefs are half value of original design, gain handled in algorithm_

filtArray[3].b[0]=0x25a7; _// feed forward b0 coef_

filtArray[3].b[1]=0xf508; _// feed forward b1 coef_

filtArray[3].b[2]=0x25a7; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArray[3].a[0]=0xf508; _// feedback a1 coef_

filtArray[3].a[1]=0x0b4f; _// feedback a2 coef_

_// 1 KHz notch filter -- divide coefs by 2_

b0 = 0.9087554064944908

b1 = -1.7990948352036205

b2 = 0.9087554064944908

a1 = -1.7990948352036205

a2 = 0.8175108129889816

_// note all coefs are half value of original design, gain handled in algorithm_

filtArray[7].b[0]=0x3a29; _// feed forward b0 coef_

filtArray[7].b[1]=0x8cdc; _// feed forward b1 coef_

filtArray[7].b[2]=0x3a29; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArray[7].a[0]=0x8cdc; _// feedback a1 coef_

filtArray[7].a[1]=0x3452; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get input data here_

dataX = compound_300_1K_hz16[i];

dataY = DSP_FilterIIRBQ16_cascade8(dataX, filtArray);

_// \*\*\* do something with the DataY here_

}

**C**

int16_t **DSP_FilterIIRBQ16_cascade8** (int16_t **Xin** , PARM_EQUAL_FILTER \* **pFilter_Array** );

**DSP_FilterIIRBQ16_cascade8_fast Function**

Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

**Description**

Function DSP_FilterIIRBQ16_cascade8_fast:

int16_t DSP_FilterIIRBQ16_cascade8_fast(int16_t Xin, PARM_EQUAL_FILTER_16 \*pFilter_Array);

Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 16 bit delay lines are maintained for each. All math is performed using 16 bit instructions, which results rounded to 16-bits for the output. All values are fractional Q15, see data structure for specifics. The function will saturate the output should it exceed maximum or minimum values.

Y = Y7 \\&lt;- Y6 \\&lt;- Y5 \\&lt;- Y4 \\&lt;- Y3 \\&lt;- Y2 \\&lt;- Y1 \\&lt;- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)\*b0 +

(b1 \* Y(n-2)) + (b2 \* Y(n-3)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2)) and: for Y0; Y(n-1) = Xin(0)

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input a t half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER_16 filtArray[8];

uint16_t dataY, dataX;

_// example to use 2 filter blocks as notch filters_

_// fill entire Filter Array with coefs_

for (i=0;i\\&lt;8;i++)

{

filtArray[i].Z[0]=0;

filtArray[i].Z[1]=0;

_// note all coefs are half value of original design, gain handled in algorithm_

_// all pass_

filtArray[i].b[0]=0x4000;

filtArray[i].b[1]=0; _// feed forward b1 coef_

filtArray[i].b[2]=0; _// feed forward b2 coef_

filtArray[i].a[0]=0; _// feedback a1 coef_

filtArray[i].a[1]=0; _// feedback a2 coef_

}

_// Unique filters for example_

_// 10KHz notch filter -- divide coefs by 2_

b0 = 0.5883783602332997

b1 = -0.17124071441396285

b2 = 0.5883783602332997

a1 = -0.17124071441396285

a2 = 0.1767567204665992

_// note all coefs are half value of original design, gain handled in algorithm_

filtArray[3].b[0]=0x25a7; _// feed forward b0 coef_

filtArray[3].b[1]=0xf508; _// feed forward b1 coef_

filtArray[3].b[2]=0x25a7; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArray[3].a[0]=0xf508; _// feedback a1 coef_

filtArray[3].a[1]=0x0b4f; _// feedback a2 coef_

_// 1 KHz notch filter -- divide coefs by 2_

b0 = 0.9087554064944908

b1 = -1.7990948352036205

b2 = 0.9087554064944908

a1 = -1.7990948352036205

a2 = 0.8175108129889816

_// note all coefs are half value of original design, gain handled in algorithm_

filtArray[7].b[0]=0x3a29; _// feed forward b0 coef_

filtArray[7].b[1]=0x8cdc; _// feed forward b1 coef_

filtArray[7].b[2]=0x3a29; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArray[7].a[0]=0x8cdc; _// feedback a1 coef_

filtArray[7].a[1]=0x3452; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get input data here_

dataX = compound_300_1K_hz16[i];

dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);

_// \*\*\* do something with the DataY here_

}

**C**

int16_t **DSP_FilterIIRBQ16_cascade8_fast** (int16_t **Xin** , PARM_EQUAL_FILTER_16 \* **pFilter_Array** );

**DSP_FilterIIRBQ16_fast Function**

Performs a single-pass IIR Biquad Filter.

**Description**

Function DSP_FilterIIRBQ16_fast:

int16_t DSP_FilterIIRBQ16_fast(int16_t Xin, PARM_EQUAL_FILTER_16 \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 16 bit instructions, with results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions.

The function will saturate the results if maximum or minimum fractional values are exceeded. All values are fractional Q15 format.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER_16 \*ptrFilterEQ;

PARM_EQUAL_FILTER_16 FilterEQ;

uint16_t DataIn, DataOut;

ptrFilterEQ = &amp;FilterEQ;

_// 48KHz sampling; 1 KHz bandpass filter; Q=0.9_

_// divide by 2 and convert to Q15_

_// b0 = 0.06761171785499065_

_// b1 = 0_

_// b2 = -0.06761171785499065_

_// a1 = -1.848823142275648_

_// a2 = 0.8647765642900187_

_// note all coefs are half value of original design, gain handled in algorithm_

ptrFiltEQ32-\\&gt;b[0]=0x0453; _// feed forward b0 coef_

ptrFiltEQ32-\\&gt;b[1]=0; _// feed forward b1 coef_

ptrFiltEQ32-\\&gt;b[2]=0xFBAD; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

ptrFiltEQ32-\\&gt;a[0]=0x89AD; _// feedback a1 coef_

ptrFiltEQ32-\\&gt;a[1]=0x3758; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get some input data here_

DataIn32 = three_hundred_hz[i];

DataOut = DSP_FilterIIRBQ16_fast(DataIn, ptrFilterEQ);

_// \*\*\* do something with the DataOut here_

}

**C**

int16_t **DSP_FilterIIRBQ16_fast** (int16_t **Xin** , PARM_EQUAL_FILTER_16 \* **pFilter** );

**DSP_FilterIIRBQ16_parallel8 Function**

Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

**Description**

Function DSP_FilterIIRBQ16_parallel8:

int16_t DSP_FilterIIRBQ16_parallel8(int16_t Xin, PARM_EQUAL_FILTER \*pFilter);

Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15 and Q31, see data structure for specifics.

Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =

X(0)\*b0 + (b1 \* X(n-1)) + (b2 \* X(n-2)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2))

**Preconditions**

Delay register values should be initialized to zero. The sum of all fracgain should be \\&lt;= 1

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2

has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER filtArrayPara[8];

uint16_t dataY, dataX;

_// fill entire Filter Array with coefs_

for (i=0;i\\&lt;8;i++)

{

filtArrayPara[i].Z[0]=0;

filtArrayPara[i].Z[1]=0;

filtArrayPara[i].G.fracGain = 0x7FFF; _// gain = 1 default_

filtArrayPara[i].G.expGain = 1; _// == 2\^N; gain of 2_

_// note all coefs are half value of original design, gain handled in algorithm_

_// none pass -- default_

filtArrayPara[i].b[0]=0; _// feed forward b0 coef_

filtArrayPara[i].b[1]=0; _// feed forward b1 coef_

filtArrayPara[i].b[2]=0; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[i].a[0]=0; _// feedback a1 coef_

filtArrayPara[i].a[1]=0; _// feedback a2 coef_

}

_// 1K bandpass Q=0.9_

filtArrayPara[7].G.fracGain = 0x4000; _// gain = 0.5 because using 2 outputs_

_// note all coefs are half value of original design, gain handled in algorithm_

filtArrayPara[7].b[0]=0x04ad;

filtArrayPara[7].b[1]=0; _// feed forward b1 coef_

filtArrayPara[7].b[2]=0xfb53; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[7].a[0]=0x8a90; _// feedback a1 coef_

filtArrayPara[7].a[1]=0x36a4; _// feedback a2 coef_

_// 300 Hz bandpass Q=0.9_

filtArrayPara[6].G.fracGain = 0x1000; _// gain = 0.125 as an example_

_// note all coefs are half value of original design, gain handled in algorithm_

filtArrayPara[6].b[0]=0x017b; _// feed forward b0 coef_

filtArrayPara[6].b[1]=0; _// feed forward b1 coef_

filtArrayPara[6].b[2]=0xfe85; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[6].a[0]=0x8316; _// feedback a1 coef_

filtArrayPara[6].a[1]=0x3d08; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get input data here_

dataX = compound_300_1K_hz16[i];

dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);

_// \*\*\* do something with the DataY here_

}

**C**

int16_t **DSP_FilterIIRBQ16_parallel8** (int16_t **Xin** , PARM_EQUAL_FILTER \* **pFilter** );

**DSP_FilterIIRBQ16_parallel8_fast Function**

Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

**Description**

Function DSP_FilterIIRBQ16_parallel8_fast:

int16_t DSP_FilterIIRBQ16_parallel8_fast(int16_t Xin, PARM_EQUAL_FILTER_16 \*pFilter);

Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is

performed using 16 bit instructions, which results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15. The function will round outputs and saturate if maximum or minimum values are exceeded.

Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =

X(0)\*b0 + (b1 \* X(n-1)) + (b2 \* X(n-2)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2))

**Preconditions**

Delay register values should be initialized to zero. The sum of all fracgain should be \\&lt;= 1

**Parameters**

**Parameters Description**

Xin input data element X (int16_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER_16 filtArrayPara[8]; _// note change in data structure_

uint16_t dataY, dataX;

_// fill entire Filter Array with coefs_

for (i=0;i\\&lt;8;i++)

{

filtArrayPara[i].Z[0]=0;

filtArrayPara[i].Z[1]=0;

filtArrayPara[i].G.fracGain = 0x7FFF; _// gain = 1 default_

filtArrayPara[i].G.expGain = 1; _// log2N; gain of 2_

_// note all coefs are half value of original design, gain handled in algorithm_

_// none pass -- default_

filtArrayPara[i].b[0]=0; _// feed forward b0 coef_

filtArrayPara[i].b[1]=0; _// feed forward b1 coef_

filtArrayPara[i].b[2]=0; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[i].a[0]=0; _// feedback a1 coef_

filtArrayPara[i].a[1]=0; _// feedback a2 coef_

}

_// 1K bandpass Q=0.9_

filtArrayPara[7].G.fracGain = 0x4000; _// gain = 0.5 because using 2 outputs_

_// note all coefs are half value of original design, gain handled in algorithm_

filtArrayPara[7].b[0]=0x04ad;

filtArrayPara[7].b[1]=0; _// feed forward b1 coef_

filtArrayPara[7].b[2]=0xfb53; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[7].a[0]=0x8a90; _// feedback a1 coef_

filtArrayPara[7].a[1]=0x36a4; _// feedback a2 coef_

_// 300 Hz bandpass Q=0.9_

filtArrayPara[6].G.fracGain = 0x1000; _// gain = 0.125 as an example_

_// note all coefs are half value of original design, gain handled in algorithm_

filtArrayPara[6].b[0]=0x017b; _// feed forward b0 coef_

filtArrayPara[6].b[1]=0; _// feed forward b1 coef_

filtArrayPara[6].b[2]=0xfe85; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

filtArrayPara[6].a[0]=0x8316; _// feedback a1 coef_

filtArrayPara[6].a[1]=0x3d08; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get input data here_

dataX = compound_300_1K_hz16[i];

dataY = DSP_FilterIIRBQ16_cascade8_fast(dataX, filtArray);

_// \*\*\* do something with the DataY here_

}

**C**

int16_t **DSP_FilterIIRBQ16_parallel8_fast** (int16_t **Xin** , PARM_EQUAL_FILTER_16 \* **pFilter** );

**DSP_FilterIIRBQ32 Function**

Performs a high resolution single-pass IIR Biquad Filter.

**Description**

Function DSP_FilterIIRBQ32:

int32_t DSP_FilterIIRBQ32(int32_t Xin, PARM_EQUAL_FILTER_32 \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 32-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.

All values are fractional Q31, see data structure for specifics.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int32_t)

pFilter pointer to high resolution filter coef and delay structure

**Returns**

Sample output Y (int32_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM_EQUAL_FILTER_32 \*ptrFiltEQ32;

PARM_EQUAL_FILTER_32 FilterEQ32;

int32_t DataIn32, DataOut32;

ptrFiltEQ32 = &amp;FilterEQ32;

ptrFiltEQ32-\\&gt;Z[0]=0;

ptrFiltEQ32-\\&gt;Z[1]=0;

_// 1000 Hz Q= 0.9 BP filter design, 44.1K sampling_

_//_

_// b0 = 0.07311778239751009 forward_

_// b1 = 0_

_// b2 = -0.07311778239751009_

_// a1 = -1.8349811166056893 back_

_// a2 = 0.8537644352049799_

_// note all coefs are half value of original design, gain handled in algorithm_

ptrFiltEQ32-\\&gt;b[0]=0x04ADF635; _// feed forward b0 coef_

ptrFiltEQ32-\\&gt;b[1]=0; _// feed forward b1 coef_

ptrFiltEQ32-\\&gt;b[2]=0xFB5209CB; _// feed forward b2 coef_

_// note all coefs are half value of original design, gain handled in algorithm_

_// note subtract is handled in algorithm, so coefs go in at actual value_

ptrFiltEQ32-\\&gt;a[0]=0x8A8FAB5D; _// feedback a1 coef_

ptrFiltEQ32-\\&gt;a[1]=0x36A41395; _// feedback a2 coef_

for (i=0;i\\&lt;256;i++)

{

_// \*\*\* get input data here_

DataIn32 = three_hundred_hz[i];

DataOut32 = DSP_FilterIIRBQ32(DataIn32, ptrFiltEQ32);

_// \*\*\* do something with the DataOut32 here_

}

**C**

int32_t **DSP_FilterIIRBQ32** (int32_t **Xin** , PARM_EQUAL_FILTER_32 \* **pFilter** );

**DSP_FilterIIRSetup16 Function**

Converts biquad structure to coeffs array to set up IIR filter.

**Description**

Function DSP_FilterIIRSetup16:

void DSP_FilterIIRSetup16(int16_t \*coeffs, biquad16 \*bq, int B);

Converts an array of biquad coefficients, bq, into an linear array of coefficients, coeffs. The output array must be 4\*B elements long. The number of biquads in the resulting factor is given by B. All numerical values must be in Q15 fractional data format.

**Preconditions**

coeffs must have 4\*B elements.

**Parameters**

**Parameters Description**

coeffs pointer to an array of coefficients (int16_t)

bq pointer to array of biquad structure filter coefs (biquad16)

B number of cascaded biquad filter groups to process (int)

**Returns**

None.

**Remarks**

None.

**Example**

see DSP_FilterIIR16 for example.

**C**

**void**  **DSP_FilterIIRSetup16** (int16_t \* **coeffs** , biquad16 \* **bq** , int  **B** );

**DSP_FilterLMS16 Function**

Performs a single sample Least Mean Squares FIR Filter.

**Description**

Function DSP_FilterLMS16:

int16_t DSP_FilterLMS16(int16_t in, int16_t ref, int16_t \*coeffs, int16_t \*delayline, int16_t \*error, int K, int16_t mu);

Computes an LMS adaptive filter on the input in. Filter output of the FIR is given as a 16 bit value. The filter target is ref, and the

calculation difference between the output and the target is error. The filter adapts its coefficients, coefs, on each pass. Th number of coefficients (filter taps) is given by the value K. The delayline array should be initialized to zero prior to calling the filter for the first time, and have K elements. The value mu is the rate at which the filter adapts. All values are Q15 fractional numbers.

The function will saturate the output if it exceeds maximum or minimum values. The LMS will adapt its coefs to attempt to drive the output value toward the ref value. The rate of adaption on each pass depends on mu and the error from the previous calculation.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K) elements, and be initialized to

zero. K (taps) must be a multiple of 4, and \\&gt;= 8. mu must be positive.

**Parameters**

**Parameters Description**

in input data value (int16_t)

ref target output value (int16_t)

coeffs pointer to an array of coefficients (int16_t)

delayline pointer to an array of delay variables (int16_t)

error output minus reference (int16_t)

K number of filter taps and coeffs (int)

mu adaption rate (int16_t)

**Returns**

(int16_t) - FIR filter output

**Remarks**

Filter coefs may start at random or zero value, but convergence is dependent on the amount of update required.

**Example**

**#define** lmsTAPS 8

int16_t lmsOut;

int lmsTaps = lmsTAPS;

int16_t lmsCoefs[lmsTAPS]={0x5000, 0x4000,0x3000, 0x2000,0x1000, 0x0000,0xF000, 0xE000};

int16_t lmsDelay[lmsTAPS]={0};

int16_t \*ptrLMSError;

int16_t lmsError = 0x0200;

int16_t inVal=0;

int16_t refVal = 0x0CCC; _// some target value = 0.1_

int16_t lmsAdapt = 0x3000;

ptrLMSError = &amp;lmsError;

for (i=0;i\\&lt;200;i++)

{

_// get some input value here //_

**if** (i \\&lt; 100)

{

inVal = 0x4233;

}

**else**

{

inVal = 0xCF10;

}

lmsOut = DSP_FilterLMS16(inVal, refVal, lmsCoefs, lmsDelay,

ptrLMSError, lmsTaps, lmsAdapt);

}

**C**

int16_t **DSP_FilterLMS16** (int16_t **in** , int16_t **ref** , int16_t \* **coeffs** , int16_t \* **delayline** , int16_t

\* **error** , int  **K** , int16_t **mu** );

**DSP_MatrixAdd32 Function**

Addition of two matrices C = (A + B).

**Description**

Function DSP_MatrixAdd32:

void DSP_MatrixAdd32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Vector summation of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.

**Preconditions**

Both matrices must be equivalent in rows and columns. Both Matrices must be set into structure (ROWS, COLUMNS,

vector_pointer).

**Parameters**

**Parameters Description**

resMat pointer to new sum Matrix C (\*int32_t)

srcMat1 pointer to the Matrix A structure (\*int32_t)

srcMat2 pointer to the Matrix B structure (\*int32_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 225 cycles + 23 / matrix_element. The function will saturate the output value if it exceeds maximum limits

per element.

**Example**

**#define** ROW 2

**#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32_t result[ROW\*COL];

int32_t matA[ROW\*COL] = {1,2,3,4};

int32_t matB[ROW\*COL] = {2,4,6,8};

matrix32 mat, mat2, mat3;

resMat=&amp;mat;

srcMat1=&amp;mat2;

srcMat2=&amp;mat3;

srcMat1-\\&gt;row=ROW;

srcMat1-\\&gt;col=COL;

srcMat1-\\&gt;pMatrix=matA;

srcMat2-\\&gt;col=COL;

srcMat2-\\&gt;row=ROW;

srcMat2-\\&gt;pMatrix=matB;

resMat-\\&gt;row=ROW;

resMat-\\&gt;col=COL;

resMat-\\&gt;pMatrix=result;

DSP_MatrixAdd32(resMat, srcMat1, srcMat2);

_// result[i] = matA[i] + matB[i] = {3,6,9,0xA}_

**C**

**void**  **DSP_MatrixAdd32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP_MatrixEqual32 Function**

Equality of two matrices C = (A).

**Description**

Function DSP_MatrixEqual32:

void DSP_MatrixEqual32(matrix32 \*resMat, matrix32 \*srcMat);

Vector copy of all elements from one matrix to another. C is a duplicate of A.

**Preconditions**

None.

**Parameters**

**Parameters Description**

resMat pointer to completed new Matrix C (\*int32_t)

srcMat pointer to the Matrix A structure (\*int32_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 163 cycles + 12 / matrix_element.

**Example**

**#define** ROW 2

**#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32_t result[ROW\*COL];

int32_t matA[ROW\*COL] = {5,2,-3,8};

matrix32 mat, mat2;

resMat=&amp;mat;

srcMat1=&amp;mat2;

srcMat1-\\&gt;row=ROW;

srcMat1-\\&gt;col=COL;

srcMat1-\\&gt;pMatrix=matA;

resMat-\\&gt;row=ROW;

resMat-\\&gt;col=COL;

resMat-\\&gt;pMatrix=result;

DSP_MatrixEqual32(resMat, srcMat1, srcMat2);

_// result[i] = matA[i] = {5, 2, -3, 8}_

**C**

**void**  **DSP_MatrixEqual32** (matrix32 \* **resMat** , matrix32 \* **srcMat** );

**DSP_MatrixInit32 Function**

Initializes the first N elements of a Matrix to the value num.

**Description**

Function DSP_MatrixInit32:

void DSP_MatrixInit32(int32_t \*data_buffer, int N, int32_t num);

Copy the value num into the first N Matrix elements of data_buffer.

**Preconditions**

data_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or it will truncate to the nearest factor of four.

**Parameters**

**Parameters Description**

data_buffer pointer to the Matrix to be initialized (int32_t[M\*N])

N number of elements to be initialized (int32_t)

num value to be initialized into the matrix (int32_t)

**Returns**

None.

**Remarks**

None.

**Example**

**#define** ROW 3

**#define** COL 3

int32_t numElements = 4; _// multiple of 4_

int valueElements = -1;

int32_t matA[ROW\*COL] = {5,2,-3,8,4,2,-6,8,9};

DSP_MatrixInit32(matA, numElements, valueElements);

_// matA[i] = {-1,-1,-1,-1,4,2,-6,8,9}_

**C**

**void**  **DSP_MatrixInit32** (int32_t \* **data_buffer** , int  **N** , int32_t **num** );

**DSP_MatrixMul32 Function**

Multiplication of two matrices C = A x B.

**Description**

Function DSP_MatrixMul32:

void DSP_MatrixMul32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Multiplication of two matrices, with inputs and outputs being in fractional Q31 numerical format. The output elements will saturate if the dot product exceeds maximum or minimum fractional values.

**Preconditions**

Matrices must be aligned such that columns of A = rows of B. resMat must have the format of rows of A, columns of B. All Matrices must be set into structure (ROWS, COLUMNS, vector_pointer).

**Parameters**

**Parameters Description**

resMat pointer to different Matrix C structure (\*int32_t)

srcMat1 pointer to the Matrix A structure (\*int32_t)

srcMat2 pointer to the Matrix B structure (\*int32_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 319 cycles + 38 / output matrix_element. The function will saturate the output value if it exceeds maximum limits per element.

**Example**

**#define** ROW1 3

**#define** COL1 2

**#define** ROW2 2

**#define** COL2 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32_t result[ROW1\*COL2];

int32_t test_MatrixA[ROW1\*COL1]=

{

0x40000000,0x20000000, _// 0.5, 0.25_

0xD999999A,0x4CCCCCCC, _// -0.3, 0.6_

0xC0000000,0x0CCCCCCD _// -0.5 0.1_

};

int32_t test_MatrixB[ROW2\*COL2]=

{

0x40000000,0x20000000, _// 0.5, 0.25_

0x0CCCCCCD,0xCCCCCCCD _// 0.1, -0.4_

};

matrix32 mat, mat2, mat3;

resMat=&amp;mat;

srcMat1=&amp;mat2;

srcMat2=&amp;mat3;

srcMat1-\\&gt;row=ROW1;

srcMat1-\\&gt;col=COL1;

srcMat1-\\&gt;pMatrix=test_MatrixA;

srcMat2-\\&gt;col=COL2;

srcMat2-\\&gt;row=ROW2;

srcMat2-\\&gt;pMatrix=test_MatrixB;

resMat-\\&gt;row=ROW1; _// note resulting matrix MUST have ROW1 &amp; COL2 format_

resMat-\\&gt;col=COL2;

resMat-\\&gt;pMatrix=result;

DSP_MatrixMul32(resMat, srcMat1, srcMat2);

_// result[] = matA[] x matB[] =_

_// { 0x23333333, 0x03333333 // 0.275, 0.025_

_// 0xF47AE147, 0xD7AE147B // -0.9, -0.315_

_// 0xE147AE14, 0xEAE147AE } // -0.24, -0.165_

**C**

**void**  **DSP_MatrixMul32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP_MatrixScale32 Function**

Scales each element of an input buffer (matrix) by a fixed number.

**Description**

Function DSP_MatrixScale32:

void DSP_MatrixScale32(int32_t \*data_buffer, int N, int32_t num);

Multiply the first N elements of an input buffer by a fixed scalar num. The resulting value is stored back into the input buffer. N number total samples of the input buffer are processed. All values are in Q31 fractional integer format. The result of calculations is saturated to the MAX32 or MIN32 value if exceeded.

**Preconditions**

data_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or will truncate to the nearest factor of four.

**Parameters**

**Parameters Description**

data_buffer pointer to the Matrix to be initialized (int32_t[M\*N])

N number of elements to be initialized (int)

num value to be initialized into the matrix (int32_t)

**Returns**

None.

**Remarks**

Execution time (cycles): 190 + 9 cycles / element, typical.

**Example**

int32_t numScale = 0x40000000; _// 0.5_

int valN = 12;

int32_t inputBufScale[12] = {0x40000000, 0x40000000, 0x20000000, 0x20000000,

0x19999999, 0xCCCCCCCD, 0xF3333333, 0x80000000,

0x7FFFFFFF, 0x00000000, 0x40000000, 0x70000000 };

_// 0.5, 0.5, 0.25, 0.25, 0.25, 0.2, -0.4, -0.1, -1, 1, 0, 0.5, 0.875_

DSP_MatrixScale32(inputBufScale,valN,numScale);

_// inputBufScale[i] = {0x20000000, 0x20000000, 0x10000000, 0x10000000,_

_// 0x0CCCCCCC, 0xE6666666, 0xF9999999, 0xC0000000,_

_// 0x3FFFFFFF, 0x00000000, 0x20000000, 0x38000000}_

_// 0.25, 0.25, 0.125, 0.125, 0.1, -0.2, -0.05, -0.5, 0.5, 0, 0.25, 0.4375_

**C**

**void**  **DSP_MatrixScale32** (int32_t \* **data_buffer** , int  **N** , int32_t **num** );

**DSP_MatrixSub32 Function**

Subtraction of two matrices C = (A - B).

**Description**

Function DSP_MatrixSub32:

void DSP_MatrixSub32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Vector subtraction of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.

**Preconditions**

Both matrices must be equivalent in rows and columns. All Matrices must be set into structure (ROWS, COLUMNS, vector_pointer)

**Parameters**

**Parameters Description**

resMat pointer to different Matrix C structure (\*int32_t)

srcMat1 pointer to the Matrix A structure (\*int32_t)

srcMat2 pointer to the Matrix B structure (\*int32_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 222 cycles + 21 / matrix_element. The function will saturate the output value if it exceeds maximum limits per element.

**Example**

**#define** ROW 2

**#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32_t result[ROW\*COL];

int32_t matA[ROW\*COL] = {5,2,-3,8};

int32_t matB[ROW\*COL] = {2,2,2,2};

matrix32 mat, mat2, mat3;

resMat=&amp;mat;

srcMat1=&amp;mat2;

srcMat2=&amp;mat3;

srcMat1-\\&gt;row=ROW;

srcMat1-\\&gt;col=COL;

srcMat1-\\&gt;pMatrix=matA;

srcMat2-\\&gt;col=COL;

srcMat2-\\&gt;row=ROW;

srcMat2-\\&gt;pMatrix=matB;

resMat-\\&gt;row=ROW;

resMat-\\&gt;col=COL;

resMat-\\&gt;pMatrix=result;

DSP_MatrixSub32(resMat, srcMat1, srcMat2);

_// result[i] = matA[i] - matB[i] = {3,0,-5,6}_

**C**

**void**  **DSP_MatrixSub32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP_MatrixTranspose32 Function**

Transpose of a Matrix C = A (T).

**Description**

Function DSP_MatrixTranspose32:

void DSP_MatrixTranspose32(matrix32 \*desMat, matrix32 \*srcMat);

Transpose of rows and columns of a matrix.

**Preconditions**

Matrix definitions for ROWS and COLS must be transposed prior to the function call.

**Parameters**

**Parameters Description**

desMat pointer to transposed new Matrix C (\*int32_t)

srcMat pointer to the Matrix A structure (\*int32_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 210 cycles + 10 / matrix_element.

**Example**

**#define** ROW 3

**#define** COL 4

matrix32 \*resMat, \*srcMat1;

int32_t result[ROW\*COL];

int32_t matA[ROW\*COL] = { 1, 2, 3, 4,

5, 6, 7, 8,

-1, -3, -5, -7};

matrix32 mat, mat2;

resMat=&amp;mat;

srcMat1=&amp;mat2;

srcMat1-\\&gt;row=ROW;

srcMat1-\\&gt;col=COL;

srcMat1-\\&gt;pMatrix=matA;

resMat-\\&gt;row=COL; _// note the shift in columns and rows_

resMat-\\&gt;col=ROW;

resMat-\\&gt;pMatrix=result;

DSP_MatrixTranspose32(resMat, srcMat1);

_// result[] = matA(T)[] = { 1, 5, -1,_

_// 2, 6, -3,_

_// 3, 7, -5,_

_// 4, 8, -7}_

**C**

**void**  **DSP_MatrixTranspose32** (matrix32 \* **desMat** , matrix32 \* **srcMat** );

**DSP_TransformFFT16 Function**

Creates an Fast Fourier Transform (FFT) from a time domain input.

**Description**

Function DSP_TransformFFT16:

void DSP_TransformFFT16(int16c \*dout, int16c \*din, int16c \*twiddles, int16c \*scratch, int log2N);

Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2\^log2N point calculation, and the working buffer scratch as well as the input and output must be 2\^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q15) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2\^(log2N) log2N must be \\&gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT16_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int16c)

din pointer to complex input array (int16c)

twiddles pointer to an complex array of factors (int16c)

scratch pointer to a complex scratch pad buffer (int16c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.

**Example**

int log2N = 8; _// log2(256) = 8_

int fftSamples = 256;

int16c \*fftDin;

int16c fftDout[fftSamples];

int16c scratch[fftSamples];

int16c fftCoefs[fftSamples];

int16c \*fftc;

fftc = &amp;fftCoefs;

DSP_TransformFFT16_setup(fftc, log2N); _// call setup function_

while (1)

{

fftDin = &amp;fftin_8Khz_long_window16; _// get 256 point complex data_

DSP_TransformFFT16(fftDout, fftDin, fftc, scratch, log2N);

_// do something with the output, fftDout_

};

**C**

**void**  **DSP_TransformFFT16** (int16c \* **dout** , int16c \* **din** , int16c \* **twiddles** , int16c \* **scratch** , int

**log2N** );

**DSP_TransformFFT16_setup Function**

Creates FFT coefficients for use in the FFT16 function.

**Description**

Function DSP_TransformFFT16_setup:

void DSP_TransformFFT16_setup(int16c \*twiddles, int log2N);

Calculates the N twiddle factors required to operate the FFT16 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a

buffer.

**Preconditions**

twiddles must be N in length N is calculated (2\^log2N)

**Parameters**

**Parameters Description**

twiddles pointer to a complex array of factors (int16c)

log2N binary exponent of number of data points (int)

**Returns**

None.

**Remarks**

This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.

**Example**

see DSP_TransformFFT16 for example.

**C**

**void**  **DSP_TransformFFT16_setup** (int16c \* **twiddles** , int  **log2N** );

**DSP_TransformFFT32 Function**

Creates an Fast Fourier Transform (FFT) from a time domain input.

**Description**

Function DSP_TransformFFT32:

void DSP_TransformFFT32(int32c \*dout, int32c \*din, int32c \*twiddles, int32c \*scratch, int log2N);

Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2\^log2N point calculation, and the working buffer scratch as well as the input and output must be 2\^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q31) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2\^(log2N) log2N must be \\&gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT32_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int32c)

din pointer to complex input array (int32c)

twiddles pointer to an complex array of FFT factors (int32c)

scratch pointer to a complex scratch pad buffer (int32c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.

**Example**

int log2N = 8; _// log2(256) = 8_

int fftSamples = 256;

int32c \*fftDin;

int32c fftDout[fftSamples];

int32c scratch[fftSamples];

int32c fftCoefs[fftSamples];

int32c \*fftc;

fftc = &amp;fftCoefs;

DSP_TransformFFT32_setup(fftc, log2N); _// call setup function_

while (1)

{

fftDin = &amp;fftin_5Khz_long_window32; _// get 256 point complex data_

DSP_TransformFFT32(fftDout, fftDin, fftc, scratch, log2N);

_// do something with the output, fftDout_

};

**C**

**void**  **DSP_TransformFFT32** (int32c \* **dout** , int32c \* **din** , int32c \* **twiddles** , int32c \* **scratch** , int

**log2N** );

**DSP_TransformFFT32_setup Function**

Creates FFT coefficients for use in the FFT32 function.

**Description**

Function DSP_TransformFFT32_setup:

void DSP_TransformFFT32_setup(int32c \*twiddles, int log2N);

Calculates the N FFT twiddle factors required to operate the FFT32 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a buffer.

**Preconditions**

twiddles must be N in length N is calculated (2\^log2N)

**Parameters**

**Parameters Description**

twiddles pointer to a complex array of coefficients (int32c)

log2N binary exponent of number of data points (int)

**Returns**

None.

**Remarks**

This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.

**Example**

see DSP_TransformFFT32 for example.

**C**

**void**  **DSP_TransformFFT32_setup** (int32c \* **twiddles** , int  **log2N** );

**DSP_TransformIFFT16 Function**

Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.

**Description**

Function DSP_TransformIFFT16:

void DSP_TransformIFFT16(int16c \*dout, int16c \*din, int16c \*twiddles, int16c \*scratch, int log2N);

Performs an complex Inverse FFT on the input, din, and stores the complex result in dout. Performs 2\^log2N point calculation, and the working buffer scratch as well as the input and output must be 2\^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP_TransformFFT16_setup. All values are 16 bit (Q15) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2\^(log2N) log2N must be \\&gt;= 3 FFT factors must be calculated in advance, use DSP_TransformFFT16_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int16c)

din pointer to complex input array (int16c)

twiddles pointer to an complex array of factors (int16c)

scratch pointer to a complex scratch pad buffer (int16c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. A very similar function to the FFT is executed for the inverse FFT. This requires twiddle factors set in advance with the same method as used in the FFT. Complex conjugate and scaling are handled within the algorithm. The output is scaled using binary shifting based on log2N. Since the algorithm reduces the output by a scale factor of log2N, the resolution is reduced proportionally to the number of data points.

**Example**

int ilog2N = 10; _// log2(64) = 6; log2(256) = 8; log2(1024) = 10;_

int ifftSamples = pow(2,ilog2N);

int16c \*ifftDin;

int16c ifftDout[ifftSamples];

int16c iscratch[ifftSamples];

int16c ifftCoefs[ifftSamples];

int16c ifftTimeOut[ifftSamples];

_// set up twiddle factors, these are used for both FFT and iFFT_

int16c \*ifftc;

ifftc = &amp;ifftCoefs;

DSP_TransformFFT16_setup( ifftc, ilog2N); _// call to coef setup_

_// in this example, we take an FFT of an original time domain (sine wave)_

_// the output of the FFT is used as the input of the iFFT for comparison_

ifftDin = &amp;fftin_800hz_verylong16;

DSP_TransformFFT16(ifftDout, ifftDin, ifftc, iscratch, ilog2N);

_// ifftDout = frequency domain output, complex number array_

DSP_TransformIFFT16(ifftTimeOut, ifftDout, ifftc, iscratch, ilog2N);

_// do something with the output, fftTimeOut, time domain_

**C**

**void**  **DSP_TransformIFFT16** (int16c \* **dout** , int16c \* **din** , int16c \* **twiddles** , int16c \* **scratch** , int

**log2N** );

**DSP_TransformWindow_Bart16 Function**

Perform a Bartlett window on a vector.

**Description**

Function DSP_TransformWindow_Bart16:

void DSP_TransformWindow_Bart16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.

Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Bart16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x0000, 0x1000, 0x2000, 0x3000, 0x4000, 0x3000, 0x2000, 0x1000_

**C**

**void**  **DSP_TransformWindow_Bart16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Bart32 Function**

Perform a Bartlett window on a vector.

**Description**

Function DSP_TransformWindow_Bart32:

void DSP_TransformWindow_Bart32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.

Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Bart32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x0, 0x10000000, 0x20000000, 0x30000000, 0x40000000,_

_// 0x30000000, 0x20000000, 0x10000000_

**C**

**void**  **DSP_TransformWindow_Bart32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Black16 Function**

Perform a Blackman window on a vector.

**Description**

Function DSP_TransformWindow_Black16:

void DSP_TransformWindow_Black16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2\*Pi\*n/(N-1)) + 0.076849 \* COS(4\*Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Black16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x0071, 0x0665, 0x1DF1, 0x3B00, 0x3B00, 0x1DF1, 0x0665, 0x0071_

**C**

**void**  **DSP_TransformWindow_Black16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Black32 Function**

Perform a Blackman window on a vector.

**Description**

Function DSP_TransformWindow_Black32:

void DSP_TransformWindow_Black32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2\*Pi\*n/(N-1)) + 0.076849 \* COS(4\*Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Black32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x0070B490, 0x06649680, 0x1DF13240, 0x3B003D80, 0x3B003D80,_

_// 0x1DF13240, 0x06649680, 0x0070B490_

**C**

**void**  **DSP_TransformWindow_Black32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Cosine16 Function**

Perform a Cosine (Sine) window on a vector.

**Description**

Function DSP_TransformWindow_Cosine16:

void DSP_TransformWindow_Cosine16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Cosine16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x0000, 0x1BC5, 0x320A, 0x3E65, 0x3E65, 0x320A, 0x1BC5, 0x0071_

**C**

**void**  **DSP_TransformWindow_Cosine16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Cosine32 Function**

Perform a Cosine (Sine) window on a vector.

**Description**

Function DSP_TransformWindow_Cosine32:

void DSP_TransformWindow_Cosine32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Cosine32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x00000000, 0x1BC4C060, 0x32098700, 0x3E653800, 0x3E653800,_

_// 0x32098700, 0x1BC4C060, 0x00000000_

**C**

**void**  **DSP_TransformWindow_Cosine32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Hamm16 Function**

Perform a Hamming window on a vector.

**Description**

Function DSP_TransformWindow_Hamm16:

void DSP_TransformWindow_Hamm16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Hamm16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x051F, 0x0DBE, 0x228F, 0x3761, 0x4000, 0x3761, 0x228F, 0x0DBE_

**C**

**void**  **DSP_TransformWindow_Hamm16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Hamm32 Function**

Perform a Hamming window on a vector.

**Description**

Function DSP_TransformWindow_Hamm32:

void DSP_TransformWindow_Hamm32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples The functional

output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Hamm32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x051EB860, 0x0DBE26C0, 0x228F5C40, 0x37609200, 0x40000000,_

_// 0x37609200, 0x228F5C40, 0x0DBE26C0_

**C**

**void**  **DSP_TransformWindow_Hamm32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Hann16 Function**

Perform a Hanning window on a vector.

**Description**

Function DSP_TransformWindow_Hann16:

void DSP_TransformWindow_Hann16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Hann16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x0000, 0x095F, 0x2000, 0x36A1, 0x4000, 0x36A1, 0x2000, 0x095F_

**C**

**void**  **DSP_TransformWindow_Hann16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Hann32 Function**

Perform a Hanning window on a vector.

**Description**

Function DSP_TransformWindow_Hann32:

void DSP_TransformWindow_Hann32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples The functional

output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Hann32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x00000000, 0x095F61C0, 0x20000000, 0x36A09E80, 0x40000000,_

_// 0x36A09E80, 0x20000000, 0x095F61C0_

**C**

**void**  **DSP_TransformWindow_Hann32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Kaiser16 Function**

Perform a Kaiser window on a vector.

**Description**

Function DSP_TransformWindow_Kaiser16:

void DSP_TransformWindow_Kaiser16(int16_t \*OutVector, int16_t \*InVector, int N);

Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2\*Pi\*n/N) + 0.098 \* cos(4\*Pi\*n/N) + 0.001 \* cos(6\*Pi\*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16_t OutVector16[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector16[i]= 0x4000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Kaiser16(OutVector16, InVector16, WindowN);

_// OutWindow = 0x0031, 0x0325, 0x1375, 0x304F, 0x3FCF, 0x304F, 0x1375, 0x0325_

**C**

**void**  **DSP_TransformWindow_Kaiser16** (int16_t \* **OutVector** , int16_t \* **InVector** , int  **N** );

**DSP_TransformWindow_Kaiser32 Function**

Perform a Kaiser window on a vector.

**Description**

Function DSP_TransformWindow_Kaiser32:

void DSP_TransformWindow_Kaiser32(int32_t \*OutVector, int32_t \*InVector, int N);

Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2\*Pi\*n/N) + 0.098 \* cos(4\*Pi\*n/N) + 0.001 \* cos(6\*Pi\*n/N) where n is the window sample

number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32_t OutVector32[8]={0};

int WindowN = 8;

for (i=0;i\\&lt;WindowN;i++)

{

InVector32[i]= 0x40000000; _// constant 0.5 for functional testing_

}

DSP_TransformWindow_Kaiser32(OutVector32, InVector32, WindowN);

_// OutWindow = 0x003126F6, 0x032555C8, 0x1374BCA0, 0x304F66C0, 0x3FCED900,_

_// 0x304F66C0, 0x1374BCA0, 0x032555C8_

**C**

**void**  **DSP_TransformWindow_Kaiser32** (int32_t \* **OutVector** , int32_t \* **InVector** , int  **N** );

**DSP_TransformWinInit_Bart16 Function**

Create a Bartlett window.

**Description**

Function DSP_TransformWinInit_Bart16:

void DSP_TransformWinInit_Bart16(int16_t \*OutWindow, int N);

Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Bartlett Window follows

the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of

significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during

recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Bart16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Bart32 Function**

Create a Bartlett window.

**Description**

Function DSP_TransformWinInit_Bart32:

void DSP_TransformWinInit_Bart32(int32_t \*OutWindow, int N);

Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values Q31 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Bart32** (int32_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Black16 Function**

Create a Blackman window.

**Description**

Function DSP_TransformWinInit_Black16:

void DSP_TransformWinInit_Black16(int16_t \*OutWindow, int N);

Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating

point, and rounded for the most accuracy possible. Output values are Q16 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2\*Pi\*n/(N-1)) + 0.076849 \* COS(4\*Pi\*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Black16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Black32 Function**

Create a Blackman window.

**Description**

Function DSP_TransformWinInit_Black32:

void DSP_TransformWinInit_Black32(int32_t \*OutWindow, int N);

Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are Q31 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2\*Pi\*n/(N-1)) + 0.076849 \* COS(4\*Pi\*n/(N-1)) where n is the window sample number N is

the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Black32** (int32_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Cosine16 Function**

Create a Cosine (Sine) window.

**Description**

Function DSP_TransformWinInit_Cosine16:

void DSP_TransformWinInit_Cosine16(int16_t \*OutWindow, int N);

Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Cosine16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Cosine32 Function**

Create a Cosine (Sine) window.

**Description**

Function DSP_TransformWinInit_Cosine32:

void DSP_TransformWinInit_Cosine32(int32_t \*OutWindow, int N);

Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Cosine32** (int32_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Hamm16 Function**

Create a Hamming window.

**Description**

Function DSP_TransformWinInit_Hamm16:

void DSP_TransformWinInit_Hamm16(int16_t \*OutWindow, int N);

Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Hamm16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Hamm32 Function**

Create a Hamming window.

**Description**

Function DSP_TransformWinInit_Hamm32:

void DSP_TransformWinInit_Hamm32(int32_t \*OutWindow, int N);

Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Hamm32** (int32_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Hann16 Function**

Create a Hanning window.

**Description**

Function DSP_TransformWinInit_Hann16:

void DSP_TransformWinInit_Hann16(int16_t \*OutWindow, int N);

Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Hann16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Hann32 Function**

Create a Hanning window.

**Description**

Function DSP_TransformWinInit_Hann32:

void DSP_TransformWinInit_Hann32(int32_t \*OutWindow, int N);

Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2\*Pi\*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Hann32** (int32_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Kaiser16 Function**

Create a Kaiser window.

**Description**

Function DSP_TransformWinInit_Kaiser16:

void DSP_TransformWinInit_Kaiser16(int16_t \*OutWindow, int N);

Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2\*Pi\*n/N) + 0.098 \* cos(4\*Pi\*n/N) + 0.001 \* cos(6\*Pi\*n/N) where n is the window sample

number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Kaiser16** (int16_t \* **OutWindow** , int  **N** );

**DSP_TransformWinInit_Kaiser32 Function**

Create a Kaiser window.

**Description**

Function DSP_TransformWinInit_Kaiser32:

void DSP_TransformWinInit_Kaiser32(int32_t \*OutWindow, int N);

Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2\*Pi\*n/N) + 0.098 \* cos(4\*Pi\*n/N) + 0.001 \* cos(6\*Pi\*n/N) where n is the window sample

number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void**  **DSP_TransformWinInit_Kaiser32** (int32_t \* **OutWindow** , int  **N** );

**DSP_VectorAbs16 Function**

Calculate the absolute value of a vector.

**Description**

Function DSP_VectorAbs16:

void DSP_VectorAbs16(int16_t \*outdata, int16_t \*indata, int N);

Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata[i] filled with the absolute value of elements of indata 
**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of

eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAbs16(pOutdata, inBufTest, Num);

_// outVal[i] = {5,2,3,4,1,0,2,8}_

**C**

**void**  **DSP_VectorAbs16** (int16_t \* **outdata** , int16_t \* **indata** , int  **N** );

**DSP_VectorAbs32 Function**

Calculate the absolute value of a vector.

**Description**

Function DSP_VectorAbs32:

void DSP_VectorAbs32(int32_t \*outdata, int32_t \*indata, int N);

Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata[i] filled with N elements of abs(indata[i])

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata pointer to input array of 16-bit elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAbs32(pOutdata, inBufTest, Num);

_// outVal[i] = {5,2,3,4,1,0,2,8}_

**C**

**void**  **DSP_VectorAbs32** (int32_t \* **outdata** , int32_t \* **indata** , int  **N** );

**DSP_VectorAdd16 Function**

Calculate the sum of two vectors.

**Description**

Function DSP_VectorAdd16:

void DSP_VectorAdd16(int16_t \*outdata, int16_t \*indata1, int16_t \*indata2, int N);

Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata[i] filled with N elements of indata1[i] + indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata1 pointer to input array of 16-bit elements (int16_t)

indata2 pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int16_t inBuf2[16]= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAdd16(pOutdata, inBufTest, inBuf2, Num);

_// outVal[i] = inBufTest[i] + inBuf2[i] = {-4,4,0,8,4,6,5,0}_

**C**

**void**  **DSP_VectorAdd16** (int16_t \* **outdata** , int16_t \* **indata1** , int16_t \* **indata2** , int  **N** );

**DSP_VectorAdd32 Function**

Calculate the sum of two vectors.

**Description**

Function DSP_VectorAdd32:

void DSP_VectorAdd32(int32_t \*outdata, int32_t \*indata1, int32_t \*indata2, int N);

Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata[i] filled with N elements of indata1[i] + indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata1 pointer to input array of 16-bit elements (int32_t)

indata2 pointer to input array of 16-bit elements (int32_t)

N number of samples

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int32_t inBuf2[16]= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAdd32(pOutdata, inBufTest, inBuf2, Num);

_// outVal[i] = inBufTest[i] + inBuf2[i] = {-4,4,0,8,4,6,5,0}_

**C**

**void**  **DSP_VectorAdd32** (int32_t \* **outdata** , int32_t \* **indata1** , int32_t \* **indata2** , int  **N** );

**DSP_VectorAddc16 Function**

Calculate the sum of a vector and a constant.

**Description**

Function DSP_VectorAddc16:

void DSP_VectorAddc16(int16_t \*outdata, int16_t \*indata, int16_t c, int N);

Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata[i] filled with N elements of indata[i] + c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata pointer to input array of 16-bit elements (int16_t)

c constant value added to all indata1 elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int16_t constValue = 3;

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAddc16(pOutdata, inBufTest, constValue, Num);

_// outVal[i] = inBufTest[i] + constValue = {-2,5,0,7,2,3,1,-5}_

**C**

**void**  **DSP_VectorAddc16** (int16_t \* **outdata** , int16_t \* **indata** , int16_t **c** , int  **N** );

**DSP_VectorAddc32 Function**

Calculate the sum of a vector and a constant.

**Description**

Function DSP_VectorAddc32:

void DSP_VectorAddc32(int32_t \*outdata, int32_t \*indata, int32_t c, int N);

Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata[i] filled with N elements of indata1[i] + c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata pointer to input array of 16-bit elements (int32_t)

c constant value added to all indata1 elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int32_t constValue = 3;

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorAddc32(pOutdata, inBufTest, constValue, Num);

_// outVal[i] = inBufTest[i] + constValue = {-2,5,0,7,2,3,1,-5}_

**C**

**void**  **DSP_VectorAddc32** (int32_t \* **outdata** , int32_t \* **indata** , int32_t **c** , int  **N** );

**DSP_VectorAutocorr16 Function**

Computes the Autocorrelation of a Vector.

**Description**

Function DSP_VectorAutocorr16:

void DSP_VectorAutocorr16(int16_t \*outCorr, int16_t \*inVector, int N, int K);

Calculates the autocorrelation, with a lag of 1 to K, on the first N elements of inVector and returns the 16-bit scalar result in outCorr. The autocorrelation is calculated from other statistical equations including mean and variance. While in some cases these equations exist inside the DSP library, the functions are executed in a serial fashion within this code to provide enhanced performance. The unbiased function has the form -

mean (M) = sum[0..N-1](x(n) / N) variance (V) = sum[0..N-1]((x(n) - M)\^2) / (N-1) autocovariance (ACV)[k] = sum[0..(N-k)]((x(n) -

M) \* (x(n+k) - M) / (N-k)) autocorrelation (AC)[k] = CV[k] / V where N is the number of vector elements, n is the index of those elements x(n) is a single element in the input vector M is the mean of the N elements of the vector k is the lag or series index

The output of the function will return K elements, and the outCorr array should be sized to accept those 16-bit results. The outputs correspond to k=1, k=2, .., k=K delay states. The function returns a 16-bit value in rounded, saturated Q15 format.

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. outCorr must be an array with at least K values. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outCorr pointer to output array (int16_t)

inVector pointer to source array of elements (int16_t)

N number of samples (int)

K lag value, number of output elements (int)

**Returns**

None.

**Remarks**

This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the _LIBQ_Q16Div specifically.

**Example**

int autocvN = 16; _// N value, number of samples in array_

int autocvLag = 4; _// Lag value, output shifts to observe_

int16_t outAC[16]={0};

int16_t CVIn16[16] = {0x1999, 0xD99A, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666,

0x3333, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666, 0x3333, 0x1999, 0x0CCC};

_// = { .2, -.3, .125, .75, .2, .2, .3, .4, .125, .75, .2, .2, .3, .4, .2, .1};_

DSP_VectorAutocorr16(outAC, CVIn16, autocvN, autocvLag);

_// outAC = {0xF406, D46C, 0x098F, 0x191A}_

_// = -0.093567, -0.34045, 0.07468, 0.19611_

**C**

**void**  **DSP_VectorAutocorr16** (int16_t \* **outCorr** , int16_t \* **inVector** , int  **N** , int  **K** );

**DSP_VectorBexp16 Function**

Computes the maximum binary exponent of a vector.

**Description**

Function DSP_VectorBexp16:

int DSP_VectorBexp16(int16_t \*DataIn, int N);

Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q15 fractional data format.

**Preconditions**

N must be a multiple of 2 and greater or equal to 2.

**Parameters**

**Parameters Description**

DataIn pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

Binary exponent [log2 multiplier] (int)

**Remarks**

None.

**Example**

int valN = 4;

int16_t dummy16[valN]={0x3004, 0x00CC, 0xFC04, 0xFFF0};

_// 0.375, 0.0062, -0.0311, -0.00049_

int answer;

answer = DSP_VectorBexp16(dummy16, valN);

_// answer = 1, maximum binary gain is 2._

**C**

int  **DSP_VectorBexp16** (int16_t \* **DataIn** , int  **N** );

**DSP_VectorBexp32 Function**

Computes the maximum binary exponent of a vector.

**Description**

Function DSP_VectorBexp32:

int DSP_VectorBexp32(int32_t \*DataIn, int N);

Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q31 fractional data format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

DataIn pointer to input array of 16-bit elements (int32_t)

N number of samples (int)

**Returns**

Binary exponent [log2 multiplier] (int)

**Remarks**

None.

**Example**

int valN=4;

int32_t datInput32[4]={0xFF000000, 0x07000000,0x000CCCCC, 0x08000000};

_// -0.007183, 0.054688, 0.0003906, 0.0625_

int answer32;

answer32 = DSP_VectorBexp32(datInput32, valN);

_// answer = 3, maximum binary gain is 8._

**C**

int  **DSP_VectorBexp32** (int32_t \* **DataIn** , int  **N** );

**DSP_VectorChkEqu32 Function**

Compares two input vectors, returns an integer &#39;1&#39; if equal, and &#39;0&#39; if not equal.

**Description**

Function DSP_VectorChkEqu32:

int DSP_VectorChkEqu32(int32_t \*indata1, int32_t \*indata2, int N);

Compares the first N values of indata1 to the same elements of indata2. The comparison requires that all numbers be in Q31 fractional data format. Returns the integer value &#39;1&#39; if all numbers are equal, and &#39;0&#39; if they are not equal. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata1 pointer to input array 1 of elements (int32_t)

indata2 pointer to input array 2 of elements (int32_t)

N number of samples (int)

**Returns**

(int) - &#39;1&#39; if vectors are equal, &#39;0&#39; if vectors are not equal

**Remarks**

None.

**Example**

int outCheck;

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufTestB[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x80000000, 0x40000000, 0x7FFFFFFF, 0x20000000};

_// 1, -1, 0.9, 0.8, -1, 0.5, 1, 0.25_

outCheck = DSP_VectorChkEqu32(inBufTestA, inBufTestB, Num);

_// outCheck = 1 // true for first 4 numbers of series_

**C**

int  **DSP_VectorChkEqu32** (int32_t \* **indata1** , int32_t \* **indata2** , int  **N** );

**DSP_VectorCopy Function**

Copies the elements of one vector to another.

**Description**

Function DSP_VectorCopy:

void DSP_VectorCopy(int32_t \*outdata, int32_t \*indata, int N);

Fills the first N values of an input vector outdata with the elements from indata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of values (int32_t)

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufTestB[8]={0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000};

_// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25_

DSP_VectorCopy(inBufTestA, inBufTestB, Num);

_// inBufTestA = {0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,_

_// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values copied_

**C**

**void**  **DSP_VectorCopy** (int32_t \* **outdata** , int32_t \* **indata** , int  **N** );

**DSP_VectorCopyReverse32 Function**

Reverses the order of elements in one vector and copies them into another.

**Description**

Function DSP_VectorCopyReverse32:

void DSP_VectorCopyReverse32(int32_t \*outdata, int32_t \*indata, int N);

Fills the first N values of an input vector Outdata with the reverse elements from INDATA. N must be a multiple of 4 and greater than 4 or will be truncated to the nearest multiple of 4. The vectors are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of values (int32_t)

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufTestB[8]={0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000};

_// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25_

DSP_VectorCopyReverse32(inBufTestA, inBufTestB, Num);

_// inBufTestA = {0x0CCCCCCC, 0x40000000, 0x7FFFFFFF, 0x00000000,_

_// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334}_

_// first 4 values copied reverse order_

**C**

**void**  **DSP_VectorCopyReverse32** (int32_t \* **outdata** , int32_t \* **indata** , int  **N** );

**DSP_VectorDivC Function**

Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.

**Description**

Function DSP_VectorDivC:

void DSP_VectorDivC(_Q16 \*outVector, _Q16 \*inVector, _Q16 divisor, int N);

Divides each element of the first N elements of inVector by a constant, divisor. The output is stored to outVector. Both vectors and the scalar are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library. 

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q16)

divisor scalar divisor for the input vector (_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for _LIBQ_Q16Div.

**Example**

int divNum = 4;

_Q16 divScalar = 0x00020000; _// 2.0_

_Q16 inDivVec[8] = {0x08000000, 0xfffc0000,0x00024000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000};

_// 2048, -4, 2.25, 16, 3.5, 64, -2, 5.5_

_Q16 outDivVec[8] = {0};

DSP_VectorDivC(outDivVec, inDivVec, divScalar, divNum);

_// outDivVec = 0x04000000, 0xFFFFE0000, 0x00012000, 0x00080000, 0, 0, 0, 0_

_// 1024.0, -2.0, 1.125, 16.0, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorDivC** (_Q16 \* **outVector** , _Q16 \* **inVector** , _Q16 **divisor** , int  **N** );

**DSP_VectorDotp16 Function**

Computes the dot product of two vectors, and scales the output by a binary factor.

**Description**

Function DSP_VectorDotp16:

int16_t DSP_VectorDotp16(int16_t \*indata1, int16_t \*indata2, int N, int scale);

Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in Q15 fractional format.

return = 1/(2\^scale) \* sum(indata1[i] \* indata2[i])

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of

eight.

**Parameters**

**Parameters Description**

indata1 pointer to input array of 16-bit elements (int16_t)

indata2 pointer to input array of 16-bit elements (int16_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t inBufMultA[8]={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int16_t inBufMultB[8]={0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD};

_// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1_

int Num = 8;

int scaleVal = 2;

int16_t outScalar;

int Num = 8;

outScalar = DSP_VectorDotp16(inBufMultA, inBufMultB, Num, scaleVal);

_// outScalar = 1/(2\^scaleVal)\*(inBufMultA[] dot inBufMultB[]) =_

_// (1/4) \* (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 \* 0.20 = 0.05_

_// = (int16_t)0x0666_

**C**

int16_t **DSP_VectorDotp16** (int16_t \* **indata1** , int16_t \* **indata2** , int  **N** , int  **scale** );

**DSP_VectorDotp32 Function**

Computes the dot product of two vectors, and scales the output by a binary factor

**Description**

Function DSP_VectorDotp32:

int32_t DSP_VectorDotp32(int32_t \*indata1, int32_t \*indata2, int N, int scale);

Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum

values. Scaling is done by binary shifting, after calculation of the result. All calculations are done in Q31 fractional format. return =

1/(2\^scale) \* sum(indata1[i] \* indata2[i])

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata1 pointer to input array of 16-bit elements (int32_t)

indata2 pointer to input array of 16-bit elements (int32_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16_t - scaled output of calculation, Q31 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int32_t inBufMultA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufMultB[8]={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};

_// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1_

int Num = 8;

int scaleVal = 2;

int32_t outScalar;

int Num = 8;

outScalar = DSP_VectorDotp32(inBufMultA, inBufMultB, Num, scaleVal);

_// outScalar = 1/(2\^scaleVal)\*(inBufMultA[] dot inBufMultB[]) =_

_// (1/4) \* (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 \* 0.20 = 0.05_

_// = (int32_t)0x06666666_

**C**

int32_t **DSP_VectorDotp32** (int32_t \* **indata1** , int32_t \* **indata2** , int  **N** , int  **scale** );

**DSP_VectorExp Function**

Computes the EXP (e\^x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorExp:

void DSP_VectorExp(_Q16 \*outVector, _Q16 \*inVector, int N);

Computes the Exp value, e to the power of X, on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Exp and Div functions from the LibQ library. That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

Inclusion of the LibQ header file and library is mandatory to use this function.

**Example**

int expNum = 4;

_Q16 inExpVec[8] = {0x00010000, 0xffff0000,0x00020000,0x00030000,0x00038000,

0x00040000,0xfffe0000,0x00058000};

_// 1.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5_

_Q16 outExpVec[8] = {0};

DSP_VectorExp(outExpVec, inExpVec, expNum);

_// outExpVec = 0x0002B7E1, 0x00005E2D, 0x00076399, 0x001415E6, 0, 0, 0, 0_

_// 2.71828, 0.26787, 7.3891, 20.0855, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorExp** (_Q16 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorFill Function**

Fills an input vector with scalar data.

**Description**

Function DSP_VectorFill:

void DSP_VectorFill(int32_t \*indata, int32_t data, int N);

Fills the first N values of an input vector indata with the value data. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32_t)

data scalar value to fill the array (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int32_t fillValue = 0x3FFFFFFF;

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

DSP_VectorFill(inBufTestA, fillValue, Num);

_// inBufTestA = {0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF,_

_// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values filled_

**C**

**void**  **DSP_VectorFill** (int32_t \* **indata** , int32_t **data** , int  **N** );

**DSP_VectorLn Function**

Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorLn:

void DSP_VectorLn(_Q4_11 \*outVector, _Q16 \*inVector, int N);

Computes the Ln(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q4.11 format, which is a 16-bit integer format with 11 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Ln function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q4_11)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the

design in order to operate this function. For more information on the Ln function see the LibQ documentation for _LIBQ_Q4_11_ln_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int lnNum = 4;

_Q16 inLnVal[8] = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000};

_// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5_

_Q4_11 outLnVal[8] = {0};

DSP_VectorLn(outLnVal, inLnVal, lnNum);

_// outLnVal = 0x4DA2, 0x8000, 0x058C, 0x162E, 0, 0, 0, 0_

_// 9.704, sat negative, 0.6934, 2.772, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorLn** (_Q4_11 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorLog10 Function**

Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorLog10:

void DSP_VectorLog10(_Q3_12 \*outVector, _Q16 \*inVector, int N);

Computes the Log10(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q3.12 format, which is a 16-bit integer format with 12 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log10 function from the LibQ library. That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q3_12)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log10 function see the LibQ documentation for _LIBQ_Q3_12_log10_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int logNum = 4;

_Q16 inLogVal[8] = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000};

_// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5_

_Q3_12 outLogVal[8] = {0};

DSP_VectorLog10(outLogVal, inLogVal, logNum);

_// outLogVal = 0x436E, 0x8000, 0x04D1, 0x1344, 0, 0, 0, 0_

_// 4.2144, sat negative, 0.3010, 1.2041, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorLog10** (_Q3_12 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorLog2 Function**

Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorLog2:

void DSP_VectorLog2(_Q5_10 \*outVector, _Q16 \*inVector, int N);

Computes the Log2 value, where log2(x) = ln(x) \* log2(e), on the first N elements of inVector. The output is stored to outVector.

Input vector is _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q5.10 format, which is a 16-bit integer format with 10 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log2 function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q5_10)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log2 function see the LibQ documentation for _LIBQ_Q5_10_log2_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int log2Num = 4;

_Q16 inLog2Val[8] = {0x40000000, 0xffff0000,0x00020000,0x00030000,0x00038000,

0x00040000,0xfffe0000,0x00058000};

_// 16384.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5_

_Q5_10 outLog2Val[8] = {0};

DSP_VectorLog2(outLog2Val, inLog2Val, log2Num);

_// outLog2Val = 0x3800, 0x8000, 0x0400, 0x0657, 0, 0, 0, 0_

_// 14.0, sat negative, 1.0, 1.585, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorLog2** (_Q5_10 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorMax32 Function**

Returns the maximum value of a vector.

**Description**

Function DSP_VectorMax32:

int32_t DSP_VectorMax32(int32_t \*indata, int N);

Returns the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of elements (int32_t)

N number of samples (int)

**Returns**

(int32_t) - maximum value within the vector, Q31 format

**Remarks**

None.

**Example**

int32_t outCheck;

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

outCheck = DSP_VectorMax32(inBufTestA, Num);

_// outCheck = 0x7FFFFFFF // first 4 values_

**C**

int32_t **DSP_VectorMax32** (int32_t \* **indata** , int  **N** );

**DSP_VectorMaxIndex32 Function**

Returns the index of the maximum value of a vector.

**Description**

Function DSP_VectorMaxIndex32:

int DSP_VectorMaxIndex32(int32_t \*indata, int N);

Returns the index of the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

int - index of the position of the maximum array element

**Remarks**

Index values range from 0 .. (n-1).

**Example**

int indexValue;

int Num = 8;

int32_t inBufTestA[8]={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

indexValue = DSP_VectorMaxIndex32(inBufTestA, Num);

_// returnValue = 6 (position corresponding to 0x7FFFFFFF)_

**C**

int  **DSP_VectorMaxIndex32** (int32_t \* **indata** , int  **N** );

**DSP_VectorMean32 Function**

Calculates the mean average of an input vector.

**Description**

Function DSP_VectorMean32:

int32_t DSP_VectorMean32(int32_t \*indata, int N);

Calculates the mean average of the first N elements of the vector indata. The values of indata1 are in Q31 fractional format. The value N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

int32_t - mean average value of the vector

**Remarks**

None.

**Example**

int32_t returnValue;

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

returnValue = DSP_VectorMean32(inBufTestA, Num);

_// returnValue = 0x36666666 = (1-1+0.9+0.8)/4 = 0.425_

**C**

int32_t **DSP_VectorMean32** (int32_t \* **indata1** , int  **N** );

**DSP_VectorMin32 Function**

Returns the minimum value of a vector.

**Description**

Function DSP_VectorMin32:

int32_t DSP_VectorMin32(int32_t \*indata, int N);

Returns the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of elements (int32_t)

N number of samples (int)

**Returns**

(int32_t) - minimum value within the vector, Q31 format

**Remarks**

None.

**Example**

int32_t outCheck;

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

outCheck = DSP_VectorMin32(inBufTestA, Num);

_// outCheck = 0x80000000 // first 4 values_

**C**

int32_t **DSP_VectorMin32** (int32_t \* **input** , int  **N** );

**DSP_VectorMinIndex32 Function**

Returns the index of the minimum value of a vector.

**Description**

Function DSP_VectorMinIndex32:

int DSP_VectorMinIndex32(int32_t \*indata, int N);

Returns the relative position index of the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

int32_t - mean average value of the vector

**Remarks**

Index values range from 0 .. (n-1).

**Example**

int indexValue;

int Num = 8;

int32_t inBufTestA[8]={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

indexValue = DSP_VectorMinIndex32(inBufTestA, Num);

_// returnValue = 1 (position corresponding to 0x80000000)_

**C**

int  **DSP_VectorMinIndex32** (int32_t \* **indata** , int  **N** );

**DSP_VectorMul16 Function**

Multiplication of a series of numbers in one vector to another vector.

**Description**

Function DSP_VectorMul16:

void DSP_VectorMul16(int16_t \*outdata, int16_t \*indata1, int16_t \*indata2, int N);

Multiples the value of each element of indata1 \* indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata[i] filled with N elements of indata1[i] \* indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata1 pointer to input array of 16-bit elements (int16_t)

indata2 pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufMultA[8]={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int16_t inBufMultB[8]={0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD};

_// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1_

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorMul16(pOutdata, inBufMultA, inBufMultB, Num);

_// outVal[i] = inBufTest[i] \* inBuf2[i] =_

_// {0x0CCD, 0xF333, 0x399A, 0xCCCD, 0xFAE2, 0x2000, 0x0000, 0xF852}_

_// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06_

**C**

**void**  **DSP_VectorMul16** (int16_t \* **outdata** , int16_t \* **indata1** , int16_t \* **indata2** , int  **N** );

**DSP_VectorMul32 Function**

Multiplication of a series of numbers in one vector to another vector.

**Description**

Function DSP_VectorMul32:

void DSP_VectorMul32(int32_t \*outdata, int32_t \*indata1, int32_t \*indata2, int N);

Multiples the value of each element of indata1 \* indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q31 fractional format. outdata[i] filled with N elements of indata1[i] \* indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata1 pointer to input array of 16-bit elements (int32_t)

indata2 pointer to input array of 16-bit elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufMultA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufMultB[8]={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};

_// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1_

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorMul32(pOutdata, inBufMultA, inBufMultB, Num);

_// outVal[i] = inBufTest[i] \* inBuf2[i] =_

_// {0x0CCCCCCD, 0xF3333333, 0x3999999A, 0xCCCCCCCD, 0xFAE147AE,_

_// 0x20000000, 0x00000000, 0xF851EB86}_

_// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06_

**C**

**void**  **DSP_VectorMul32** (int32_t \* **outdata** , int32_t \* **indata1** , int32_t \* **indata2** , int  **N** );

**DSP_VectorMulc16 Function**

Multiplication of a series of numbers in one vector to a scalar value.

**Description**

Function DSP_VectorMulc16:

void DSP_VectorMulc16(int16_t \*outdata, int16_t \*indata, int16_t c, int N);

Multiples the value of each element of indata1 \* c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata[i] filled with N elements of indata[i] \* c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata pointer to input array of 16-bit elements (int16_t)

c scalar multiplicand (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufMultA[8]={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x0000, 0xB334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 0, -0.6_

int16_t constValue = 0x4000;

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorMulc16(pOutdata, inBufMultA, constValue, Num);

_// outVal[i] = inBufTest[i] \* constValue =_

_// {0x4000, 0xC000, 0x399A, 0x3333, 0x1999, 0x2000, 0x0000, 0xD99A}_

_// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3_

**C**

**void**  **DSP_VectorMulc16** (int16_t \* **outdata** , int16_t \* **indata** , int16_t **c** , int  **N** );

**DSP_VectorMulc32 Function**

Multiplication of a series of numbers in one vector to a scalar value.

**Description**

Function DSP_VectorMulc32:

void DSP_VectorMulc32(int32_t \*outdata, int32_t \*indata, int32_t c, int N);

Multiples the value of each element of indata \* c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata[i] filled with N elements of indata[i] \* c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata pointer to input array of 16-bit elements (int32_t)

c scalar multiplicand (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufMultA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x00000000, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t constValue = 0x4000;

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorMulc32(pOutdata, inBufMultA, constValue, Num);

_// outVal[i] = inBufTest[i] \* constValue =_

_// {0x40000000, 0xC0000000, 0x3999999A, 0x33333333, 0x19999999,_

_// 0x20000000, 0x00000000, 0xD999999A}_

_// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3_

**C**

**void**  **DSP_VectorMulc32** (int32_t \* **outdata** , int32_t \* **indata** , int32_t **c** , int  **N** );

**DSP_VectorNegate Function**

Inverses the sign (negates) the elements of a vector.

**Description**

Function DSP_VectorNegate:

void DSP_VectorNegate(int32_t \*outdata, int32_t \*indata, int N);

Sign inversion of the first N values of an indata are assigned to outdata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32_t)

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t outBufTest[8]={0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD};

_// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1;_

DSP_VectorNegate(outBufTest, inBufTestA, Num);

_// inBufTestA = {0x80000000, 0x7FFFFFFF, 0x8CCCCCCD, 0x9999999A,_

_// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334} // first 4 values neg_

_// -1, 1, -0.9, -0.8, -0.2, 0.5, 0, 0.1_

**C**

**void**  **DSP_VectorNegate** (int32_t \* **outdata** , int32_t \* **indata** , int  **N** );

**DSP_VectorRecip Function**

Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorRecip:

void DSP_VectorRecip(_Q16 \*outVector, _Q16 \*inVector, int N);

Computes the reciprocal (1/x) on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for _LIBQ_Q16Div.

A value of zero in the array will not cause an error, but will return 0.

**Example**

int recNum = 4;

_Q16 inRecVec[8] = {0x08000000, 0xfffc0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000};

_// 2048.0, -4.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5_

_Q16 outRecVec[8] = {0};

DSP_VectorRecip(outRecVec, inRecVec, recNum);

_// outRecVec = 0x00000020, 0xFFFFC0000, 0x00008000, 0x00001000, 0, 0, 0, 0_

_// 0.000488, -0.25, 0.5, 0.0625, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorRecip** (_Q16 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorRMS16 Function**

Computes the root mean square (RMS) value of a vector.

**Description**

Function DSP_VectorRMS16:

int16_t DSP_VectorRMS16(int16_t \*inVector, int N);

Computes the root mean square value of the first N values of inVector. Both input and output are Q15 fractional values. The function will saturate if maximum or minimum values are exceeded.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

int16_t - RMS function output, Q15 format

**Remarks**

This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and uses the _LIBQ_Q16Sqrt external function call.

**Example**

int16_t vecRMSIn[32]={0x1999, 0xD99A, 0x4000, 0x2666,0x1999,0x1999,0x2666, 0x3333};

_// 0.2, -0.3, 0.5, 0.3, 0.2, 0.2, 0.3, 0.4_

int16_t RMSOut=0;

int Nrms = 8;

RMSOut = DSP_VectorRMS16(vecRMSIn, Nrms);

_// RMSOut = 0x287C (= 0.31628)_

**C**

int16_t **DSP_VectorRMS16** (int16_t \* **inVector** , int  **N** );

**DSP_VectorShift Function**

Shifts the data index of an input data vector.

**Description**

Function DSP_VectorShift:

void DSP_VectorShift(int32_t \*outdata, int32_t \*indata, int N, int shift);

Shifts N data elements of indata to outdata, with an index change of shift. The amount of data shifted includes zero padding for

the first (shift) elements if shift is positive. The vector size of indata and outdata need not be the same, however, N must not exceed either array size.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must not exceed the amount of elements in the source array. shift must not exceed the number of elements in the destination array.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32_t)

indata pointer to source array of elements (int32_t)

N number of samples (int)

shift number of indexes to shift (int)

**Returns**

None.

**Remarks**

Destination array values shift to left (relative to the input vector) when shift is positive (back filled with zeros) and shift to the right when shift is negative. The total amount of values copied to the destination array is the length of N less the shift amount.

**Example**

int shiftValue = 3;

int Num = 8;

int32_t inBufTestA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int32_t inBufTestB[8]={0x80000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000};

_// -1, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25_

DSP_VectorShift(inBufTestA, inBufTestB, Num, shiftValue);

_// inBufTestA = {0x00000000, 0x00000000, 0x00000000, 0x80000000,_

_// 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC, 0x40000000} // shifted 3 positive_

**C**

**void**  **DSP_VectorShift** (int32_t \* **outdata** , int32_t \* **indata** , int  **N** , int  **shift** );

**DSP_VectorSqrt Function**

Computes the square root of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP_VectorSqrt:

void DSP_VectorSqrt(_Q16 \*outVector, _Q16 \*inVector, int N);

Computes the Sqrt(x) on the first N elements of inVector. The output is stored to outVector. Both vectors are _Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Sqrt function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (_Q16)

indata pointer to source array of elements (_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Sqrt function see the LibQ documentation for _LIBQ_Q16Sqrt. A negative number input will return a saturated value (0x00FFFFxx).

**Example**

int sqrtNum = 4;

_Q16 inSqrtVec[8] = {0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000};

_// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5_

_Q16 outSqrtVec[8] = {0};

DSP_VectorSqrt(outSqrtVec, inSqrtVec, sqrtNum);

_// outSqrtVec = 0x00800000, 0x00FFFF80, 0x00016A0A, 0x00040000, 0, 0, 0, 0_

_// 128.0, sat negative, 1.41422, 4.0, 0, 0, 0, 0_

**C**

**void**  **DSP_VectorSqrt** (_Q16 \* **outVector** , _Q16 \* **inVector** , int  **N** );

**DSP_VectorStdDev16 Function**

Computes the Standard Deviation of a Vector.

**Description**

Function DSP_VectorStdDev16:

int16_t DSP_VectorStdDev16(int16_t \*inVector, int N);

Calculates the standard deviation on the first N elements of inVector and returns the 16-bit scalar result. The standard deviation is the square root of the variance, which is a measure of the delta from mean values. The mean value of the vector is computed in

the process. The function has the form -

StdDev = SQRT(sum[0..N]((x(i) - M(N))\^2) / (N-1)) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and ha internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

Dependent on use of the LibQ library.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int16_t)

N number of samples (int)

**Returns**

int16_t - Standard Deviation of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the _LIBQ_Q16Sqrt specifically.

**Example**

int16_t vecStDevIn[32]={0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333};

_// .2, -.3, .125, .75, .2, .2, .3, .4_

int16_t StDevOut, Var16Out;

int Nstdev = 4;

StDevOut = DSP_VectorStdDev16(vecStDevIn, Nstdev);

_// StDevOut = 0x3A9E (= 0.45797)_

**C**

int16_t **DSP_VectorStdDev16** (int16_t \* **inVector** , int  **N** );

**DSP_VectorSub16 Function**

Calculate the difference of two vectors.

**Description**

Function DSP_VectorSub16:

void DSP_VectorSub16(int16_t \*outdata, int16_t \*indata1, int16_t \*indata2, int N);

Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata[i] filled with N elements of indata1[i] - indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16_t)

indata1 pointer to input array of 16-bit elements (int16_t)

indata2 pointer to input array of 16-bit elements (int16_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int16_t outVal[8];

int16_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int16_t inBuf2[16]= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorSub16(pOutdata, inBufTest, inBuf2, Num);

_// outVal[i] = inBufTest[i] - inBuf2[i] = {-6,0,-6,0,-6,-6,-9,-16}_

**C**

**void**  **DSP_VectorSub16** (int16_t \* **outdata** , int16_t \* **indata1** , int16_t \* **indata2** , int  **N** );

**DSP_VectorSub32 Function**

Calculate the difference of two vectors.

**Description**

Function DSP_VectorSub32:

void DSP_VectorSub32(int32_t \*outdata, int32_t \*indata1, int32_t \*indata2, int N);

Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata[i] filled with N elements of indata1[i] - indata2[i]

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32_t)

indata1 pointer to input array of 16-bit elements (int32_t)

indata2 pointer to input array of 16-bit elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t \*pOutdata;

int32_t outVal[8];

int32_t inBufTest[16] = {-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2};

int32_t inBuf2[16]= { 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0};

int Num = 8;

pOutdata = &amp;outVal;

DSP_VectorSub32(pOutdata, inBufTest, inBuf2, Num);

_// outVal[i] = inBufTest[i] - inBuf2[i] = {-6,0,-6,0,-6,-6,-9,-16}_

**C**

**void**  **DSP_VectorSub32** (int32_t \* **outdata** , int32_t \* **indata1** , int32_t \* **indata2** , int  **N** );

**DSP_VectorSumSquares16 Function**

Computes the sum of squares of a vector, and scales the output by a binary factor.

**Description**

Function DSP_VectorSumSquares16:

int16_t DSP_VectorSumSquares16(int16_t \*indata, int N, int scale);

Calculates the sum of the squares of each element of an input vector, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in

Q15 fractional format. return = 1/(2\^scale) \* sum(indata[i]\^2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int16_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16_t inBufMultA[8]={0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int Num = 8;

int scaleVal = 3;

int16_t outScalar;

outScalar = DSP_VectorSumSquares16(inBufMultA, Num, scaleVal);

_// outScalar = 1/(2\^scaleVal)\* sum(inBufMultA[i]\^2) =_

_// (1/8) \* (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 \* 5.1 = 0.6375_

_// = (int16_t)0x5199_

**C**

int16_t **DSP_VectorSumSquares16** (int16_t \* **indata** , int  **N** , int  **scale** );

**DSP_VectorSumSquares32 Function**

Computes the sum of squares of a vector, and scales the output by a binary factor.

**Description**

Function DSP_VectorSumSquares32:

int32_t DSP_VectorSumSquares32(int32_t \*indata, int N, int scale);

Calculates the sum of the squares of each element of an input vector, and scales the output. The function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after calculation of the results. All calculations are done in Q31 fractional format. return = 1/(2\^scale) \* sum(indata[i]\^2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of

four.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int32_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int32_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int32_t inBufMultA[8]={0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x00000000, 0xB3333334};

_// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

int Num = 8;

int scaleVal = 3;

int32_t outScalar;

outScalar = DSP_VectorSumSquares32(inBufMultA, Num, scaleVal);

_// outScalar = 1/(2\^scaleVal)\* sum(inBufMultA[i]\^2) =_

_// (1/8) \* (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 \* 5.1 = 0.6375_

_// = (int32_t)0x51999999_

**C**

int32_t **DSP_VectorSumSquares32** (int32_t \* **indata** , int  **N** , int  **scale** );

**DSP_VectorVari16 Function**

Computes the variance of N elements of a Vector.

**Description**

Function DSP_VectorVari16:

int16_t DSP_VectorVari16(int16_t \*inVector, int N);

Calculates the variance on the first N elements of inVector and returns the 16-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -

var = sum[0..N]((x(i) - M(N))\^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int16_t)

N number of samples (int)

**Returns**

int16_t - Variance of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.

**Example**

int16_t vecStDevIn[32]={0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333};

_// .2, -.3, .125, .75, .2, .2, .3, .4_

int16_t Var16Out;

int Nvar = 4;

Var16Out= DSP_VectorVari16(vecStDevIn, Nvar); _// 16-bit variance function_

_// Var16Out = 0x1AD8 (= 0.20974)_

**C**

int16_t **DSP_VectorVari16** (int16_t \* **inVector** , int  **N** );

**DSP_VectorVariance Function**

Computes the variance of N elements of inVector.

**Description**

Function DSP_VectorVariance:

int32_t DSP_VectorVariance(int32_t \*inVector, int N);

Calculates the variance on the first N elements of inVector and returns the 32-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -

var = sum[0..N]((x(i) - M(N))\^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q31 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

int32_t - Variance of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.

**Example**

int varN = 8;

int32_t inVarVec[8] = {0xE6666667, 0x40000000,0x40000000,0x0CCCCCCC,

0x00000000,0x59999999,0x20000000,0xC0000000};

_// -0.2, 0.5, 0.5, 0.1, 0, 0.7, 0.25, -0.5_

int32_t outVar = 0;

outVar = DSP_VectorVariance(inVarVec, varN);

_// outVar == 0x1490D2A6, = 0.1606696_

**C**

int32_t **DSP_VectorVariance** (int32_t \* **inVector** , int  **N** );

**DSP_VectorZeroPad Function**

Fills an input vector with zeros.

**Description**

Function DSP_VectorZeroPad:

void DSP_VectorZeroPad(int32_t \*indata, int N);

Fills the first N values of an input vector indata with the value zero. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result is in Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32_t inBufTestA[8]={0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};

_// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6_

DSP_VectorZeroPad(inBufTestA, Num);

_// inBufTestA = {0x00000000, 0x00000000, 0x00000000, 0x00000000,_

_// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334};_

_// 0, 0, 0, 0, 0.2, 0.5, 1, -0.6_

**C**

**void**  **DSP_VectorZeroPad** (int32_t \* **indata** , int  **N** );

**mul16 Function**

multiply and shift integer

**C**

**static inline** int16_t **mul16** (int16_t **a** , int16_t **b** );

**mul16r Function**

multiply and shift Q15

**C**

**static inline** int16_t **mul16r** (int16_t **a** , int16_t **b** );

**mul32 Function**

multiply and shift Q31

**C**

**static inline** int32_t **mul32** (int32_t **a** , int32_t **b** );

**SAT16 Function**

saturate both positive and negative Q15

**C**

**static inline** int32_t **SAT16** (int32_t **x** );

**SAT16N Function**

saturate negative Q15

**C**

**static inline** int32_t **SAT16N** (int32_t **x** );

**SAT16P Function**

saturate positive Q15

**C**

**static inline** int32_t **SAT16P** (int32_t **x** );

## LibQ

### LibQ Fixed-Point Math Library

### Introduction

This topic describes the LibQ Fixed-Point Math Library.

### Description

The LibQ Fixed-Point Math Library is available for the PIC32MZ family of microcontrollers. This library was created from optimized assembly routines written specifically for devices with microAptiv™ core features.

The LibQ Fixed-Point Math Library simplifies writing fixed point algorithms, supporting Q15, Q31 and other 16-bit and 32-bit data formats. Using the simple, C callable functions contained in the library, fast fixed point mathematical operations can be easily executed. Fixed-point mathematical calculations may replace some functions implemented in the floating point library (math.h),

depending on performance and resolution requirements.

Functions included in the LibQ library include capabilities for trigonometric, power and logarithms, and data conversion. In many cases the functions are identical other than the precision of their operands and the corresponding value that they return.

These functions are implemented in efficient assembly, and generally tuned to optimize performance over code size. In some cases the library breaks out functions that enable one to be optimized for accuracy, while another version is optimized for speed.

These functions such as

_LIBQ_Q2_29_acos_Q31 and _LIBQ_Q2_29_acos_Q31_Fast are otherwise identical and can be used interchangeably. Each of these functions are typically used in computationally intensive real-time applications where execution time is a critical parameter.

**Using the Library**

This topic describes the basic architecture of the LibQ Fixed-Point Math Library and provides information and examples on its use.

**Description**

**Interface Header File:**  **libq.h**

The interface to the LibQ Fixed-Point Math Library is defined in the libq.h header file. Any C language source (.c) file that uses

the LibQ Fixed-Point Library should include libq.h.

Library File:

The LibQ Fixed-Point Math Library archive (.a) file is installed with MPLAB Harmony.

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries, as shown below

The project configuration should now contain the Math Libraries block.

Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.

### Library Overview

The LibQ Fixed-Point Math Library contains functions for manipulating Q15, Q31 and other intermediate integer representations of real numbers. The Library Interface section details the operation of the data formats and explains each function in detail.

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the DSP Fixed-Point Math Library.

**Library Interface Section Description**

**Divide Functions**

_Q16 fixed point divide function.

**Square Root Functions**

Square root of a positive _Q16 fixed point value function.

**Log Functions**

Log calculation functions.

**Power Functions**

Power calculation functions.

**Exponential Functions** Exponential calculation functions.

**Sine Functions**

Sine calculation functions.

**Cosine Functions**

Cosine calculation functions.

**Target Functions**

Target calculation functions.

**Arcsin Functions**

Arcsin calculation functions.

**Arccos Functions**

Arccos calculation functions.

**Arctan2 Functions**

Arctan2 calculation functions.

**Random Number Functions**

_Q15 and _Q31 pseudo-random value functions.

**Float Functions**

Float conversion functions.

**String Functions**


ASCII to _Q15 conversions.

Signed fixed-point types are defined as follows: Qn_m where:

• n is the number of data bits to the left of the radix point

• m is the number of data bits to the right of the radix point

• a signed bit is implied

For convenience, short names are also defined:

**Exact Name Number of Bits Required Short Name**

_Q0_15 16 _Q15

_Q15_16 16 _Q16

_Q0_31 32 _Q31

Qn_m numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. The range of the numerical value therefore is:

-2<sup>(n-1)</sup> to [2<sup>(n-1)</sup> - 2(<sup>-m</sup>)]; with a resolution of 2(<sup>-m</sup>).

A _Q16 format number (_Q15_16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259

(or 2<sup>-16</sup>). For example, a numerical representation of the number 3.14159 in _Q2_13 notation would be:

3.14159 \* 2<sup>13</sup> = 25735.9 =\\&gt; 0x6488

And converting from the _Q7_8 format with the value 0x1D89 would be:

0x1D89 / 2<sup>8</sup> = 7561 / 256 =\\&gt; 29.5316, accurate to 0.00391

Functions in the library are prefixed with the type of the return value. For example, _LIBQ_Q16Sqrt returns a _Q16 value equal to the square root of its argument. Argument types do not always match the return type. Refer to the function prototype for a specification of its arguments.

In cases where the return value is not a fixed-point type, the argument type is appended to the function name. For example, _LIBQ_ToFloatQ31 accepts a type _Q31 argument.

In some cases, both the return type and the argument type are specified within the function name. For example:

**Function Name Return Type Argument Type**

_LIBQ_Q15_sin_Q2_13 _Q15 Q2_13

_LIBQ_Q31_sin_Q2_29 _Q31 _Q2_29

### Library Interface

**Functions**

**Name Description**

_LIBQ_Q15_cos_Q2_13 Calculates the value of cosine(x).

_LIBQ_Q15_sin_Q2_13 Calculates the value of sine(x).

_LIBQ_Q15FromFloat Converts a float to a _Q15 value.

_LIBQ_Q15FromString ASCII to _Q15 conversion.

_LIBQ_Q15Rand Generate a _Q15 random number.

_LIBQ_Q16_tan_Q2_29 Calculates the value of tan(x).

_LIBQ_Q16Div _Q16 fixed point divide.

_LIBQ_Q16Exp Calculates the exponential function e\^x.

_LIBQ_Q16Power Calculates the value of x raised to the y power (x\^y).

_LIBQ_Q16Sqrt Square root of a positive _Q16 fixed point value.

_LIBQ_Q2_13_acos_Q15 Calculates the value of acos(x).

_LIBQ_Q2_13_asin_Q15 Calculates the asin value of asin(x).

_LIBQ_Q2_13_atan_Q7_8 Calculates the value of atan(x).

_LIBQ_Q2_13_atan2_Q7_8 Calculates the value of atan2(y, x).

_LIBQ_Q2_29_acos_Q31 Calculates the value of acos(x).

_LIBQ_Q2_29_acos_Q31_Fast Calculates the value of acos(x). This function executes faster than

_LIBQ_Q2_29_acos_Q31 but is less precise.

_LIBQ_Q2_29_asin_Q31 Calculates the value of asin(x).

_LIBQ_Q2_29_asin_Q31_Fast Calculates the value of asin(x). This function executes faster than the

_LIBQ_Q2_29_asin_Q31 function, but is less precise.

_LIBQ_Q2_29_atan_Q16 Calculates the value of atan(x).

_LIBQ_Q2_29_atan2_Q16 Calculates the value of atan2(y, x).

_LIBQ_Q3_12_log10_Q16 Calculates the value of Log10(x).

_LIBQ_Q31_cos_Q2_29 Calculates the value of cosine(x).

_LIBQ_Q31_sin_Q2_29 Calculates the value of sine(x).

_LIBQ_Q31FromFloat Converts a float to a _Q31 value.

_LIBQ_Q31Rand Generate a _Q31 random number.

_LIBQ_Q4_11_ln_Q16 Calculates the natural logarithm ln(x).

_LIBQ_Q5_10_log2_Q16 Calculates the value of log2(x).

_LIBQ_Q7_8_tan_Q2_13 Calculates the value of tan(x).

_LIBQ_ToFloatQ15 Converts a _Q15 value to a float.

_LIBQ_ToFloatQ31 Converts a _Q31 value to a float.

_LIBQ_ToStringQ15 _Q15 to ASCII conversion.

**Description**

_ **Functions** _

**_LIBQ_Q15_cos_Q2_13 Function**

Calculates the value of cosine(x).

**Description**

Function _LIBQ_Q15_cos_Q2_13:

_Q15 _LIBQ_Q15_cos_Q2_13 (_Q2_13 x);

Calculates the cosine(x), where x is of type _Q2_13 radians and the resulting value is of type _Q15.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The _Q2_13 input value from which to calculate cosine(x).

**Returns**

_LIBQ_Q15_cos_Q2_13 returns the _Q15 fixed point result from the calculation cosine(x).

**Remarks**

Execution Time (cycles): 102 cycles Program Memory 224 bytes

Error \\&lt;= 0.00003052 (accurate to least significant _Q15 bit)

**Example**

_Q15 resultCos;

resultCos = _LIBQ_Q15_cos_Q2_13 ((_Q2_13)0x2171); _// _LIBQ_Q15_cos_Q2_13(1.045044) = 0.501862_

_(0x403d)_

**C**

_Q15 **_LIBQ_Q15_cos_Q2_13** (_Q2_13 **x** );

**_LIBQ_Q15_sin_Q2_13 Function**

Calculates the value of sine(x).

**Description**

Function _LIBQ_Q15_sin_Q2_13:

_Q15 _LIBQ_Q15_sin_Q2_13 (_Q2_13 x);

Calculates the sine(x), where x is of type _Q2_13 radians and the resulting value is of type _Q15.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q2_13 input value from which to calculate sine(x).

**Returns**

_LIBQ_Q15_sin_Q2_13 returns the _Q15 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 100 typical (100 to 102) Program Memory 220 bytes

Error \\&lt;= 0.00003052 (accurate to least significant _Q15 bit)

**Example**

_Q15 resultSin;

resultSin = _LIBQ_Q15_sin_Q2_13 ((_Q2_13)0x4093); _// _LIBQ_Q15_sin_Q2_13(2.017944) = 0.901672_

_(0x736a)_

**C**

_Q15 **_LIBQ_Q15_sin_Q2_13** (_Q2_13 **x** );

**_LIBQ_Q15FromFloat Function**

Converts a float to a _Q15 value.

**Description**

Function _LIBQ_Q15FromFloat:

_Q15 _LIBQ_Q15FromFloat(float x);

Converts a floating point value to a _Q15 fixed point representation. The _Q15 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the _Q15 representation.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The float point value to convert to _Q15 fixed point

**Returns**

_LIBQ_Q15FromFloat returns the _Q15 fixed point value corresponding to the floating point (float) input value.

**Remarks**

The C library functions __gesf2, __lesf2, __addsf3, __mulsf3, and __fixsfsi are called by this routine and thus must be linked into

the executable image.

Execution Time (cycles): 213 typical (158 to 224) Program Memory 96 bytes

**Example**

_Q15 q15;

q15 = _LIBQ_Q15FromFloat(( **float** )0.5); _// q15 now equals (_Q15)0x4000_

q15 = _LIBQ_Q15FromFloat(( **float** )-1.0); _// q15 now equals (_Q15)0x8000_

q15 = _LIBQ_Q15FromFloat(( **float** )-0.233828); _// q15 now equals (_Q15)0xe212_

**C**

_Q15 **_LIBQ_Q15FromFloat** ( **float**  **x** );

**_LIBQ_Q15FromString Function**

ASCII to _Q15 conversion.

**Description**

Function _LIBQ_Q15FromString:

_Q15 _LIBQ_Q15FromString(char \*s);

Convert an ASCII string into a _Q15 fixed point value. The ASCII string must be in an -N.NNNNNN format. Leading spaces are ignored. The conversion stops at either the first non-conforming character in the string or the Null string terminator. There must be no spaces within the string value itself.

**Preconditions**

None.

**Parameters**

**Parameters Description**

s A pointer to the ASCII input string representing the _Q15 fixed point value.

**Returns**

_LIBQ_Q15FromString returns the _Q15 fixed point value represented by the input string.

**Remarks**

Execution Time (cycles): 296 typical (28 to 346) Program Memory 172 bytes

**Example**

_Q15 x;

x = _LIBQ_Q15FromString(&quot;0.125&quot;); _// x will equal 0.125 using_

_// an internal value of 0x1000_

x = _LIBQ_Q15FromString(&quot;-1.0&quot;); _// x will equal -1.0 using_

_// an internal value of 0x8000_

x = _LIBQ_Q15FromString(&quot;0.999969&quot;); _// x will equal 0.999969 using_

_// an internal value of 0x7FFF_

**C**

_Q15 **_LIBQ_Q15FromString** ( **char** \* **s** );

**_LIBQ_Q15Rand Function**

Generate a _Q15 random number.

**Description**

Function _LIBQ_Q15Rand:

_Q15 _LIBQ_Q15Rand (int64_t \*pSeed);

Generates a _Q15 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.

The function updates the \*pSeed value each time it is called. The updated \*pSeed value must be passed back to the function with each subsequent call.

Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.

**Preconditions**

None.

**Parameters**

**Parameters Description**

pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.

**Returns**

_LIBQ_Q15Rand returns a random _Q15 value. _LIBQ_Q15Rand also updates the int64_t \*pSeed value.

**Remarks**

Execution Time (cycles): 32 Program Memory 92 bytes

**Example**

_// Initialize seed to a constant or random value_

**static** int64_t randomSeed = 0xA71078BE72D4C1F1;

_Q15 randomValue;

randomValue = _LIBQ_Q15Rand(&amp;randomSeed);

...

randomValue = _LIBQ_Q15Rand(&amp;randomSeed);

**C**

_Q15 **_LIBQ_Q15Rand** (int64_t \* **pSeed** );

**_LIBQ_Q16_tan_Q2_29 Function**

Calculates the value of tan(x).

**Description**

Function _LIBQ_Q16_tan_Q2_29:

_Q16 _LIBQ_Q16_tan_Q2_29 (_Q2_29 x);

Calculates the tan(x), where x is of type _Q2_29 radians and the resulting value is of type _Q16.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The _Q2_29 input value from which to calculate tan(x).

**Returns**

_LIBQ_Q16_tan_Q2_29 returns the _Q16 fixed point result from the calculation tan(x). The resulting value is saturated.

**Remarks**

The functions _LIBQ_Q31_sin_Q2_29, _LIBQ_Q31_cos_Q2_29, and _LIBQ_Q16Div are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 703 typical (22 to 796) Program Memory 88 bytes

Error \\&lt;= 0.000015259 (accurate to least significant _Q16 bit for the input range -1.568 .. 1.568) Error rises from 0.0 to 0.065 for

the input range -1.568 .. -1.570765808 and 1.568 .. 1.570765808)

**Example**

_Q16 resultTan;

resultTan = _LIBQ_Q16_tan_Q2_29 ((_Q2_29)0x16720c36); _// _LIBQ_Q16_tan_Q2_29( 0.701421838) =_

_0.844726562 (0x0000d840)_

**C**

_Q16 **_LIBQ_Q16_tan_Q2_29** (_Q2_29 **x** );

**_LIBQ_Q16Div Function**

_Q16 fixed point divide.

**Description**

Function _LIBQ_Q16Div:

_Q16 _LIBQ_Q16Div (_Q16 dividend, _Q16 divisor);

Quotient (_Q16) = Dividend (_Q16) / Divisor (_Q16).

**Preconditions**

Divisor must not equal 0.

**Parameters**

**Parameters Description**

dividend The divide operation dividend (_Q16)

divisor The divide operation divisor (_Q16)

**Returns**

_Q16 quotient of the divide operation

**Remarks**

The _LIBQ_Q16Div operation saturates its result.

Execution Time (cycles): 143 typical (80 to 244) Program Memory 204 bytes

Error \\&lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)

**Example**

_Q16 quotient, dividend, divisor;

dividend = (_Q16)0x00010000; _// 1_

divisor = (_Q16)0x00008000; _// 0.5_

quotient = _LIBQ_Q16Div (dividend, divisor);

_// quotient now equals 2; i.e., (_Q16)0x00020000;_

**C**

_Q16 **_LIBQ_Q16Div** (_Q16 **dividend** , _Q16 **divisor** );

**_LIBQ_Q16Exp Function**

Calculates the exponential function e\^x.

**Description**

Function _LIBQ_Q16Exp:

_Q16 _LIBQ_Q16Exp(_Q16 x);

Calculates the exponential function e\^x. The calculation will saturate if the resulting value is outside the range of the _Q16 representation. For x \\&gt; 10.3972015380859375, the resulting value will be saturated to 0x7fffffff. For x \\&lt; -10.3972015380859375 the resulting value will be saturated to 0.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The exponent value

**Returns**

_LIBQ_Q16Exp returns the _Q16 fixed point result from the calculation e\^x.

**Remarks**

The function _LIBQ_Q16Div is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 170 typical (18 to 292) Program Memory 446 bytes

Error \\&lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)

**Example**

_Q16 expResult;

expResult = _LIBQ_Q16Exp((_Q16)0x00010000); _// _LIBQ_Q16Exp(1.000000) = 2.718277 (0x0002b7e1)_

**C**

_Q16 **_LIBQ_Q16Exp** (_Q16 **x** );

**_LIBQ_Q16Power Function**

Calculates the value of x raised to the y power (x\^y).

**Description**

Function _LIBQ_Q16Power:

_Q16 _LIBQ_Q16Power (_Q16 x, _Q16 y);

Calculates the x raised to the y power. Both x and y are of type _Q16. x must be positive. The calculation will saturate if the resulting value is outside the range of the _Q16 representation.

**Preconditions**

x must be positive.

**Parameters**

**Parameters Description**

x The _Q16 input value x from which to calculate x raised to the y.

y The _Q16 input value y from which to calculate x raised to the y.

**Returns**

_LIBQ_Q16Power returns the _Q16 fixed point result from the calculation x raised to the y.

**Remarks**

Execution Time (cycles): 882 typical (586 to 1042) Program Memory 1038 bytes

Error \\&lt;= 0.000015258789 (accurate to least significant _Q16 bit within the non-saturated range)

**Example**

_Q16 resultPower;

resultPower = _LIBQ_Q16Power ((_Q16)0x00020000, (_Q16)0xffff0000); _// _LIBQ_Q16Power(2.000000,_

_-1.000000) = 0.500000 (0x00008000)_

**C**

_Q16 **_LIBQ_Q16Power** (_Q16 **x** , _Q16 **y** );

**_LIBQ_Q16Sqrt Function**

Square root of a positive _Q16 fixed point value.

**Description**

Function _LIBQ_Q16Sqrt:

_Q16 _LIBQ_Q16Sqrt(_Q16 x);

Calculate the square root of a positive _Q16 fixed point value, and return the _Q16 result.

**Preconditions**

The input value must be positive.

**Parameters**

**Parameters Description**

x The _Q16 fixed point value input from which to find the square root.

**Returns**

_LIBQ_Q16Sqrt returns the _Q16 fixed point value which is the square root of the input parameter.

**Remarks**

Execution Time (cycles): 240 typical (104 to 258) Program Memory 152 bytes

Error \\&lt;= 0.000015258789 (accurate to least significant _Q16 bit)

**Example**

_Q16 squareRoot;

squareRoot = _LIBQ_Q16Sqrt((_Q16)0x01000000); _// The square root of 256.0 is 16.0 (0x00100000)_

squareRoot = _LIBQ_Q16Sqrt((_Q16)0x00004000); _// The square root of 0.25 is 0.5 (0x00008000)_

squareRoot = _LIBQ_Q16Sqrt((_Q16)0x5851f42d); _// The square root of 22609.953125 is 150.366074_

_(0x00965db7)_

**C**

_Q16 **_LIBQ_Q16Sqrt** (_Q16 **x** );

**_LIBQ_Q2_13_acos_Q15 Function**

Calculates the value of acos(x).

**Description**

Function _LIBQ_Q2_13_acos_Q15:

_Q2_13 _LIBQ_Q2_13_acos_Q15 (_Q15 x);

Calculates the acos(x), where x is of type _Q15 and the resulting value is of type _Q2_13. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q15 input value from which to calculate acos(x).

**Returns**

_LIBQ_Q2_13_acos_Q15 returns the _Q2_13 fixed point result from the calculation acos(x).

**Remarks**

The function _LIBQ_Q2_13_asin_Q15 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 588 typical (32 to 666) Program Memory 24 bytes

Error \\&lt;= 0.00012207 (accurate to least significant _Q2_13 bit)

A higher precision function with equivalent performance exists, see _LIBQ_Q2_29_acos_Q31_Fast

**Example**

_Q2_13 resultAcos;

resultAcos = _LIBQ_Q2_13_acos_Q15((_Q15)0x2993); _// _LIBQ_Q2_13_acos_Q15(0.324799) = 1.239990_

_(0x27ae)_

**C**

_Q2_13 **_LIBQ_Q2_13_acos_Q15** (_Q15 **x** );

**_LIBQ_Q2_13_asin_Q15 Function**

Calculates the asin value of asin(x).

**Description**

Function _LIBQ_Q2_13_asin_Q15:

_Q2_13 _LIBQ_Q2_13_asin_Q15 (_Q15 x);

Calculates asin(x), where x is of type _Q15 and the resulting value is of type _Q2_13. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q15 input value from which to calculate asin(x).

**Returns**

_LIBQ_Q2_13_asin_Q15 returns the _Q2_13 fixed point result from the calculation asin(x).

**Remarks**

The functions _LIBQ_Q16Sqrt and _LIBQ_Q16Div are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 578 typical (22 to 656) Program Memory 336 bytes

Error \\&lt;= 0.00012207 (accurate to least significant _Q2_13 bit)

A higher resolution version of this function exists with equivalent performance, see _LIBQ_Q2_29_asin_Q31_Fast

**Example**

_Q2_13 resultAsin;

resultAsin = _LIBQ_Q2_13_asin_Q15 ((_Q15)0x3231); _// _LIBQ_Q2_13_asin_Q15(0.392120) = 0.402954_

_(0x0ce5)_

**C**

_Q2_13 **_LIBQ_Q2_13_asin_Q15** (_Q15 **x** );

**_LIBQ_Q2_13_atan_Q7_8 Function**

Calculates the value of atan(x).

**Description**

Function _LIBQ_Q2_13_atan_Q7_8:

_Q2_13 _LIBQ_Q2_13_atan_Q7_8 (_Q7_8 x);

Calculates the atan(x), where x is of type _Q7_8 and the resulting value is of type _Q2_13. The output value will be radians in the

range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q7_8 input value from which to calculate atan(x).

**Returns**

_LIBQ_Q2_13_atan_Q7_8 returns the _Q2_13 fixed point result from the calculation atan(x).

**Remarks**

The function _LIBQ_Q2_13_atan2_Q7_8 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 240 typical (202 to 256) Program Memory 16 bytes

Error \\&lt;= 0.00012207 (accurate to least significant _Q2_13 bit)

**Example**

_Q2_13 resultAtan;

resultAtan = _LIBQ_Q2_13_atan_Q7_8 ((_Q7_8)0x0097); _// _LIBQ_Q2_13_atan_Q7_8(0.589844) =_

_0.532959 (0x110e)_

**C**

_Q2_13 **_LIBQ_Q2_13_atan_Q7_8** (_Q7_8 **x** );

**_LIBQ_Q2_13_atan2_Q7_8 Function**

Calculates the value of atan2(y, x).

**Description**

Function _LIBQ_Q2_13_atan2_Q7_8:

_Q2_13 _LIBQ_Q2_13_atan2_Q7_8 (_Q7_8 y, _Q7_8 x);

Calculates the atan2(y, x), where y and x are of type _Q7_8 and the resulting value is of type _Q2_13. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

y The _Q7_8 input value from which to calculate atan2(y, x).

x The _Q7_8 input value from which to calculate atan2(y, x).

**Returns**

_LIBQ_Q2_13_atan2_Q7_8 returns the _Q2_13 fixed point result from the calculation atan2(y, x).

**Remarks**

The function _LIBQ_Q16Div is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 220 typical (22 to 250) Program Memory 288 bytes

Error \\&lt;= 0.00012207 (accurate to least significant _Q2_13 bit)

**Example**

_Q2_13 resultAtan2;

resultAtan2 = _LIBQ_Q2_13_atan2_Q7_8 ((_Q7_8)0x589d, (_Q7_8)0xf878); _//_

__LIBQ_Q2_13_atan2_Q7_8(88.613281, -7.531250) = 1.655518 (0x34fa)_

**C**

_Q2_13 **_LIBQ_Q2_13_atan2_Q7_8** (_Q7_8 **y** , _Q7_8 **x** );

**_LIBQ_Q2_29_acos_Q31 Function**

Calculates the value of acos(x).

**Description**

Function _LIBQ_Q2_29_acos_Q31:

_Q2_29 _LIBQ_Q2_29_acos_Q31 (_Q31 x);

Calculates the acos(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q31 input value from which to calculate acos(x).

**Returns**

_LIBQ_Q2_29_acos_Q31 returns the _Q2_29 fixed point result from the calculation acos(x).

**Remarks**

The functions _LIBQ_Q2_29_asin_Q31_Fast and _LIBQ_Q31_cos_Q2_29 are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 3370 typical (70 to 4824) Program Memory 142 bytes

Error \\&lt;= 0.0000000019 (accurate to least significant _Q2_29 bit for the range -0.9993..0.9993) Error \\&lt;= 0.0000000355 (accurate to 5th least significant _Q2_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)

A similar function with higher performance and reduced precision exists, see _LIBQ_Q2_29_acos_Q31_Fast

**Example**

_Q2_29 resultAcos;

resultAcos = _LIBQ_Q2_29_acos_Q31 ((_Q31)0xee63708c); _// _LIBQ_Q2_29_acos_Q31(-0.1375903431)_

_= 1.7088244837 (0x36aeb0af)_

**C**

_Q2_29 **_LIBQ_Q2_29_acos_Q31** (_Q31 **x** );

**_LIBQ_Q2_29_acos_Q31_Fast Function**

Calculates the value of acos(x). This function executes faster than _LIBQ_Q2_29_acos_Q31 but is less precise.

**Description**

Function _LIBQ_Q2_29_acos_Q31_Fast:

_Q2_29 _LIBQ_Q2_29_acos_Q31_Fast (_Q31 x);

Calculates the acos(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q31 input value from which to calculate acos(x).

**Returns**

_LIBQ_Q2_29_acos_Q31_Fast returns the _Q2_29 fixed point result from the calculation acos(x).

**Remarks**

The function _LIBQ_Q2_29_asin_Q31_Fast is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 517 typical (32 to 1310) Program Memory 28 bytes

Error \\&lt;= 0.000000911 (accurate to 9 least significant _Q2_29 bits)

A higher precision function with reduced performance exists, see _LIBQ_Q2_29_acos_Q31

**Example**

_Q2_29 resultAcos;

resultAcos = _LIBQ_Q2_29_acos_Q31_Fast ((_Q31)0xee63708c); _//_

__LIBQ_Q2_29_acos_Q31_Fast(-0.1375903431) = 1.7088244837 (0x36aeb0af)_

**C**

_Q2_29 **_LIBQ_Q2_29_acos_Q31_Fast** (_Q31 **x** );

**_LIBQ_Q2_29_asin_Q31 Function**

Calculates the value of asin(x).

**Description**

Function _LIBQ_Q2_29_asin_Q31:

_Q2_29 _LIBQ_Q2_29_asin_Q31 (_Q31 x);

Calculates the asin(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be in radians the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q31 input value from which to calculate asin(x).

**Returns**

_LIBQ_Q2_29_asin_Q31 returns the _Q2_29 fixed point result from the calculation asin(x).

**Remarks**

The functions _LIBQ_Q2_29_asin_Q31_Fast and_LIBQ_Q31_sin_Q2_29 are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 2525 typical (286 to 4330) Program Memory 138 bytes

Error \\&lt;= 0.0000000019 (accurate to least significant _Q2_29 bit for the range -0.9993..0.9993) Error \\&lt;= 0.0000000346 (accurate to 5th least significant _Q2_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)

A faster version of this function exists with modestly reduced accuracy, see _LIBQ_Q2_29_asin_Q31_Fast

**Example**

_Q2_29 resultAsin;

resultAsin = _LIBQ_Q2_29_asin_Q31 ((_Q31)0x7fe50658); _// _LIBQ_Q2_29_asin_Q31( 0.9991767816)_

_= 1.5302172359 (0x30f78a23)_

**C**

_Q2_29 **_LIBQ_Q2_29_asin_Q31** (_Q31 **x** );

**_LIBQ_Q2_29_asin_Q31_Fast Function**

Calculates the value of asin(x). This function executes faster than the _LIBQ_Q2_29_asin_Q31 function, but is less precise.

**Description**

Function _LIBQ_Q2_29_asin_Q31_Fast:

_Q2_29 _LIBQ_Q2_29_asin_Q31_Fast (_Q31 x);

Calculates the asin(x), where x is of type _Q31 and the resulting value is of type _Q2_29. The output value will be in radians the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q31 input value from which to calculate asin(x).

**Returns**

_LIBQ_Q2_29_asin_Q31_Fast returns the _Q2_29 fixed point result from the calculation asin(x).

**Remarks**

Execution Time (cycles): 507 typical (22 to 1300) Program Memory 638 bytes

Error \\&lt;= 0.000000911 (accurate to 9 least significant _Q2_29 bits)

A higher resolution version of this function exists with reduced performance, see _LIBQ_Q2_29_asin_Q31

**Example**

_Q2_29 resultAsin;

resultAsin = _LIBQ_Q2_29_asin_Q31_Fast ((_Q31)0x7fe50658); _// _LIBQ_Q2_29_asin_Q31_Fast(_

_0.9991767816) = 1.5302172359 (0x30f78a23)_

**C**

_Q2_29 **_LIBQ_Q2_29_asin_Q31_Fast** (_Q31 **x** );

**_LIBQ_Q2_29_atan_Q16 Function**

Calculates the value of atan(x).

**Description**

Function _LIBQ_Q2_29_atan_Q16:

_Q2_29 _LIBQ_Q2_29_atan_Q16 (_Q16 x);

Calculates the atan(x), where x is of type _Q16 and the resulting value is of type _Q2_29. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q16 input value from which to calculate atan(x).

**Returns**

_LIBQ_Q2_29_atan_Q16 returns the _Q2_29 fixed point result from the calculation atan(x).

**Remarks**

The function _LIBQ_Q2_29_atan2_Q16 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 354 typical (178 to 360) Program Memory 16 bytes

Error \\&lt;= 0.000000003 (accurate within one least significant _Q2_29 bit)

**Example**

_Q2_29 resultAtan;

resultAtan = _LIBQ_Q2_29_atan_Q16 ((_Q16)0x00098b31); _// _LIBQ_Q2_29_atan_Q16(9.543716) =_

_1.466396 (0x2eecb7ee)_

**C**

_Q2_29 **_LIBQ_Q2_29_atan_Q16** (_Q16 **x** );

**_LIBQ_Q2_29_atan2_Q16 Function**

Calculates the value of atan2(y, x).

**Description**

Function _LIBQ_Q2_29_atan2_Q16:

_Q2_29 _LIBQ_Q2_29_atan2_Q16 (_Q16 y, _Q16 x);

Calculates the atan(y, x), where y and x are of type _Q16 and the resulting value is of type _Q2_29. The output value will be radians in the range pi \\&gt;= result \\&gt;= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

y The _Q16 input value from which to calculate atan2(y, x).

x The _Q16 input value from which to calculate atan2(y, x).

**Returns**

_LIBQ_Q2_29_atan2_Q16 returns the _Q2_29 fixed point result from the calculation atan2(y, x).

**Remarks**

The C function __divdi3 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 348 typical (20 to 376) Program Memory 464 bytes

Error \\&lt;= 0.000000003 (accurate within one least significant _Q2_29 bit)

**Example**

_Q2_29 resultAtan2;

resultAtan2 = _LIBQ_Q2_29_atan2_Q16 ((_Q16)0xf6276270, x(_Q16)0x34b4b4c0); _//_

__LIBQ_Q2_29_atan2_Q16(-2520.615479, 13492.706055) = -0.184684 (0xfa1710c7)_

**C**

_Q2_29 **_LIBQ_Q2_29_atan2_Q16** (_Q16 **y** , _Q16 **x** );

**_LIBQ_Q3_12_log10_Q16 Function**

Calculates the value of Log10(x).

**Description**

Function _LIBQ_Q3_12_log10_Q16:

_Q3_12 _LIBQ_Q3_12_log10_Q16 (_Q16 x);

Calculates the log10(x), where log10(x) = ln(x) \* log10(e). x is of type _Q16 and must be positive. The resulting value is of type _Q3_12.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate log10(x).

**Returns**

_LIBQ_Q3_12_log10_Q16 returns the _Q3_12 fixed point result from the calculation log10(x).

**Remarks**

Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes

Error \\&lt;= 0.000244140625 (accurate to least significant _Q3_12 bit)

**Example**

_Q3_12 resultLog10;

resultLog10 = _LIBQ_Q3_12_log10_Q16 ((_Q16)0x12ed7d91); _// _LIBQ_Q3_12_log10_Q16(4845.490494)_

_= 3.685303 (0x3af7)_

**C**

_Q3_12 **_LIBQ_Q3_12_log10_Q16** (_Q16 **x** );

**_LIBQ_Q31_cos_Q2_29 Function**

Calculates the value of cosine(x).

**Description**

Function _LIBQ_Q31_cos_Q2_29:

_Q31 _LIBQ_Q31_cos_Q2_29 (_Q2_29 x);

Calculates the cosine(x), where x is of type _Q2_29 radians and the resulting value is of type _Q31.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q2_29 input value from which to calculate cosine(x).

**Returns**

_LIBQ_Q31_cos_Q2_29 returns the _Q31 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 265 typical (22 to 288) Program Memory 746 bytes

Error \\&lt;= 0.00000000047 (accurate to least significant _Q31 bit)

**Example**

_Q31 resultCos;

resultCos = _LIBQ_Q31_cos_Q2_29 ((_Q2_29)0x07e2e1c2); _// _LIBQ_Q31_cos_Q2_29( 0.246445540) =_

_0.969785686 (0x7c21eff7)_

**C**

_Q31 **_LIBQ_Q31_cos_Q2_29** (_Q2_29 **x** );

**_LIBQ_Q31_sin_Q2_29 Function**

Calculates the value of sine(x).

**Description**

Function _LIBQ_Q31_sin_Q2_29:

_Q31 _LIBQ_Q31_sin_Q2_29 (_Q2_29 x);

Calculates the sine(x), where x is of type _Q2_29 radians and the resulting value is of type _Q31.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q2_29 input value from which to calculate sine(x).

**Returns**

_LIBQ_Q31_sin_Q2_29 returns the _Q31 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 246 typical (244 to 266) Program Memory 598 bytes

Error \\&lt;= 0.00000000047 (accurate to least significant _Q31 bit)

**Example**

_Q31 resultSin;

resultSin = _LIBQ_Q31_sin_Q2_29 ((_Q2_29)0x5a637cfe); _// _LIBQ_Q31_sin_Q2_29( 2.824644562) =_

_0.311668121 (0x27e4bdb1)_

**C**

_Q31 **_LIBQ_Q31_sin_Q2_29** (_Q2_29 **x** );

**_LIBQ_Q31FromFloat Function**

Converts a float to a _Q31 value.

**Description**

Function _LIBQ_Q31FromFloat:

_Q31 _LIBQ_Q31FromFloat(float x);

Converts a floating point value to a _Q31 fixed point representation. The _Q31 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the _Q31 representation.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The floating point value to convert to _Q31 fixed point.

**Returns**

_LIBQ_Q31FromFloat returns the _Q31 fixed point value corresponding to the floating point (float) input value.

**Remarks**

The C library functions __gesf2, __lesf2, __addsf3, __mulsf3, and __fixsfsi are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 210 typical (158 to 214) Program Memory 100 bytes

**Example**

_Q31 q31;

q31 = _LIBQ_Q31FromFloat(( **float** )0.000008); _// q31 now equals (_Q31)0x00004000_

q31 = _LIBQ_Q31FromFloat(( **float** )-1.0); _// q31 now equals (_Q31)0x80000000_

q31 = _LIBQ_Q31FromFloat(( **float** )0.690001); _// q31 now equals (_Q31)0x5851f400_

**C**

_Q31 **_LIBQ_Q31FromFloat** ( **float**  **x** );

**_LIBQ_Q31Rand Function**

Generate a _Q31 random number.

**Description**

Function _LIBQ_Q31Rand:

_Q31 _LIBQ_Q31Rand (int64_t \*pSeed);

Generates a _Q31 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.

The function updates the \*pSeed value each time it is called. The updated \*pSeed value must be passed back to the function with each subsequent call.

Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.

**Preconditions**

None.

**Parameters**

**Parameters Description**

pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.

**Returns**

_LIBQ_Q31Rand returns a pseudo-random _Q31 value. _LIBQ_Q31Rand also updates the int64_t \*pSeed value.

**Remarks**

Execution Time (cycles): 32 Program Memory 88 bytes

**Example**

_// Initialize seed to a constant or random value_

**static** int64_t randomSeed = 0x7F18BA710E72D4C1;

_Q31 randomValue;

randomValue = _LIBQ_Q31Rand(&amp;randomSeed);

...

randomValue = _LIBQ_Q31Rand(&amp;randomSeed);

**C**

_Q31 **_LIBQ_Q31Rand** (int64_t \* **pSeed** );

**_LIBQ_Q4_11_ln_Q16 Function**

Calculates the natural logarithm ln(x).

**Description**

Function _LIBQ_Q4_11_ln_Q16:

_Q4_11 _LIBQ_Q4_11_ln_Q16 (_Q16 x);

Calculates the natural logarithm ln(x). x is of type _Q16 and must be positive. The resulting value is of type _Q4_11.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate ln(x).

**Returns**

_LIBQ_Q4_11_ln_Q16 returns the _Q4_11 fixed point result from the calculation ln(x).

**Remarks**

Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes

Error \\&lt;= 0.00048828 (accurate to least significant _Q4_11 bit)

**Example**

_Q4_11 resultLN;

resultLN = _LIBQ_Q4_11_ln_Q16 ((_Q16)0x00004000); _// _LIBQ_Q4_11_LN_Q16(0.250000) = -1.386230_

_(0xf4e9)_

**C**

_Q4_11 **_LIBQ_Q4_11_ln_Q16** (_Q16 **x** );

**_LIBQ_Q5_10_log2_Q16 Function**

Calculates the value of log2(x).

**Description**

Function _LIBQ_Q5_10_log2_Q16:

_Q5_10 _LIBQ_Q5_10_log2_Q16 (_Q16 x);

Calculates the log2(x), where log2(x) = ln(x) \* log2(e). x is of type _Q16 and must be positive. The resulting value is of type _Q5_10.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate log2(x).

**Returns**

_LIBQ_Q5_10_log2_Q16 returns the _Q5_10 fixed point result from the calculation log2(x).

**Remarks**

Execution Time (cycles): 227 typical (14 to 268) Program Memory 164 bytes

Error \\&lt;= 0.0009765625 (accurate to least significant _Q5_10 bit)

**Example**

_Q5_10 resultLog2;

resultLog2 = _LIBQ_Q5_10_log2_Q16 ((_Q16)0x40000000); _// _LIBQ_Q5_10_log2_Q16(16384.000000) =_

_14.000000 (0x3800)_

**C**

_Q5_10 **_LIBQ_Q5_10_log2_Q16** (_Q16 **x** );

**_LIBQ_Q7_8_tan_Q2_13 Function**

Calculates the value of tan(x).

**Description**

Function _LIBQ_Q7_8_tan_Q2_13:

_Q7_8 _LIBQ_Q7_8_tan_Q2_13 (_Q2_13 x);

Calculates the tan(x), where x is of type _Q2_13 radians and the resulting value is of type _Q7_8.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The _Q2_13 input value from which to calculate tan(x).

**Returns**

_LIBQ_Q7_8_tan_Q2_13 returns the _Q7_8 fixed point result from the calculation tan(x).

**Remarks**

Execution Time (cycles): 288 typical (18 to 346) Program Memory 980 bytes

Error \\&lt;= 0.00390625 (accurate to least significant _Q7_8 bit)

**Example**

_Q7_8 resultTan;

resultTan = _LIBQ_Q7_8_tan_Q2_13 ((_Q2_13)0x2e20); _// _LIBQ_Q7_8_tan_Q2_13(1.441406) =_

_7.683594 (0x07af)_

**C**

_Q7_8 **_LIBQ_Q7_8_tan_Q2_13** (_Q2_13 **x** );

**_LIBQ_ToFloatQ15 Function**

Converts a _Q15 value to a float.

**Description**

Function _LIBQ_ToFloatQ15:

float _LIBQ_ToFloatQ15(_Q15 x);

Converts a _Q15 fixed point value to a floating point representation. The floating point value is returned by the function.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q15 fixed point value to convert to float

**Returns**

_LIBQ_ToFloatQ15 returns the floating point (float) value corresponding to the _Q15 input value.

**Remarks**

The C library functions __floatsisf and __divsf3 are called by this routine and thus must be linked in to the executable image.

Execution Time (cycles): 158 typical (54 to 176) Program Memory 28 bytes

**Example**

**float** f;

f = _LIBQ_ToFloatQ15((_Q15)0x4000); _// f now equals 0.5_

f = _LIBQ_ToFloatQ15((_Q15)0x8000); _// f now equals -1.0_

f = _LIBQ_ToFloatQ15((_Q15)0xb7ff); _// f now equals -0.562531_

**C**

**float**  **_LIBQ_ToFloatQ15** (_Q15 **x** );

**_LIBQ_ToFloatQ31 Function**

Converts a _Q31 value to a float.

**Description**

Function _LIBQ_ToFloatQ31:

float _LIBQ_ToFloatQ31(_Q31 x);

Converts a _Q31 fixed point value to a floating point representation. The floating point value is returned by the function.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The _Q31 fixed point value to convert to float

**Returns**

_LIBQ_ToFloatQ31 returns the floating point (float) value corresponding to the _Q31 input value.

**Remarks**

The C library functions __floatsisf and __divsf3 are called by this routine and thus must be linked in to the executable image.

Execution Time (cycles): 163 typical (54 to 176) Program Memory 28 bytes

**Example**

**float** f;

f = _LIBQ_ToFloatQ31((_Q31)0x00004000); _// f now equals 0.000008_

f = _LIBQ_ToFloatQ31((_Q31)0x80000000); _// f now equals -1.0_

f = _LIBQ_ToFloatQ31((_Q31)0x5851f42d); _// f now equals 0.690001_

**C**

**float**  **_LIBQ_ToFloatQ31** (_Q31 **x** );

**_LIBQ_ToStringQ15 Function**

_Q15 to ASCII conversion.

**Description**

Function _LIBQ_ToStringQ15:

void _LIBQ_ToStringQ15(_Q15 x, char \*s);

Convert a _Q15 fixed point value to an ASCII string representation in a -N.NNNNNN format.

**Preconditions**

The character string &quot;s&quot; must be at least 10 characters long, including the Null string terminator.

**Parameters**

**Parameters Description**

x The fixed point value to be converted into an ASCII string (_Q15)

s A pointer to the output string of at least 10 characters

**Returns**

An ASCII string that represents the _Q15 fixed point value in -N.NNNNNN format. The output string will be terminated by a Null

(0x00) character.

**Remarks**

Execution Time (cycles): 118 typical (28 to 132) Program Memory 200 bytes

**Example**

**char** s[10];

_LIBQ_ToStringQ15((_Q15)0x1000, s); _// s will equal &quot;0.125000&quot;_

_LIBQ_ToStringQ15((_Q15)0x8000, s); _// s will equal &quot;-1.000000&quot;_

_LIBQ_ToStringQ15((_Q15)0x7FFF, s); _// s will equal &quot;0.999969&quot;_

**C**

**void**  **_LIBQ_ToStringQ15** (_Q15 **x** , **char** \* **s** );

## LibQ_c

### LibQ Fixed-Point &quot;C&quot; Math Library

### Introduction

This topic describes the LibQ Fixed-Point &#39;C&#39; Math Library.

### Description

The LibQ Fixed-Point &#39;C&#39; Math Library is written in C and is available for all processors supported by Harmony 3.

The libq_c Fixed-Point Math Library provides fixed-point math functions written in C for portability between core processors. The

library uses signed fixed point types (fractional Q types specified by Qn.m) which are specifed as follows in the library names:

Qndm where:

• n is the number of data bits to the left of the radix point

• m is the number of data bits to the right of the radix point

• a signed bit is implied (unless stated otherwise)

For convenience, short names are also defined for arbitrary scaled fractional types:

• q15 is signed fractional 16 bit value

• q31 is signed fractional 32 bit value

• i16 is signed integer, i.e. Q16d0

In addition, A pseudo floating point 32 bit format (FxQFloat32) is defined that consists of 16 mantissa and a 16 bit exponent (base

2). Functions in the library are prefixed with the type of the return value and followed by argument types (in order):

libq_\\&lt;result\\&gt;_\\&lt;name\\&gt;_\\&lt;args\\&gt;

For example, libq_q1d15_Sin_q10d6 returns a Q1.15 value equal to the to the sine of an angle specified as a Q10.6 value (in degrees between 0 and 360).

For arbitrary scaled types (q15, q16, q31, and q32) the scaling of the result will depend on the function and the scaling of the

arguments. For instance, libq_q15_Add_q15_q15(a,b) will return a scaled value type that is the two input types (which must have

equivalent scaled value type).

**Using the Library**

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq_c, libq/dsp libraries, as shown below

The project configuration should now contain the Math Libraries block.

The configuration window (when the block is selected) looks like the following:

**Remarks**

The libq_c functions do not correspond to the libq fixed-point library optimized for the microaptive core processor and written in

asm.

### Library Overview

**Table of LIBQ_C math functions:**

Sine: libq_q1d15_Sin_q10d6 libq_q20d12_Sin_q20d12 Abs: libq_q15_Abs_q15 libq_q31_Abs_q31

Negate: libq_q15_Negate_q15 libq_q31_Negate_q31 Round: libq_q15_RoundL_q31

Deposit: libq_q31_DepositH_q15 libq_q31_DepositL_q15 Extract: libq_q15_ExtractH_q31 libq_q15_ExtractL_q31 Add:

libq_q15_Add_q15_q15 libq_q31_Add_q31_q31 Subtract: libq_q15_Sub_q15_q15 libq_q31_Sub_q31_q31

Shift(Scale): libq_q15_ShiftLeft_q15_q15 libq_q31_ShiftLeft_q31_q15 libq_q15_ShiftRight_q15_q15

libq_q31_ShiftRight_q31_q15 libq_q15_ShiftRightRound_q15_q15 libq_q31_ShiftRightRound_q31_q15

Multiply: libq_q15_Mult_q15_q15 libq_q15_MultipyR2_q15_q15 libq_q31_Multi_q15_q31 Divide:

libq_q15_DivisionWithSaturation_q15_q15

Multiply-Accumulate: libq_q31_Mac_q31_q15_q15 libq_q15_MacR_q31_q15_q15 Multiply-Subtract: libq_q31_Msu_q31_q15_q15

libq_q15_MsuR_q31_q15_q15 Exponential-Averaging: libq_q15_ExpAvg_q15_q15_q1d15

Table of LIBQ_C conversion functions: Normalize Q value: Fx16Norm Fx32Norm

Float-to-Q value: Fl2Fract16 Fl2Fract32 Fl2FxPnt16 Fl2FxPnt32 Fl2FxPnt Float-To-Integer: Fl2Int16 Fl2Int32

### Library Interface

**Functions**

**Name Description**

CosInDegs Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in

degrees (Q8.6 fixed point)

Fract_10toX_Q15bfp Calculates pow(2,x) with fixed point math.

Fract_10toX_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.

Fract_10toX_Q15d16 Calculates pow(2,x) with fixed point math.

Fract_2toMinusX_Q15 Calculates pow(2,-x) with fixed point math.

Fract_2toX_Q15bfp Calculates pow(2,x) with fixed point math.

Fract_2toX_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.

Fract_2toX_Q15d16 Calculates pow(2,x) with fixed point math.

Fract_Convert_Q15bfpToQ15d16 Convert Q15 block floating point to Q15.16 fixed point.

Fract_Convert_Q15bfpToQ31 Convert Q15 block floating point to Q31 fixed point.

Fract_Convert_Q15d16ToQ15bfp Convert from Q15.16 fixed point to Q15 Block Floating Point

Fract_Convert_Q15ToQ15bfp Convert from Q15 fixed point to Q15 Block Floating Point

Fract_InversePower Computes pow(nBase,-nExponent).

Fract_log10fix Calculates fixed point base 10 logarithm using number of fractional bits

specified by precision argument. Log base 10 is calculated using the log

base 2 function Fract_log2fix.

Fract_log2fix Calculates fixed point base 2 logarithm using number of fractional bits

specified by precision argument.

Fract_Power Computes pow(nBase,nExponent) using for loop.

Fract_sqrtQ15 Fixed point Q15 squareroot.

Fract_XminusY_Q15bfp Subtract two Q15 block floating point numbers.

Fract_XoverY_Q15bfp Division x/y as Q15 block floating point.

Fract_XoverY_Q15bfpFromQ15 Calculate ratio of X/Y as Q15&#39;s but return result as Q15 block floating

point.

Fract_XoverY_Q15d16FromQ15 Calculates ratio X/Y for two Q15 fixed points

Fract_XplusY_Q15bfp Add two Q15 block floating point numbers.

Fract_XtimesY_Q15 Calculates product of X\*Y for Q15 fixed point

Fract_XtimesY_Q15bfp Multiply X times Y, for Q15 block floating point arguments.

Fract_XtimesY_Q15d16 Calculates product of X\*Y for Q15.16 fixed point

Fract_XtimesY_Q31 Calculates product of X\*Y for Q31 fixed point

Fx16Norm Normalize the 16-bit fractional value.

Fx32Norm Normalize the 32-bit number.

libq_q15_Abs_q15 Saturated Absolute value.

libq_q15_Add_q15_q15 Add two 16-bit 2s-complement fractional values.

libq_q15_DivisionWithSaturation_q15_q15 Fractional division with saturation.

libq_q15_ExpAvg_q15_q15_q1d15 Exponential averaging

libq_q15_ExtractH_q31 Extracts upper 16 bits of input 32-bit fractional value.

libq_q15_ExtractL_q31 Extracts lower 16-bits of input 32-bit fractional value.

Descriptionf Extracts lower 16-bits of input 32-bit fractional value and

returns them as 16-bit fractional value. This is a bit-for-bit extraction of

the bottom 16-bits of the 32-bit input. This function relates to the ETSI

extract_l function.

libq_q15_MacR_q31_q15_q15 Multiply accumulate with rounding.

libq_q15_MsuR_q31_q15_q15 Multiply-Subtraction with rounding

libq_q15_MultiplyR2_q15_q15 fractional multiplication of two 16-bit fractional values giving a 16 bit

rounded result.

libq_q15_Negate_q15 Negate 16-bit 2s-complement fractional value with saturation.

libq_q15_RoundL_q31 Rounds the lower 16-bits of the 32-bit fractional input.

libq_q15_ShiftLeft_q15_i16 &#39;Arithmetic&#39; Shift of the 16-bit input argument.

libq_q15_ShiftRight_q15_i16 &#39;Arithmetic&#39; RIGHT Shift on a 16-bit value.

libq_q15_ShiftRightR_q15_i16 Performs an &#39;Arithmetic&#39; RIGHT Shift on a 16-bit input.

libq_q15_Sub_q15_q15 Subtract two 16-bit 2s-complement fractional values

libq_q1d15_Sin_q10d6 Approximates the sine of an angle.

libq_q20d12_Sin_q20d12 3rd order Polynomial apprx. of a sine function

libq_q31_Abs_q31 Saturated Absolute value.

libq_q31_Add_q31_q31 Add two 32-bit 2s-complement fractional values.

libq_q31_DepositH_q15 Place 16 bits in the upper half of 32 bit word.

libq_q31_DepositL_q15 Place 16 bits in the lower half of 32 bit word.

libq_q31_Mac_q31_q15_q15 Multiply-Accumulate function WITH saturation

libq_q31_Msu_q31_q15_q15 L_msu(a,b,c)

libq_q31_Mult2_q15_q15 fractional multiplication of two 16-bit fractional values.

libq_q31_Multi_q15_q31 Implement 16 bit by 32 bit multiply.

libq_q31_Negate_q31 Negate 32-bit 2s-complement fractional value with saturation.

libq_q31_ShiftLeft_q31_i16 &#39;Arithmetic&#39; Shift of the 32-bit value.

libq_q31_ShiftRight_q31_i16 &#39;Arithmetic&#39; RIGHT Shift on a 32-bit value.

libq_q31_ShiftRightR_q31_i16 &#39;Arithmetic&#39; RIGHT Shift on a 32-bit value

libq_q31_Sub_q31_q31 Subtract two 32-bit 2s-complement fractional values

LUTwInterpolation_Q15 Calculates calculates y = f(x) based on a lookup table with linear

interpolation between table entries.

SinInDegs Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in

degrees (Q8.6 fixed point)

**Description**

_ **Functions** _

**CosInDegs Function**

fract_q0d15_t CosInDegs( fract_q9d6_t theta );

**Summary**

Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Description**

Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Preconditions**

None

**Parameters**

**Parameters Description**

theta Q9.6 fixed point angle

**Returns**

cos(theta) in Q0.15 fixed point

**Remarks**

CosInDegs uses SinInDegs.

**Example**

int32_t nTests = 400;

**float** theta;

**float** delta_theta = 360.0/(nTests-1);

**float** theta0 = 0;

int32_t i;

int32_t x;

for ( i = 0; i \\&lt; nTests; i++ )

{

theta = theta0 + i\*delta_theta;

x = theta\*(32768/512); _//Q9.6_

printf(&quot;%d, %d rn&quot;,( int )x,CosInDegs(x));

}

**C**

fract_q0d15_t **CosInDegs** (fract_q9d6_t **theta** );

**Fract_10toX_Q15bfp Function**

fract_q15bfp_t Fract_10toX_Q15bfp( fract_q15bfp_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15 block floating point, returning the result in the same format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15 block floating point format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

Fract_10toX(x) is basically Fract_2toX( log2(10)\*x ).

**Example**

fract_q15bfp_t X,Y;

X.m = 0x4000; _// 1/2_

X.e = 0;

Y = Fract_10toX_Q15bfp(X);

_// Y.m = 0x6532 = 25906_

_// Y.e = 2_

_// Y = ( 25906 / 32768 )\\&lt;\\&lt;2 = 3.162353 (vs. 3.162277) , rel error = 1/41688_

X.m = 0x6488; _// (3.14159/4)_

X.e = 2;

Y = Fract_10toX_Q15bfp(X);

_// Y.m = 0x5697 = 22167 / 32768 = 0.676483_

_// Y.e = 0x000B = 11_

_// Y = (22167 / 32768)\\&lt;\\&lt;11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023_

**C**

fract_q15bfp_t **Fract_10toX_Q15bfp** (fract_q15bfp_t **x** );

**Fract_10toX_Q15bfpFromQ15d16 Function**

fract_q15bfp_t Fract_10toX_Q15bfpFromQ15d16( fract_q15d16_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent as Q15.16

**Returns**

pow(2,x) as Q15 block floating point

**Remarks**

Fract_10toX(x) is basically Fract_2toX( log2(10)\*x ).

**Example**

fract_q15bfp_t Y;

x = 0x00008000; _// 0.5_

Y = Fract_10toX_Q15bfpFromQ15d16(x);

_// Y.m = 0x6532 = 25906_

_// Y.e = 2_

_// Y = ( 25906 / 32768 )\\&lt;\\&lt;2 = 3.162353 (vs. 3.162277) , rel error = 1/41688_

x = 0x0003243F; _// 205,887 / 65536 = 3.141586 (vs. 3.14159)_

Y = Fract_10toX_Q15bfpFromQ15d16(x);

_// Y.m = 0x5696 = 22167 / 32768 = 0.676483_

_// Y.e = 0x000B = 11_

_// Y = (22167 / 32768)\\&lt;\\&lt;11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023_

**C**

fract_q15bfp_t **Fract_10toX_Q15bfpFromQ15d16** (fract_q15d16_t **x** );

**Fract_10toX_Q15d16 Function**

fract_q15d16_t Fract_10toX_Q15d16( fract_q15d16_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15.16.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent as Q15.16

**Returns**

pow(2,x) as Q15.16

**Remarks**

Fract_10toX(x) is basically Fract_2toX( log2(10)\*x ).

**Example**

fract_q15d16_t x,y;

x = 0x00008000; _// 0.5_

y = Fract_10toX_Q15d16(x);

_// y = 0x0003 2990 = 207,248/65536 = 3.162353 (vs. 3.162277) , rel error = 1/41688_

x = 0x0003243F; _// 205,887 / 65536 = 3.141586 (vs. 3.14159)_

y = Fract_10toX_Q15d16(x);

_// y = 0x0569 6000 = 90,791,936/65536 = 1385.375 (vs. 1385.435475) , rel error = 1/22909_

**C**

fract_q15d16_t **Fract_10toX_Q15d16** (fract_q15d16_t **x** );

**Fract_2toMinusX_Q15 Function**

fract_q15_t Fract_2toMinusX_Q15( fract_q15_t x );

**Summary**

Calculates pow(2,-x) with fixed point math.

**Description**

Calculates pow(2,-x) with fixed point math, using three term Taylor Series and 256 entry lookup table.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Exponent in calculating 2\^-x. If x \\&lt; 0 then -x is used.

**Returns**

Value of pow(2,-x)

**Remarks**

If 0 \\&lt;= x \\&lt; 1, then pow(2,-x) is in the range 0.5 \\&lt; pow(2,-x) \\&lt;= 1.

**Example**

fract_q15_t x,y;

x = 3277; _// 0.1_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.1) = 0.933033 = 30574 / 32768_

_// y = 0x776D = 30573_

x = 6554; _// 0.2_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.2) = 0.870551 = 28526 / 32768_

_// y = 0x6F6E = 28526_

x = 9830; _// 0.3_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.3) = 0.812252 = 26616 / 32768_

_// y = 0x67F9 = 26617_

x = 13107; _// 0.4_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.4) = 0.757858 = 24834 / 32768_

_// y = 0x6102 = 24834_

x = 16384; _// 0.5_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.5) = 0.707107 = 23170 / 32768_

_// y = 0x5A81 = 23169_

x = 3277 + 16384; _// 0.1 + 0.5 = 0.6_

y = Fract_2toMinusX_Q15(x);

_// pow(2,0.6) = 0.659754 = 21619 / 32768_

_// y = 0x5472 = 21618_

x = 6554 + 16384; _// 0.2 + 0.5 = 0.7_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.7) = 0.615572 = 20171 / 32768_

_// y = 0x4ECA = 20170_

x = 9830 + 16384; _// 0.3 + 0.5 = 0.8_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.8) = 0.574349 = 18820 / 32768_

_// y = 0x4984 = 18820_

x = 13107 + 16384; _// 0.4 + 0.5 = 0.9_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-0.9) = 0.535887 = 17560 / 32768_

_// y = 0x4498 = 17560_

x = 32767; _// 0.5 + 0.5 = 1.0_

y = Fract_2toMinusX_Q15(x);

_// pow(2,-1.0) = 0.5 = 16384 / 32768_

_// y = 0x4001 = 16385_

**C**

fract_q15_t **Fract_2toMinusX_Q15** (fract_q15_t **x** );

**Fract_2toX_Q15bfp Function**

fract_q15bfp_t Fract_2toX_Q15bfp( fract_q15bfp_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, from Q15 block floating point x, returning Q15 block floating point result.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x exponent, in Q15 block floating point format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

None.

**Example**

fract_q15bfp_t x, y;

x.m = 16384; _// 0.5_

x.e = 0;

y = Fract_2toX_Q15bfp(x);

_// pow(2,0.5) = sqrt(2) = 46341/32768;_

_// y.m = 0x5A85 = 23173_

_// y.e = 1_

_// y = (23173/32768)\\&lt;\\&lt;1 = 1.414368 (vs. 1.414214)_

x.m = 24576; _// 0.75_

x.e = 0;

y = Fract_2toX_Q15bfp(x);

_// pow(2,0.75) = 1.681793 = 55109/32768;_

_// y.m = 0x6BA4 = 27556_

_// y.e = 1_

_// y = (27556/32768)\\&lt;\\&lt;1 = 1.681885 (vs. 1.681793)_

**C**

fract_q15bfp_t **Fract_2toX_Q15bfp** (fract_q15bfp_t **x** );

**Fract_2toX_Q15bfpFromQ15d16 Function**

fract_q15bfp_t Fract_2toX_Q15bfpFromQ15d16( fract_q15d16_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, based on input in Q15.16 format, returning result in Q15 block floating point format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15.16 format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

None.

**Example**

fract_q15d16_t x;

fract_q15bfp_t Y;

x = 0x00008000; _// 0.5 in Q15.16_

Y = Fract_2toX_Q15bfpFromQ15d16(x);

_// pow(2,0.5) = sqrt(2) = 1.414213 = 46341 / 32768 = 0x5A82\\&lt;\\&lt;1_

_// Y.m = 0x5A85 = 23173_

_// Y.e = 1_

_// Y = ( 23173 / 32768 )\\&lt;\\&lt;1 = 1.414367 (vs. 1.414213)_

x = 0x00014000; _// 1.25 in Q15.16_

Y = Fract_2toX_Q15bfpFromQ15d16(x);

_// pow(2,1.25) = 2.378414 = 77936 / 32768 = 0x4C1C\\&lt;\\&lt;2_

_// Y.m = 0x4C1 = 19484_

_// Y.e = 2_

_// Y = ( 19484/32768 ) \\&lt;\\&lt; 2 = 2.378418 (vs. 2.378414)_

**C**

fract_q15bfp_t **Fract_2toX_Q15bfpFromQ15d16** (fract_q15d16_t **x** );

**Fract_2toX_Q15d16 Function**

fract_q15d16_t Fract_2toX_Q15d16( fract_q15d16_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with Q15.16 x, returning Q15.16 result

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15.16 format

**Returns**

pow(2,x), in Q15.16 format

**Remarks**

None.

**Example**

fract_q15d16_t x,y;

x = 0x00008000; _// 0.5 in Q15.16_

y = Fract_2toX_Q15d16(x);

_// pow(2,0.5) = sqrt(2) = 1.414213 = 92682/65536 = 0x0001 6A0A_

_// y = 0x0001 6A14 = 92692/65536 = 1.414367 (vs. 1.414213)_

x = 0x00014000; _// 1.25 in Q15.16_

y = Fract_2toX_Q15d16(x);

_// pow(2,1.25) = 2.378414 = 155,872 / 65536 = 0x0002 60E0_

_// y = 0x0002 60E0_

**C**

fract_q15d16_t **Fract_2toX_Q15d16** (fract_q15d16_t **x** );

**Fract_Convert_Q15bfpToQ15d16 Function**

fract_q15d16_t Fract_Convert_Q15bfpToQ15d16( fract_q15bfp_t x )

**Summary**

Convert Q15 block floating point to Q15.16 fixed point.

**Description**

Convert Q15 block floating point to Q15.16 fixed point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 Block Floating Point

**Returns**

Input converted to Q15.16 fixed point.

**Remarks**

No effort is made to trap overflows of underflows,

**Example**

fract_q15d16_t x_Q15d16;

fract_q15bfp_t x_Q15bfp;

x_Q15bfp.m = 0x4000; _// 1/2_

x_Q15bfp.e = -1; _// 1/2\\&gt;\\&gt;1 = 1/4_

x_Q15d16 = Fract_Convert_Q15bfpToQ15d16( x_Q15bfp );

_// x_Q15d16 = 0x0000 4000_

**C**

fract_q15d16_t **Fract_Convert_Q15bfpToQ15d16** (fract_q15bfp_t **x** );

**Fract_Convert_Q15bfpToQ31 Function**

fract_q31_t Fract_Convert_Q15bfpToQ31( fract_q15bfp_t x )

**Summary**

Convert Q15 block floating point to Q31 fixed point.

**Description**

Convert Q15 block floating point to Q31 fixed point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 Block Floating Point

**Returns**

Input converted to Q31 fixed point.

**Remarks**

No effort is made to trap overflows of underflows,

**Example**

**C**

fract_q31_t **Fract_Convert_Q15bfpToQ31** (fract_q15bfp_t **x** );

**Fract_Convert_Q15d16ToQ15bfp Function**

fract_q15bfp_t Fract_Convert_Q15d16ToQ15bfp( fract_q15d16_t x )

**Summary**

Convert from Q15.16 fixed point to Q15 Block Floating Point

**Description**

Convert from Q15.16 fixed point to Q15 Block Floating Point

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15.16 fixed point

**Returns**

Input convertd to Q15 Block Floating Point.

**Remarks**

Mantissa and exponent are adjusted to remove redundant leading bits.

**Example**

fract_q15d16_t x_Q15d16;

fract_q15bfp_t x_Q15bfp;

x_Q15d16 = 0xFFFFC000; _//-1/4_

x_Q15bfp = Fract_Convert_Q15d16ToQ15bfp(x_Q15d16);

_//x_Q15bfp.m = 0xC000 // -1/2_

_//x_Q15bfp.e = 0xFFFF = -1; // -1/2\\&gt;\\&gt;1 = -1/4_

**C**

fract_q15bfp_t **Fract_Convert_Q15d16ToQ15bfp** (fract_q15d16_t **x** );

**Fract_Convert_Q15ToQ15bfp Function**

fract_q15bfp_t Fract_Convert_Q15ToQ15bfp( fract_q15_t x )

**Summary**

Convert from Q15 fixed point to Q15 Block Floating Point

**Description**

Convert from Q15 fixed point to Q15 Block Floating Point

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 (aka Q1.15) fixed point

**Returns**

Input convertd to Q15 Block Floating Point.

**Remarks**

Mantissa and exponent are adjusted to remove redundant leading bits.

**Example**

fract_q15_t x_Q15;

fract_q15bfp_t x_Q15bfp;

x_Q15 = 0xE000; _//-1/4_

x_Q15bfp = Fract_Convert_Q15d16ToQ15bfp(x_Q15d16);

_//x_Q15bfp.m = 0xC000 // -1/2_

_//x_Q15bfp.e = 0xFFFF = -1; // -1/2\\&gt;\\&gt;1 = -1/4_

**C**

fract_q15bfp_t **Fract_Convert_Q15ToQ15bfp** (fract_q15_t **x** );

**Fract_InversePower Function**

fract_q15bfp_t Fract_InversePower( uint16_t nBase, uint16_t nExponent )

**Summary**

Computes pow(nBase,-nExponent).

**Description**

Computes pow(nBase,-nExponent).

**Preconditions**

None

**Returns**

pow(nBase,-nExponent), as a Q15bfp block floating point number.

**Remarks**

pow(nBase,nExponent) must fit inside a uint32_t variable.

**Example**

uint16_t nBase, nExponent;

fract_q15bfp_t Answer;

nBase = 5;

nExponent = 3;

Answer = Fract_InversePower(nBase,nExponent);

_// Answer = pow(5,-3) = 1/125_

_// Answer.m = 0x4189 = 16777_

_// Answer.e = 0xFFFA = -6_

_// Answer = (16777/32768)\\&gt;\\&gt;6 = 1/(125.001609)_

**C**

fract_q15bfp_t **Fract_InversePower** (uint16_t **nBase** , uint16_t **nExponent** );

**Fract_log10fix Function**

int32_t Fract_log10fix (int32_t x, size_t precision)

Calculates fixed point base 10 logarithm using number of fractional bits

specified by precision argument.

**Description**

Calculates fixed point base 10 logarithm using number of fractional bits specified by precision argument. Log base 10 is calculated using the log base 2 function Fract_log2fix.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Fixed point input, if x == 0, function returns INT32_MIN to represent negative

infinity. If x is input as a negative number it will be cast to be a unsigned 32 bit integer.

precision number of fractional bits in input and output, 1\\&lt;= precision \\&lt;= 31. if precision \\&lt; 1 or precision \\&gt; 31 function returns INT32_MAX.

**Returns**

Logarithm base 10 of input, in same Q format as input.

**Remarks**

If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.

This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16_t integer.

**Example**

See the code example under Fract_log2fix.

**C**

int32_t **Fract_log10fix** (int32_t **x** , size_t **precision** );

**Fract_log2fix Function**

int32_t Fract_log2fix (int32_t X32, size_t precision)

**Summary**

Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument.

**Description**

Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument. This implementation is based on Clay. S. Turner&#39;s fast binary logarithm algorithm[1].

**Preconditions**

None.

**Parameters**

**Parameters Description**

X32 Fixed point input, if x == 0, function returns INT32_MIN to represent negative

infinity. If x \\&lt; 0 function returns INT32_MAX as error.

precision number of fractional bits in input and output, 1\\&lt;= precision \\&lt;= 31. if precision \\&lt; 1 or

precision \\&gt; 31 function returns INT32_MAX as error.

**Returns**

Logarithm base 2 of input, in same Q format as input. The Q format used is based on the value of precision. For example, if

precision == 16 then the Q format used is Q15.16.

**Remarks**

If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.

This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16_t integer.

References: [1] C. S. Turner, &quot;A Fast Binary Logarithm Algorithm&quot;, IEEE Signal Processing Mag., pp. 124,140, Sep. 2010.

**Example**

_// Make log output Q15.16_

**#define** PRECISION 16

**#define** STRING_MAX_SIZE 133

**char** ioString[STRING_MAX_SIZE];

**double** Xdouble;

**double** scale = 1U \\&lt;\\&lt; PRECISION;

**float** Xfloat;

int16_t X16;

int32_t X32;

while ( Xdouble != -1.0 )

{

sprintf(ioString,&quot;rnX: &quot;);

SendDataBuffer(ioString, strlen(ioString) );

GetDataBuffer(ioString,STRING_MAX_SIZE);

sscanf(ioString,&quot;%f&quot;,&amp;Xfloat);

Xdouble = Xfloat;

**if** ( Xdouble == -1 )

{

sprintf(ioString,&quot;rnWe&#39;re done!rn&quot;);

SendDataBuffer(ioString, strlen(ioString) );

**return** 0;

}

**else if** ( Xdouble \\&lt; 0 )

{

sprintf(ioString,&quot;%f is Negative!rn&quot;,Xdouble);

SendDataBuffer(ioString, strlen(ioString) );

**continue** ;

}

**else if** ( Xdouble \\&gt;= 1 \\&lt;\\&lt; (32 - PRECISION) )

{

sprintf(ioString, &quot;%f is too bigrn&quot;, Xdouble);

SendDataBuffer(ioString, strlen(ioString) );

**continue** ;

}

sprintf(ioString,&quot; log10(%f) = %frn&quot;, Xdouble, ( **double** )log10(Xdouble));

SendDataBuffer(ioString, strlen(ioString) );

X32 = Fract_log10fix(Xdouble \* scale, PRECISION);

sprintf(ioString,&quot;Fract_log10fix(%f) = %f (0x%08X)rn&quot;, Xdouble, X32/scale, X32);

SendDataBuffer(ioString, strlen(ioString) );

X32 = Fract_log2fix(Xdouble \* scale, PRECISION) ;

sprintf(ioString,&quot; Fract_log2fix(%f) = %f (0x%08X)rn&quot;, Xdouble, X32/scale, X32 );

SendDataBuffer(ioString, strlen(ioString) );

}_//end while ( Xdouble != -1.0 )_

**C**

int32_t **Fract_log2fix** (int32_t **X32** , size_t **precision** );

**Fract_Power Function**

uint32_t Fract_Power( uint16_t nBase, uint16_t nExponent )

**Summary**

Computes pow(nBase,nExponent) using for loop.

**Description**

Computes pow(nBase,nExponent) using for loop.

**Preconditions**

None

**Returns**

pow(nBase,nExponent), this must fit into a 32 bit unsigned integer.

**Remarks**

none

**Example**

uint16_t nBase, nExponent;

uint32_t answer;

nBase = 5;

nExponent = 3;

answer = Fract_Power(nBase,nExponent);

_// Answer = pow(5,3) = 125 = 0x007D_

**C**

uint32_t **Fract_Power** (uint16_t **nBase** , uint16_t **nExponent** );

**Fract_sqrtQ15 Function**

fract_q15_t Fract_sqrtQ15(fract_q15_t X)

**Summary**

Fixed point Q15 squareroot.

**Description**

Returns square root of Q15 (Q0.15) fraction. Since -1 \\&lt;= X \\&lt; 1, we know that the 0\\&lt;= SquareRoot(||X||) \\&lt; 1.

**Preconditions**

None.

**Parameters**

**Parameters Description**

X Q15 input, should be non-negative.

**Returns**

Square root of abs(X).

**Remarks**

Given integer X, solve for Y such that

Y Y X

---- \* ---- = ----

2\^15 2\^15 2\^15

This is equivalent to

Y \* Y = X \* 2\^15 = X\\&lt;\\&lt;15

So as integers:

Y = integer sqrt(X\\&lt;\\&lt;15)

thus

fixed_point_sqrt(X) = integer_sqrt(X\\&lt;\\&lt;15)

For X = 0,1,...32767, define

ErrSqrt = (sqrt(X/32768.0) - FixedPointSQRT(X))/sqrt(X/32768.0)

This error ranges from 0 to 0.015259, with an average error of 0.0054096

The fast integer square root function used is based on

http://stackoverflow.com/questions/1100090/looking-for-an-efficient-integer-square-root-algorithm-for-arm-thumb2

**Example**

**C**

fract_q15_t **Fract_sqrtQ15** (fract_q15_t **X** );

**Fract_XminusY_Q15bfp Function**

fract_q15bfp_t Fract_XminusY_Q15bfp( fract_q15bfp_t x, fract_q15bfp_t y )

**Summary**

Subtract two Q15 block floating point numbers.

**Description**

Subtract two Q15 block floating point numbers.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x Q15 block floating point term

y Q15 block floating point term

**Returns**

x-y as Q15 block floating point

**Remarks**

None.

**Example**

fract_q15d16_t x, y;

fract_q15bfp_t X, Y, XminusY;

x = 0x00030000; _// 3_

y = 0x00070000; _// 7_

X = Fract_Convert_Q15d16ToQ15bfp(x);

Y = Fract_Convert_Q15d16ToQ15bfp(y);

XminusY = Fract_XminusY_Q15bfp( X, Y );

_// XplusY.m = 0xC000 = -16384/32768 = -0.5_

_// XPlusY.e = 3_

_// XPlusY = -0.5\\&lt;\\&lt;3 = -4_

**C**

fract_q15bfp_t **Fract_XminusY_Q15bfp** (fract_q15bfp_t **x** , fract_q15bfp_t **y** );

**Fract_XoverY_Q15bfp Function**

fract_q15bfp_t Fract_XoverY_Q15bfp(fract_q15bfp_t x, fract_q15bfp_t y )

**Summary**

Division x/y as Q15 block floating point.

**Description**

Division x/y as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Numerator as Q15 block floating point

y Denominator as Q15 block floating point

**Returns**

Ratio x/y as Q15 block floating point.

**Remarks**

None.

**Example**

fract_q15_t x,y;

fract_q15bfp_t X, Y, XoverY;

x = 0x1234; _// 4660/32768 = 0.142219_

y = 0x5678; _// 22136/32768 = 0.675537_

X = Fract_Convert_Q15d16ToQ15bfp((fract_q15d16_t)x);

Y = Fract_Convert_Q15d16ToQ15bfp((fract_q15d16_t)y);

XoverY = Fract_XoverY_Q15bfp(X,Y);

_// x/y = 4660/22136 = 6898/32768 = 0.210516_

_// XoverY.m = 0x6BC8 = 27592_

_// XoverY.e = 0xFFFE = -2_

_// XoverY = (27592/32768)\\&gt;\\&gt;2 = 0.210510_

**C**

fract_q15bfp_t **Fract_XoverY_Q15bfp** (fract_q15bfp_t **x** , fract_q15bfp_t **y** );

**Fract_XoverY_Q15bfpFromQ15 Function**

fract_q15bfp_t Fract_XoverY_Q15bfpFromQ15(fract_q15_t x, fract_q15_t y )

**Summary**

Calculate ratio of X/Y as Q15&#39;s but return result as Q15 block floating point.

**Description**

Calculate ratio of X/Y as Q15&#39;s but return result as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 numerator

y Q15 denominator

**Returns**

Ratio x/y as Q15 block floating point

**Remarks**

None.

**Example**

fract_q15_t x,y;

fract_q15bfp_t XoverY;

x = 0x1234; _// 4660/32768 = 0.142219_

y = 0x5678; _// 22136/32768 = 0.675537_

XoverY = Fract_XoverY_Q15bfpFromQ15(x,y);

_// x/y = 4660/22136 = 6898/32768 = 0.210516_

_// XoverY.m = 0x6BC8 = 27592_

_// XoverY.e = 0xFFFE = -2_

_// XoverY = (27592/32768)\\&gt;\\&gt;2 = 0.210510_

**C**

fract_q15bfp_t **Fract_XoverY_Q15bfpFromQ15** (fract_q15_t **x** , fract_q15_t **y** );

**Fract_XoverY_Q15d16FromQ15 Function**

fract_q15d16_t Fract_XoverY_Q15d16FromQ15( fract_q15_t x, fract_q15_t y );

**Summary**

Calculates ratio X/Y for two Q15 fixed points

**Description**

Calculates ratio X/Y for two Q15 fixed points

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 numerator

y Q15 denominator

**Returns**

Ratio x/y as Q15.16 fixed point

**Remarks**

Since ratio x/y can be bigger than unity, result must be Q15.16.

**Example**

fract_q15_t x,y;

fract_q15d16_t xovery;

x = 0xDEAD; _// -8531/32768 = -0.260345_

y = 0xBEEF; _// -16657/32768 = -0.508331_

xovery = Fract_XoverY_Q15d16FromQ15(x,y);

_// x/y = -8531/-16657 = 33564/65536 = 0.512157_

_// xovery = 0x0000 831C = 33564_

**C**

fract_q15d16_t **Fract_XoverY_Q15d16FromQ15** (fract_q15_t **x** , fract_q15_t **y** );

**Fract_XplusY_Q15bfp Function**

fract_q15bfp_t Fract_XplusY_Q15bfp( fract_q15bfp_t x, fract_q15bfp_t y )

**Summary**

Add two Q15 block floating point numbers.

**Description**

Add two Q15 block floating point numbers.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x Q15 block floating point term

y Q15 block floating point term

**Returns**

x+y as Q15 block floating point

**Remarks**

None.

**Example**

fract_q15d16_t x, y;

fract_q15bfp_t X, Y, XplusY;

x = 0x00030000; _// 3_

y = 0x00070000; _// 7_

X = Fract_Convert_Q15d16ToQ15bfp(x);

Y = Fract_Convert_Q15d16ToQ15bfp(y);

XplusY = Fract_XplusY_Q15bfp( X, Y );

_// XplusY.m = 0x5000 = 20480/32768 = 0.625_

_// XPlusY.e = 4_

_// XPlusY = 0.625\\&lt;\\&lt;4 = 10_

**C**

fract_q15bfp_t **Fract_XplusY_Q15bfp** (fract_q15bfp_t **x** , fract_q15bfp_t **y** );

**Fract_XtimesY_Q15 Function**

fract_q15_t Fract_XtimesY_Q15(fract_q15_t x, fract_q15_t y );

**Summary**

Calculates product of X\*Y for Q15 fixed point

**Description**

Calculates product of X\*Y for Q15 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q15 multiplicand

y Q15 multiplicand

**Returns**

Q15 product x\*y

**Remarks**

Since both x and y are Q15 fixed point numbers the product x\*y is also Q15.

**Example**

fract_q15_t x, y, xtimesy;

x = 0x1234; _// 4660/32768 = 0.142219_

y = 0x5678; _// 22136/32768 = 0.675537_

xtimesy = Fract_XtimesY_Q15(x,y);

_// x\*y = 0.142219 \* 0.675537 = 0.096069_

_// xtimesy = 0x0C4C = 3148/32768 = 0.096069_

**C**

fract_q15_t **Fract_XtimesY_Q15** (fract_q15_t **x** , fract_q15_t **y** );

**Fract_XtimesY_Q15bfp Function**

fract_q15bfp_t Fract_XtimesY_Q15bfp(fract_q15bfp_t x, fract_q15bfp_t y )

**Summary**

Multiply X times Y, for Q15 block floating point arguments.

**Description**

Multiply X times Y, for Q15 block floating point arguments.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 block floating point multiplicand

y Q15 block floating point multiplicand

**Returns**

Product x\*y as Q15 block floating point

**Remarks**

None.

**Example**

fract_q15bfp_t X,Y,XtimesY;

X.m = 0x1234;

X.e = 0; _// 4660/32768 = 0.142219_

Y.m = 0x5678;

Y.e = 0; _// 22136/32768 = 0.675537_

XtimesY = Fract_XtimesY_Q15bfp(X,Y);

_// XtimesY.m = 0x6260 = 25184/32768 = 0.768554_

_// XtimesY.e = 0xFFFD = -3_

_// XtimesY = 0.768554\\&gt;\\&gt;3 = 0.096069_

_// X\*Y = 0.142219 \* 0.675537 = 0.096069_

**C**

fract_q15bfp_t **Fract_XtimesY_Q15bfp** (fract_q15bfp_t **x** , fract_q15bfp_t **y** );

**Fract_XtimesY_Q15d16 Function**

fract_q15d16_t Fract_XtimesY_Q15d16(fract_q15d16_t x, fract_q15d16_t y );

**Summary**

Calculates product of X\*Y for Q15.16 fixed point

**Description**

Calculates product of X\*Y for Q15.16 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q15.16 multiplicand

y Q15.16 multiplicand

**Returns**

Q15.16 product x\*y

**Remarks**

Since both x and y are Q15.16 fixed point numbers the product x\*y is also Q15.16.

**C**

fract_q15d16_t **Fract_XtimesY_Q15d16** (fract_q15d16_t **x** , fract_q15d16_t **y** );

**Fract_XtimesY_Q31 Function**

fract_q31_t Fract_XtimesY_Q31(fract_q31_t x, fract_q31_t y );

**Summary**

Calculates product of X\*Y for Q31 fixed point

**Description**

Calculates product of X\*Y for Q31 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q31 multiplicand

y Q31 multiplicand

**Returns**

Q31 product x\*y

**Remarks**

Since both x and y are Q31 fixed point numbers the product x\*y is also Q31.

**C**

fract_q31_t **Fract_XtimesY_Q31** (fract_q31_t **x** , fract_q31_t **y** );

**Fx16Norm Function**

Normalize the 16-bit fractional value.

**Description**

Function Fx16Norm:

Produces then number of left shifts needed to Normalize the 16-bit fully fractional input. If the input &#39;a&#39; is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of [(MAXFRACT16+1)/2] to a maximum of [MAXFRACT16]. If the input &#39;a&#39; is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of [MINFRACT16] to a maximum of [MINFRACT16/2]. This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left shift function should be used with the value returned From this function.

the 16-bit input on range: 0 =\\&gt; result \\&lt; 16 (i.e. NUMBITSFRACT16) If a\\&gt;0: 0x4000 \\&gt; Normalized Value \\&lt;= 0x7fff i.e. (MAXFRACT16+1)/2 \\&gt; aNorm \\&lt;= MAXFRACT16 If a\\&lt;0: 0x8000 \\&gt;= Normalilzed Value \\&lt; 0xC000 i.e. MINFRACT16\\&gt;= aNorm \\&lt;

MINFRACT16/2

This function relates to the ETSI norm_s function.

**Parameters**

**Parameters Description**

q15 a in Q1.15

**Returns**

i16 result - The number of left shifts required to normalize

**C**

int16_t **Fx16Norm** (q15);

**Fx32Norm Function**

Normalize the 32-bit number.

**Description**

Function Fx32Norm:

Produces then number of left shifts needed to Normalize the 32-bit fractional input. If the input &#39;a&#39; is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of [(MAXFRACT32+1)/2] to a maximum of [MAXFRACT32]. If the input &#39;a&#39; is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of [MINFRACT32] to a maximum of [MINFRACT32/2]. This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left-shift function should be used with the value returned From this function.

32-bit input on range: 0 =\\&gt; result \\&lt; 32 (i.e. NUMBITSFRACT32) If a\\&gt;0: 0x40000000 \\&gt; Normalized Value \\&lt;= 0x7fffffff i.e.

(MAXFRACT32+1)/2 \\&gt; aNorm \\&lt;= MAXFRACT32 If a\\&lt;0: 0x80000000 \\&gt;= Normalized Value \\&lt; 0xC0000000 i.e. MINFRACT32\\&gt;=

aNorm \\&lt; MINFRACT32/2

This function relates to the ETSI norm_l function.

**Parameters**

**Parameters Description**

q31 a 32-bit Q1.d31 to be normalized

**Returns**

int16_t result - The number of left shifts required to normalize the

**C**

int16_t **Fx32Norm** (q31);

**libq_q15_Abs_q15 Function**

Saturated Absolute value.

**Description**

Function libq_q15_Abs_q15:

Creates a saturated Absolute value. It takes the absolute value of the 16-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT16 is greater than MAXFRACT16, or the allowable range of 16-bit values. This function relates to the ETSI abs function.

**Parameters**

**Parameters Description**

q15 a input argument

**Returns**

q15 result - abs(input) \\&lt;= MAXFRACT16

**C**

q15 **libq_q15_Abs_q15** (q15);

**libq_q15_Add_q15_q15 Function**

Add two 16-bit 2s-complement fractional values.

**Description**

Function libq_q15_Add_q15_q15: f

Add two 16-bit 2s-complement fractional (op1 + op2) to produce a 16-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output.

**Returns**

q15 - a+b on Range: MINFRACT16 \\&lt;= result \\&lt;= MAXFRACT16

**C**

q15 **libq_q15_Add_q15_q15** (q15, q15);

**libq_q15_DivisionWithSaturation_q15_q15 Function**

Fractional division with saturation.

**Description**

Function libq_q15_DivisionWithSaturation_q15_q15():

Performs fractional division with saturation. There are three restrictions that the calling code must satisfy.

1. Both the numerator and denominator must be positive.

2. In order to obtain a non-saturated result, the numerator must be LESS than or equal to the denominator.

3. The denominator must not equal zero.

If &#39;num&#39; equals &#39;den&#39;, then the result equals MAXINT16.

This function relates to the ETSI div_s function.

**Parameters**

**Parameters Description**

q15 num 16-bit fractional numerator

q15 den 16-bit fractional denumerator

**Returns**

q15 result - ratio a/b in 16-bit fractional format

**C**

q15 **libq_q15_DivisionWithSaturation_q15_q15** (q15, q15);

**libq_q15_ExpAvg_q15_q15_q1d15 Function**

Exponential averaging

**Description**

Function libq_q15_ExpAvg_q15_q15_q1d15()

Exponential averaging implements a smoothing function based on the form: avg[i+1] = avg[i] \* lamda + new \* (1-lamda) In this implementation, is has been optimized as follows. avg[i+1] = (avg[i] - new) \* lamda + new

The optimization precludes accurate processing of new numbers that differ from the current average by more than unity. If the difference is greater than unity or less than negative unity, the difference is saturated.

The effect is akin to a smaller lambda, e.g., the new value will have a greater weight than expected. If the smoothing is of data that is entirely positive or entirely negative, then the saturation will not be an issue.

**Parameters**

**Parameters Description**

q15 S(k) Previous exponential average

q15 X(k) New value to be averaged in

q15 L exponential averaging constant in Q1.15

**Returns**

q15 result - S(k+1) = S(k)\*L + X(k)\*(1-L)

**C**

q15 **libq_q15_ExpAvg_q15_q15_q1d15** (q15 **prevAvgQ15** , q15 **newMeasQ15** , q15 **lamdaQ1d15** );

**libq_q15_ExtractH_q31 Function**

Extracts upper 16 bits of input 32-bit fractional value.

**Description**

Function libq_q15_ExtractH_q31:

Extracts upper 16 bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the top 16-bits of the 32-bit input. This function relates to the ETSI extract_h function.

**Returns**

q15 result - Upper 16 bits of 32-bit argument a

**C**

q15 **libq_q15_ExtractH_q31** (q31);

**libq_q15_ExtractL_q31 Function**

Extracts lower 16-bits of input 32-bit fractional value.

Descriptionf Extracts lower 16-bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the bottom 16-bits of the 32-bit input. This function relates to the ETSI extract_l function.

**Description**

Function libq_q15_ExtractL_q31:

**Returns**

q15 - Lower 16 bits of 32-bit argument a

**C**

q15 **libq_q15_ExtractL_q31** (q31);

**libq_q15_MacR_q31_q15_q15 Function**

Multiply accumulate with rounding.

**Description**

Function libq_q15_MacR_q31_q15_q15:

This function is multiply-accumulate WITH Rounding applied to the accumulator result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values &#39;b x c&#39; which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a &#39;0&#39; in the Lsb. The shifted multiplier output is then added to the 32-bit fractional input &#39;a&#39;. Then the 32-bits of the accumulator output are rounded by adding &#39;2\^15&#39;. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output. This function is for fractional Qtype format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI L_mac_r function.

**Parameters**

**Parameters Description**

q31 a 32-bit accumulator operand

q15 b 16-bit multiplication operand

q15 c 16-bit multiplication operand

**Returns**

q15 result - a+b\*c rounded

**C**

q15 **libq_q15_MacR_q31_q15_q15** (q31, q15, q15);

**libq_q15_MsuR_q31_q15_q15 Function**

Multiply-Subtraction with rounding

**Description**

Function libq_q15_MsuR_q31_q15_q15:

This function is like Multiply-Subtract but WITH Rounding applied to the subtractor result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values &#39;b x c&#39; which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a &#39;0&#39; in the Lsb. The shifted multiplier output is then SUBTRACTED From the 32-bit fractional input &#39;a&#39;. Then the 32-bits output From this subtraction are rounded by adding &#39;2\^15&#39;. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output.

This function is for fractional Q-type format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI msu_r function.

**Parameters**

**Parameters Description**

q31 a Value which is subtracted from

q15 b multiplication operand 1

q15 c multiplication operand 2

**Returns**

q15 result - a-b\*c rounded to Q1.15

**C**

q15 **libq_q15_MsuR_q31_q15_q15** (q31, q15, q15);

**libq_q15_MultiplyR2_q15_q15 Function**

fractional multiplication of two 16-bit fractional values giving a 16 bit rounded result.

**Description**

Function libq_q15_MultiplyR2_q15_q15:

Performs fractional multiplication of two 16-bit fractional values and returns a ROUNDED 16-bit fractional result. The function performs a Q15xQ15-\\&gt;Q30 bit multiply with a left shift by &#39;1&#39; to give a Q31 result. This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any 32-bit result that overflows. Rounding is applied to the 32-bit SHIFTED result by adding in a weight factor of 2\^15, again any overflows are saturated. The TOP 16-bits are extracted and returned. This function is for fractional &#39;Qtype&#39; data only and it therefore will not give the correct results for true integers (because left shift by &#39;1&#39;). This function assumes that the binary point in the 32-bit shifted multiplier output is between bit_16 and bit_15 when the rounding factor is added. For the special case where both inputs equal the MINFACT16, the function returns a value equal to MAXFACT16, i.e. 0x7fff = &#39;libq_q15_Mult2_q15_q15(0x8000,0x8000)&#39;. This function internally calls the libq_q15_mult_q15_q31() routine to perform the actual multiplication and the rounding routine to perform the actual rounding.

This function relates to the ETSI mult_r function.

**Parameters**

**Parameters Description**

q15 a value in Q1.15

q15 b value in Q1.15

**Returns**

q15 result - a\*b rounded 16-bit signed integer (Q1.15) output value

**C**

q15 **libq_q15_MultiplyR2_q15_q15** (q15, q15);

**libq_q15_Negate_q15 Function**

Negate 16-bit 2s-complement fractional value with saturation.

**Description**

Function libq_q15_Negate_q15:

Negate 16-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT16 is greater than MAXFRACT16, or the allowable range of values. This function relates to the ETSI negate function.

**Returns**

q15 result on range: MINFRACT16 \\&lt;= result \\&lt;= MAXFRACT16

**C**

q15 **libq_q15_Negate_q15** (q15);

**libq_q15_RoundL_q31 Function**

Rounds the lower 16-bits of the 32-bit fractional input.

**Description**

Function libq_q15_RoundL_q31:

Rounds the lower 16-bits of the 32-bit fractional input into a 16-bit fractional value with saturation. This converts the 32-bit fractional value to 16-bit fractional value with rounding. This function calls the &#39;Add&#39; function to perform the 32-bit rounding of the input value and &#39;ExtractH&#39; function to extract to top 16-bits. This has the effect of rounding positive fractional values up and more positive, and has the effect of rounding negative fractional values up and more positive. This function relates to the ETSI round function.

**Returns**

q15 result

**C**

q15 **libq_q15_RoundL_q31** (q31);

**libq_q15_ShiftLeft_q15_i16 Function**

&#39;Arithmetic&#39; Shift of the 16-bit input argument.

**Description**

Function libq_q15_ShiftLeft_q15_i16:

Performs an &#39;Arithmetic&#39; Shift of the 16-bit input argument &#39;a&#39; left by the input argument &#39;b&#39; bit positions. If &#39;b&#39; is a positive number, a 16-bit left shift is performed with &#39;zeros&#39; inserted to the right of the shifted bits. If &#39;b&#39; is a negative number, a right shift by abs(b) positions with &#39;sign extention&#39; Saturation is applied if shifting causes an overflow or an underflow.

positive value: # of bits to left shift (zeros inserted at LSB&#39;s) {To not always saturate: if &#39;a=0&#39;, then max b=15, else max b=14}

negative value: # of bits to right shift (sign extend)

This function relates to the ETSI shl function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed integer value to be shifted.

i16 b 16-bit signed integer shift value

**Returns**

q15 result - arithmetically shifted 16-bit signed integer output

**C**

q15 **libq_q15_ShiftLeft_q15_i16** (q15, i16);

**libq_q15_ShiftRight_q15_i16 Function**

&#39;Arithmetic&#39; RIGHT Shift on a 16-bit value.

**Description**

Function libq_q15_ShiftRight_q15_q15:

Performs an &#39;Arithmetic&#39; RIGHT Shift on a 16-bit input by &#39;b&#39; bit positions. For positive shift directions (b\\&gt;0), &#39;b&#39; Lsb-bits are shifted out to the right and &#39;b&#39; sign-extended Msb-bits fill in From the left. For negative shift directions (b\\&lt;0), &#39;b&#39; Lsb&#39;s are shifted to the LEFT with 0&#39;s filling in the empty lsb position. The left shifting causes &#39;b&#39; Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 16-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.

positive value: # of bits to right shift (sign extend) { To get all sign bits, b\\&gt;=15 } negative value: # of bits to left shift (zeros inserted

at LSB&#39;s)

This function relates to the ETSI shr function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed input value to shift

i16 b 16-bit signed integer shift index

**Returns**

q15 result - 16-bit signed shifted output

**C**

q15 **libq_q15_ShiftRight_q15_i16** (q15, i16);

**libq_q15_ShiftRightR_q15_i16 Function**

Performs an &#39;Arithmetic&#39; RIGHT Shift on a 16-bit input.

**Description**

Function libq_q15_ShiftRightR_q15_q15:

Performs an &#39;Arithmetic&#39; RIGHT Shift on a 16-bit input by &#39;b&#39; bits with Rounding applied. The rounding occurs by adding a bit weight of &quot;1/2 Lsb&quot;, where the &quot;Lsb&quot; is the Ending (shifted) Lsb. For example: The initial Bit#(b) is after the right shift Bit#(0), so the rounding bit weight is Bit#(b-1). Rounding does not occur on either left shifts or on no shift needed cases. For positive shift directions (b\\&gt;0), &#39;b&#39; Lsb-bits are shifted out to the right and &#39;b&#39; sign-extended Msb-bits fill in From the left. For negative shift directions (b\\&lt;0), &#39;b&#39; Lsb&#39;s are shifted to the LEFT with 0&#39;s filling in the empty lsb position. The left shifting causes &#39;b&#39; Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 16-bit left shift. This function does not provide any status-type information to indicate when overflows occur.

positive value: # of bits to right shift (sign extend) {b \\&gt; 15, results in all sign bits} negative value: # of bits to left shift (zeros

inserted at LSB&#39;s)

This function relates to the ETSI shr_r function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q15 result - Arithmetically shifted 16-bit signed integer output

**C**

q15 **libq_q15_ShiftRightR_q15_i16** (q15, i16);

**libq_q15_Sub_q15_q15 Function**

Subtract two 16-bit 2s-complement fractional values

**Description**

Function libq_q15_Sub_q15_q15:

Subtract two 16-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.

**Returns**

q15 result a+b on range: MINFRACT16 \\&lt;= result \\&lt;= MAXFRACT16

**C**

q15 **libq_q15_Sub_q15_q15** (q15, q15);

**libq_q1d15_Sin_q10d6 Function**

Approximates the sine of an angle.

**Description**

Function libq_q1d15_Sin_q10d6:

This function approximates the sine of an angle using the following algorithm: sin(x) = 3.140625x + 0.02026367x\^2 - 5.325196x\^3

+ 0.5446778x\^4 + 1.800293x\^5. The approximation is accurate for any value of x from 0 degrees to 90 degrees. Because sin(-x) =

- sin(x) and sin(x) = sin(180 - x), the sine of any angle can be inferred from an angle in the first quadrant. Therefore, any angle \\&gt;

90 is converted to an angle between 0 &amp; 90. The coefficients of the algorithm have been scaled by 1/8 to fit a Q1d15 format. So the result is scaled up by 8 to obtain the proper magnitudes. The algorithm expects the angle to be in degrees and represented in Q10.6 format. The computed sine value is returned in Q1.15 format.

**Preconditions**

none.

**Parameters**

**Parameters Description**

q15 angle The angle in degrees for which the sine is computed in Q10.6

**Returns**

q15 sine(angle) value in Q1.15

**C**

q15 **libq_q1d15_Sin_q10d6** (q15 **angleQ10d6** );

**libq_q20d12_Sin_q20d12 Function**

3rd order Polynomial apprx. of a sine function

**Description**

Function libq_q20d12_Sin_q20d12:

3rd order Polynomial apprx. of a sine function

**Preconditions**

none.

**Parameters**

**Parameters Description**

q31 angle The angle in radians for which the sine is computed in Q20.12

**Returns**

q31 Sine(angle) value in Q20.12

**C**

q31 **libq_q20d12_Sin_q20d12** (q31 **angQ20d12** );

**libq_q31_Abs_q31 Function**

Saturated Absolute value.

**Description**

Function libq_q31_Abs_q31:

Creates a saturated Absolute value. It takes the absolute value of the 32-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT32 is greater than MAXFRACT32, or the allowable range of 32-bit values.

This function relates to the ETSI L_abs function.

**Returns**

q31 result - abs(a) \\&lt;= MAXFRACT32

**C**

q31 **libq_q31_Abs_q31** (q31);

**libq_q31_Add_q31_q31 Function**

Add two 32-bit 2s-complement fractional values.

**Description**

Function libq_q31_Add_q31_q31:

Add two 32-bit 2s-complement fractional (op1 + op2) to produce a 32-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 32-bit inputs and the resulting 32-bit

output. This function relates to the ETSI L_add function.

**Returns**

q31 result a+b on range: MINFRACT32 \\&lt;= result \\&lt;= MAXFRACT32

**C**

q31 **libq_q31_Add_q31_q31** (q31, q31);

**libq_q31_DepositH_q15 Function**

Place 16 bits in the upper half of 32 bit word.

**Description**

Function libq_q31_DepositH_q15:

Composes a 32-bit fractional value by placing the input 16-bit fractional value in the composite MSB&#39;s and zeros the composite 16-bit LSB&#39;s This is a bit-for-bit placement of input 16-bits into the upper part of 32-bit result.

This function relates to the ETSI L_deposit_H function.

**Returns**

q31 result 16-bits of a in upper MSB&#39;s and zeros in the lower LSB&#39;s

**C**

q31 **libq_q31_DepositH_q15** (q15);

**libq_q31_DepositL_q15 Function**

Place 16 bits in the lower half of 32 bit word.

**Description**

Function libq_q31_DepositL_q15:

Composes a 32-bit fractional value by placing the 16-bit Fraction input value into the lower 16-bits of the 32-bit composite value.

The 16-bit MSB&#39;s of the composite output are sign extended. This is a bit-for-bit placement of input 16-bits into the bottom portion of the composite 32-bit result with sign extention. This function relates to the ETSI L_deposit_l function.

**Returns**

q31 result - SignExtended 16-bit MSB&#39;s and a Value in lower 16-bit LSB&#39;s

**C**

q31 **libq_q31_DepositL_q15** (q15);

**libq_q31_Mac_q31_q15_q15 Function**

Multiply-Accumulate function WITH saturation

**Description**

Function libq_q31_Mac_q31_q15_q15():

Performs a Multiply-Accumulate function WITH saturation. This routine returns the fully fractional 32-bit result From the accumulator output &#39;SAT(addOut_Q1d31)=outQ1d15&#39; where &#39;multOut_Q1d31 + a_Q1d31 = addOut_Q1d31&#39;, and &#39;b_Q1d15 x c_Q1d15 = multOut_Q1d31&#39;. The multiply is performed on the two 16-bit fully fully fractional input values &#39;b x c&#39; which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fully fully fractional-type multiply. The shifted number represents a Q1d31 number with the lsb set to &#39;0&#39;. This Q1d31 number is added with the 32-bit fully fully fractional input argument &#39;a&#39;. Saturation is applied on the output of the accumulator to keep the value within the 32-bit fully fractional range and then this value is returned. This function is for fully fractional Q-type format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI L_mac function.

**Parameters**

**Parameters Description**

q31 a 32-bit accumulator operand 1 in Q1d31

q15 b 16-bit multiplication operand 1 in Q1d15

q15 c 16-bit multiplication operand 2 in Q1d15

**Returns**

q31 result, a+b\*c saturated

**C**

q31 **libq_q31_Mac_q31_q15_q15** (q31, q15, q15);

**libq_q31_Msu_q31_q15_q15 Function**

L_msu(a,b,c)

**C**

q31 **libq_q31_Msu_q31_q15_q15** (q31, q15, q15);

**libq_q31_Mult2_q15_q15 Function**

fractional multiplication of two 16-bit fractional values.

**Description**

Function libq_q31_Mult2_q15_q15:

Performs fractional multiplication of two 16-bit fractional values and returns the 32-bit fractional scaled result. The function performs the Q15xQ15-\\&gt;Q30 fractional bit multiply. It then shifts the result left by &#39;1&#39;, to give a Q31 type result, (the lsb is zero-filled). This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any results that overflow, and then the function returns the 32-bit fractional q31 result. This function is for fractional &#39;Q&#39; data only and it therefore will not give correct results for true integers (because left shift by &#39;1&#39;). For the special case where both inputs equal the MINFRACT16, the function returns a value equal to MAXFACT32, i.e. 0x7fffffff = libq_q15_mult_q15_q31(0x8000,0x8000).

This function relates to the ETSI L_mult function.

**Parameters**

**Parameters Description**

q15 a multiplicand a

q15 b multiplicand b

**Returns**

q31, a\*b

**C**

q31 **libq_q31_Mult2_q15_q15** (q15, q15);

**libq_q31_Multi_q15_q31 Function**

Implement 16 bit by 32 bit multiply.

**Description**

Function libq_q31_Multi_q15_q31():

Implement 16 bit by 32 bit multiply as shown below The &#39;s&#39; and &#39;u&#39; notation shows the processing of signed and unsigned numbers.

-B1- -B0- s u 2nd argument is 32 bits -A0- s 1st argument is 16 bits

**------------**

A0B0 A0B0 s=s\*u 1st 32-bit product is A0\*B0 A0B1 A0B1 s=s\*s 2nd 32-bit product is A0\*B1

**------------**

-S2- -S1- -S0- s=s+s 48-bit result is the sum of products -P1- -P0- 32-bit return is the most significant bits of sum

The algorithm is implemented entirely with the fractional arithmetic library. The unsigned by signed multiply is implemented by shifting bits 15:1 to bits 14:0 of a 16-bit positive fractional number, which throws away bit 0 of the 32-bit number. Since that affects result bits that are used for rounding, rounding processing is included. Saturation processing is handled implicitly in the fractional arithmetic library, except for the case of maximum negative numbers.

**Returns**

q31 result - a\*b rounded

**C**

q31 **libq_q31_Multi_q15_q31** (q15 **argAQ1d15** , q31 **argBQ1d31** );

**libq_q31_Negate_q31 Function**

Negate 32-bit 2s-complement fractional value with saturation.

**Description**

Function libq_q31_Negate_q31:

Negate 32-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT32 is greater than MAXFRACT32, or the allowable range of values. This function relates to the ETSI L_negate function.

**Returns**

q31 result on range: MINFRACT32 \\&lt;= result \\&lt;= MAXFRACT32

**C**

q31 **libq_q31_Negate_q31** (q31);

**libq_q31_ShiftLeft_q31_i16 Function**

&#39;Arithmetic&#39; Shift of the 32-bit value.

**Description**

Function libq_q31_ShiftLeft_q31_i16:

Performs an &#39;Arithmetic&#39; Shift of the 32-bit input argument &#39;a&#39; left by the input argument &#39;b&#39; bit positions. If &#39;b&#39; is a positive number, a 32-bit left shift is performed with &#39;zeros&#39; inserted to the right of the shifted bits. If &#39;b&#39; is a negative number, a 32-bit right shift by b bit positions with &#39;sign extention&#39;:

positive value: # of bits to left shift (zeros inserted at LSB&#39;s) negative value: # of bits to right shift (sign extend)

Saturation is applied if shifting causes an overflow or an underflow.

This function relates to the ETSI L_shl function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 16-bit signed integer shift index

**Returns**

q31 result - arithmetically shifted 32-bit signed integer output

**C**

q31 **libq_q31_ShiftLeft_q31_i16** (q31, i16);

**libq_q31_ShiftRight_q31_i16 Function**

&#39;Arithmetic&#39; RIGHT Shift on a 32-bit value.

**Description**

Function libq_q31_ShiftRight_q31_q15:

Performs an &#39;Arithmetic&#39; RIGHT Shift on a 32-bit input by &#39;b&#39; bit positions. For positive shift directions (b\\&gt;0), &#39;b&#39; Lsb-bits are shifted out to the right and &#39;b&#39; sign-extended Msb-bits fill in From the left. For negative shift directions (b\\&lt;0), &#39;b&#39; Lsb&#39;s are shifted to the LEFT with 0&#39;s filling in the empty lsb position. The left shifting causes &#39;b&#39; Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 32-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.

positive value: # of bits to right shift (sign extend) negative value: # of bits to left shift (zeros inserted at LSB&#39;s)

This function relates to the ETSI L_shr function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q31 result - Arithmetically shifted 32-bit signed integer output

**C**

q31 **libq_q31_ShiftRight_q31_i16** (q31, i16);

**libq_q31_ShiftRightR_q31_i16 Function**

&#39;Arithmetic&#39; RIGHT Shift on a 32-bit value

**Description**

Function libq_q31_ShiftRightR_q31_q15:

Performs an &#39;Arithmetic&#39; RIGHT Shift on a 32-bit input by &#39;b&#39; bits with Rounding applied. The rounding occurs before any shift by adding a bit weight of &quot;1/2 Lsb&quot;, where the &quot;Lsb&quot; is the Ending (shifted) Lsb. For example: The initial Bit#(i+b) is after the right shift Bit#(i), so the rounding bit weight is Bit#(i+b-1). Rounding does not occur on left shifts, when b is negative. After rounding, this function calls the right-shift function to perform the actual 32-bit right shift. For positive shift directions (b\\&gt;0), &#39;b&#39; Lsb-bits are shifted out to the right and &#39;b&#39; sign-extended Msb-bits fill in From the left. For negative shift directions (b\\&lt;0), &#39;b&#39; Lsb&#39;s are shifted to the LEFT with 0&#39;s filling in the empty lsb position. The left shifting causes &#39;b&#39; Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 32-bit left shift. This function does not provide any status-type flag to indicate occurence of overflow.

positive value: # of bits to right shift (sign extend) negative value: # of bits to left shift (zeros inserted at LSB&#39;s)

This function relates to the ETSI L_shr_r function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q31 result - Arithmetically shifted 32-bit signed integer output

**C**

q31 **libq_q31_ShiftRightR_q31_i16** (q31, i16);

**libq_q31_Sub_q31_q31 Function**

Subtract two 32-bit 2s-complement fractional values

**Description**

Function libq_q31_Sub_q31_q31:

Subtract two 32-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.

**Returns**

q31 result a-b on range: MINFRACT31 \\&lt;= result \\&lt;= MAXFRACT31

**C**

q31 **libq_q31_Sub_q31_q31** (q31, q31);

**LUTwInterpolation_Q15 Function**

fract_q15_t LUTwInterpolation_Q15( fract_q15_t x,

const fract_q15_t \* pX_LUT_Vector,

const fract_q15_t \* pY_LUT_Vector,

const uint16_t nLUTSize );

**Summary**

Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.

**Description**

Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 value, independent variable

pX_LUT_Vector X column of LUT in Q15

pY_LUT_Vector Y column of LUT in Q15

nLutSize number of rows (entries) in the LUT

**Returns**

y = f(x) based on the LUT using linear interpolation between table entries.

**Remarks**

It is assumed that X LUT vector is in strictly monotonically increasing order. That is: pX_LUT_Vector[i] \\&lt; pX_LUT_Vector[i+1] for i = 0,1,...nLUTSize-2

Internal math is done in signed 32 integers and truncated to Q15.

If x \\&lt;= pX_LUT_Vector[0] then pY_LUT_Vector[0] is returned.

if pX_LUT_Vector[nLUTSize-1] \\&lt;= x then pY_LUT_Vector[nLUTSize-1] is returned.

WARNING: It is strongly recommended that you test out the LUT and compare actual vs. desired values in Matlab/Octave or Excel! You may need to add additional rows where the interpolation does not produce the needed accuracy.

**C**

fract_q15_t **LUTwInterpolation_Q15** (fract_q15_t **x** , **const** fract_q15_t \* **pX_LUT_Vector** , **const**

fract_q15_t \* **pY_LUT_Vector** , **const** uint16_t **nLUTSize** );

**SinInDegs Function**

fract_q0d15_t SinInDegs( fract_q9d6_t theta );

**Summary**

Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Description**

Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Preconditions**

None

**Parameters**

**Parameters Description**

theta Q9.6 fixed point angle

**Returns**

sin(theta) in Q0.15 fixed point

**Remarks**

None.

**Example**

int32_t nTests = 400;

**float** theta;

**float** delta_theta = 360.0/(nTests-1);

**float** theta0 = 0;

int32_t i;

int32_t x;

for ( i = 0; i \\&lt; nTests; i++ )

{

theta = theta0 + i\*delta_theta;

x = theta\*(32768/512); _//Q9.6_

printf(&quot;%d, %d rn&quot;,( int )x,SinInDegs(x)));

}

**C**

fract_q0d15_t **SinInDegs** (fract_q9d6_t **theta** );