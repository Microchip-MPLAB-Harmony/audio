# Math Libraries Help

**Parent topic:**[MPLAB® Harmony 3 Audio, Support Package](GUID-546D2D8B-EC03-4BF5-B23F-D618F41955FB.md)

## Introduction

This section provides descriptions of the Math libraries that are available in MPLAB-X Harmony 3.

### Description

The fixed point math libraries use fractional value represented in "Q" format as described below

**Integer Representation of Fractions**

Fractional representation of a real number is given by:

*Qn.m* where:

• *n* is the number of data bits to the left of the radix point

• *m* is the number of data bits to the right of the radix point

• a signed bit is implied, and takes one bit of resolution

• Shorthand may eliminate the leading 0, such as in Q0.15, which may be shortened to Q15, and similarly Q0.31, which is shortened to Q31

*Qn.m* numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. Therefore, the range of the numerical value is:

-2^(n-1) to [2^(n-1)) - 2^(-m)]; with a resolution of 2^(-m).

A Q16 format number (Q15.16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259 (or 2^(-16)). For example, a numerical representation of the number 3.14159 in Q2.13 notation would be:

3.14159 * (213^(13)) = 25735.9 => 0x6488

And converting from the Q7.8 format with the value 0x1D89 would be:

0x1D89 / (2^(8)) = 7561 / 256 => 29.5316, accurate to 0.00391

The majority of the math libraries uses functions with variables in Q15 or Q31 format. This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary. All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution. Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.

Usually, a Q16, Q31 and version of each function is available. Floating point versions are also available for CMSIS-DSP.

## CMSIS-DSP

### CMSIS-DSP Library

### Introduction

This topic describes the CMSIS-DSP Library.

### Description

The Cortex Microcontroller System Interface Standard-DSP (CMSIS-DSP) Library is the ARM® DSP Math Library integrated with MPLAB Harmony. It can only be used for ARM Cortex cores M0 through M7.

The CMSIS-DSP Library contains functions implementing 16-bit (Q15) and 32-bit (Q31) fixed-point math, as well as 32-bit floating point (F32) math.

Functions included in the CMSIS-DSP Library include complex math, vector math, matrix math, digital filters, adaptive filters, control and transforms. In many cases, these functions require specific data structures to operate, which are detailed in the header file.

### Using the Library

This topic describes the basic architecture of the CMSIS-DSP Library and provides information and examples on its use.

### Description

**Interface Header File:** **arm\_math.h**

The interface to the DSP Fixed-Point library is defined in the arm\_math.h header file. Any C language source (.c) file that uses the DSP Fixed-Point library must include arm\_math.h.

### Library Source Files

The CMSIS-DSP Library source files are provided in the dev\_packs repo under:

packs\\arm\\CMSIS&lt;Version Number\>\\CMSIS\\DSP\\Source

The source is not generated to the Harmony 3 project but will give the implementation details and the ability to rebuild the library.

### Library Files

The CMSIS-DSP Library archive file is generated by MHC to the following project directory:

firmware\\src\\packs\\CMSIS\\CMSIS\\DSP\\Lib\\GCC

The following prebuilt versions of the library are available:

libarm\_cortexM0l\_math.a

libarm\_cortexM3l\_math.a

libarm\_cortexM4l\_math.a

libarm\_cortexM4lf\_math.a

libarm\_cortexM7l\_math.a

libarm\_cortexM7lfdp\_math.a

libarm\_cortexM7lfsp\_math.a

The naming convention is as follows:

libarm\_<ARM,cortex\><core\><codes\>\_math.a

The cores are: M0,M3,M4, or M7,

The codes are as follows:

<l,b\> - little or big endian byte order

<dp,sp\> – double or single precision

<f\> - Floating Point Unit on

### Configuring the Library using MHC

Provides information on using MPLAB Harmony Configurator (MHC) to configure the library.

### Description

The library can be generated by the MPLAB Harmony Configurator to any MPLAB® Harmony 3 project that has the CMSIS Pack component, i.e. only MPLAB® Harmony 3 projects that target ARM processors. Select the CMSIS Pack component highlighted in from the Project Graph.

The Configuration Options window looks like the following, with the selection for the CMSIS-DSP Library

The speed optimized library for the given processor will be generated to the project.

### Library Overview

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the CMSIS-DSP Library.

### Library Interface

### Section

### Description

**Basic Math Functions**

Basic vector math functions.

**Fast Math Functions**

This set of functions provides a fast approximation to sine, cosine, and square root.

**Complex Math Functions**

This set of functions operates on complex data vectors. The data in the complex arrays is stored in an interleaved fashion (real, imaginary, real, imaginary, ...). In the API functions, the number of samples in a complex array refers to the number of complex values; the array contains twice this number of real values.

**Filter**

Implementation of biquad cascade, IIR Direct Form I and II Transposed, convolution, correlation, FIR, IIR Lattice, LMS, and Normalized LMS filter functions

**Matrix Functions**

This set of functions provides basic matrix math operations. The functions operate on matrix data structures.

**Transforms**

FFT, DCT Type IV, and Real FFT functions.

**Statistical Functions**

Maximum, Minimum, Mean, Power, RMS, Standard Deviation and Variance calculations.

**Support Functions**

Vector Copy, Vector Fill, and conversion between F32, Q15, Q32 and Q7 values.

**Interpolation Functions**

Linear and Bilinear interpolation functions.

**Motor Control Functions**

PID Motor Control and Vector Clark, Vector Park, and Vector Inverse

The CMSIS-DSP Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.

Floating point versions of the function are also available.

### Library Interface

Provides information on the list of available functions and interfaces.

### Description

Documentation of the available CMSIS-DSP Library functions and interfaces and their descriptions can be found at:

https://arm-software.github.io/CMSIS\_5/DSP/html/modules.html

## DSP

### DSP Fixed-Point Math Libraries

### Introduction

This topic describes the DSP Fixed-Point Math Libraries.

### Description

The DSP Fixed-Point Library are available for the PIC32MZ family of microcontrollers. This library was created from optimized assembly routines written specifically for devices with microAptiv™ core features that utilize DSP ASE.

\_ **The LIBQ library is required to use the DSP library.** \_

The DSP Fixed-Point Library contains building block functions for developing digital signal processing algorithms. The library supports the Q15 and Q31 fractional data formats. The functions are implemented in efficient assembly specifically targeted at the DSP extensions in this core family.

The library makes these functions available in a simple C-callable structure.

Functions included in the DSP Fixed-Point Library include complex math, vector math, matrix math, digital filters, and transforms.

In many cases, these functions require specific data structures to operate, which are detailed in the header file and examples.

**Using the Library**

This topic describes the basic architecture of the DSP Fixed-Point Library and provides information and examples on its use.

### Description

**Interface Header File:** **dsp.h,**

The interface to the DSP Fixed-Point library is defined in the dsp.h header file. Any C language source (.c) file that uses the DSP

Fixed-Point library must include dsp.h. This file is automatically included by definitions.h when the library is generated using MHC.

Some functions make special use of the optimized fixed-point math library libq.h. For use of those functions, the libq.h file must also be included in a project. The libq.h file is also installed with MPLAB Harmony. Specific notes within each function will describe if the function is dependent on the LibQ Fixed-Point Math Library.

Library Files:

The DSP Fixed-Point library archive (.a) files are installed with MPLAB Harmony. Although there are two PIC32 DSP files, the linker will only utilize one of these depending on your device usage.

This library is only available in prebuilt binary form, with prototypes for each function described in the dsp.h file. The available

library versions are:

• dsp\_mips32\_mz\_ef\_nfO3.a

• dsp\_mips32\_mz\_ef\_nfOs.a

The naming convention for these libraries is as follows:

<name\>*<arch\>*<core\>*<fpu\>*<codes\>.a

where, "name" is the name of the library (DSP); "arch" is the 32 MIPS architecture (MIPS32); "core" is the microAptive core with

DSP ASE extensions (MZ); and "fpu" indicates that a Floating Point Unit(FPU) is available. The "codes" are as follows:

• <nf, fpu\> - FPU disabled or enabled

• <O3,OS\> - Fully optimized for speed or optimized for size.

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq\_c, libq/dsp libraries.

The project configuration should now contain the Math Libraries block.

Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.

NOTE: LIBQ is also required to be selected.

### Library Overview

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the

DSP Fixed-Point Math Library.

**Library Interface Section Description**

**Complex Math Functions**

General mathematical operations using a complex structure with the form (a + bi)

**Vector Math Functions**

Mathematical operations on a array of numbers or vector

**Matrix Math Functions**

Mathematical operations on a matrix

**Digital Filter Functions**

FIR and IIR filtering functions with various architectures

**Transform Functions**

FFT, Windows and related transform elements

**Support Functions**

Quick support functions for numerical transform

The DSP Fixed-Point Library uses fixed-point fractional functions to optimize execution speed. These functions limit the accuracy of the calculations to the bits specified for the function. Due to parallelism in some operations, the 16-bit version of the functions are more efficient than their 32-bit counterparts. In many cases both 16-bit and 32-bit functions are available to give the user the choice of balance between speed and functional resolution.

A majority of the DSP Fixed-Point Library uses functions with variables in Q15 or Q31 format. Representations of these numbers are given in **Data Types and Constants** in the Library Interface section, and generally are int16\_t (for Q15 fractional representation) and int32\_t (for Q31 fractional representation). This limits the equivalent numerical range to roughly -1.0 to 0.999999999. It is possible to represent other number ranges, but scaling before and after the function call are necessary.

All library functions will saturate the output if the value exceeds the maximum or is lower than the minimum allowable value for that resolution.

Some prescaling may be necessary to prevent unwanted saturation in functions that may otherwise create calculation errors.

### Library Interface

**Functions**

**Name Description**

DSP\_ComplexAdd32 Calculates the sum of two complex numbers.

DSP\_ComplexConj16 Calculates the complex conjugate of a complex number.

DSP\_ComplexConj32 Calculates the complex conjugate of a complex number.

DSP\_ComplexDotProd32 Calculates the dot product of two complex numbers.

DSP\_ComplexMult32 Multiplies two complex numbers.

DSP\_ComplexScalarMult32 Multiplies a complex number and a scalar number.

DSP\_ComplexSub32 Calculates the difference of two complex numbers.

DSP\_FilterFIR32 Performs a Finite Infinite Response (FIR) filter on a vector.

DSP\_FilterFIRDecim32 Performs a decimating FIR filter on the input array.

DSP\_FilterFIRInterp32 Performs an interpolating FIR filter on the input array.

DSP\_FilterIIR16 Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.

DSP\_FilterIIRBQ16 Performs a single-pass IIR Biquad Filter.

DSP\_FilterIIRBQ16\_cascade8 Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

DSP\_FilterIIRBQ16\_cascade8\_fast Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

DSP\_FilterIIRBQ16\_fast Performs a single-pass IIR Biquad Filter.

DSP\_FilterIIRBQ16\_parallel8 Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

DSP\_FilterIIRBQ16\_parallel8\_fast Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

DSP\_FilterIIRBQ32 Performs a high resolution single-pass IIR Biquad Filter.

DSP\_FilterIIRSetup16 Converts biquad structure to coeffs array to set up IIR filter.

DSP\_FilterLMS16 Performs a single sample Least Mean Squares FIR Filter.

DSP\_MatrixAdd32 Addition of two matrices C = (A + B).

DSP\_MatrixEqual32 Equality of two matrices C = (A).

DSP\_MatrixInit32 Initializes the first N elements of a Matrix to the value num.

DSP\_MatrixMul32 Multiplication of two matrices C = A x B.

DSP\_MatrixScale32 Scales each element of an input buffer (matrix) by a fixed number.

DSP\_MatrixSub32 Subtraction of two matrices C = (A - B).

DSP\_MatrixTranspose32 Transpose of a Matrix C = A (T).

DSP\_TransformFFT16 Creates an Fast Fourier Transform (FFT) from a time domain input.

DSP\_TransformFFT16\_setup Creates FFT coefficients for use in the FFT16 function.

DSP\_TransformFFT32 Creates an Fast Fourier Transform (FFT) from a time domain input.

DSP\_TransformFFT32\_setup Creates FFT coefficients for use in the FFT32 function.

DSP\_TransformIFFT16 Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.

DSP\_TransformWindow\_Bart16 Perform a Bartlett window on a vector.

DSP\_TransformWindow\_Bart32 Perform a Bartlett window on a vector.

DSP\_TransformWindow\_Black16 Perform a Blackman window on a vector.

DSP\_TransformWindow\_Black32 Perform a Blackman window on a vector.

DSP\_TransformWindow\_Cosine16 Perform a Cosine (Sine) window on a vector.

DSP\_TransformWindow\_Cosine32 Perform a Cosine (Sine) window on a vector.

DSP\_TransformWindow\_Hamm16 Perform a Hamming window on a vector.

DSP\_TransformWindow\_Hamm32 Perform a Hamming window on a vector.

DSP\_TransformWindow\_Hann16 Perform a Hanning window on a vector.

DSP\_TransformWindow\_Hann32 Perform a Hanning window on a vector.

DSP\_TransformWindow\_Kaiser16 Perform a Kaiser window on a vector.

DSP\_TransformWindow\_Kaiser32 Perform a Kaiser window on a vector.

DSP\_TransformWinInit\_Bart16 Create a Bartlett window.

DSP\_TransformWinInit\_Bart32 Create a Bartlett window.

DSP\_TransformWinInit\_Black16 Create a Blackman window.

DSP\_TransformWinInit\_Black32 Create a Blackman window.

DSP\_TransformWinInit\_Cosine16 Create a Cosine (Sine) window.

DSP\_TransformWinInit\_Cosine32 Create a Cosine (Sine) window.

DSP\_TransformWinInit\_Hamm16 Create a Hamming window.

DSP\_TransformWinInit\_Hamm32 Create a Hamming window.

DSP\_TransformWinInit\_Hann16 Create a Hanning window.

DSP\_TransformWinInit\_Hann32 Create a Hanning window.

DSP\_TransformWinInit\_Kaiser16 Create a Kaiser window.

DSP\_TransformWinInit\_Kaiser32 Create a Kaiser window.

DSP\_VectorAbs16 Calculate the absolute value of a vector.

DSP\_VectorAbs32 Calculate the absolute value of a vector.

DSP\_VectorAdd16 Calculate the sum of two vectors.

DSP\_VectorAdd32 Calculate the sum of two vectors.

DSP\_VectorAddc16 Calculate the sum of a vector and a constant.

DSP\_VectorAddc32 Calculate the sum of a vector and a constant.

DSP\_VectorAutocorr16 Computes the Autocorrelation of a Vector.

DSP\_VectorBexp16 Computes the maximum binary exponent of a vector.

DSP\_VectorBexp32 Computes the maximum binary exponent of a vector.

DSP\_VectorChkEqu32 Compares two input vectors, returns an integer 1 if equal, and 0 if not equal.

DSP\_VectorCopy Copies the elements of one vector to another.

DSP\_VectorCopyReverse32 Reverses the order of elements in one vector and copies them into another.

DSP\_VectorDivC Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.

DSP\_VectorDotp16 Computes the dot product of two vectors, and scales the output by a binary factor.

DSP\_VectorDotp32 Computes the dot product of two vectors, and scales the output by a binary factor

DSP\_VectorExp Computes the EXP (e^x) of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorFill Fills an input vector with scalar data.

DSP\_VectorLn Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorLog10 Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorLog2 Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorMax32 Returns the maximum value of a vector.

DSP\_VectorMaxIndex32 Returns the index of the maximum value of a vector.

DSP\_VectorMean32 Calculates the mean average of an input vector.

DSP\_VectorMin32 Returns the minimum value of a vector.

DSP\_VectorMinIndex32 Returns the index of the minimum value of a vector.

DSP\_VectorMul16 Multiplication of a series of numbers in one vector to another vector.

DSP\_VectorMul32 Multiplication of a series of numbers in one vector to another vector.

DSP\_VectorMulc16 Multiplication of a series of numbers in one vector to a scalar value.

DSP\_VectorMulc32 Multiplication of a series of numbers in one vector to a scalar value.

DSP\_VectorNegate Inverses the sign (negates) the elements of a vector.

DSP\_VectorRecip Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorRMS16 Computes the root mean square (RMS) value of a vector.

DSP\_VectorShift Shifts the data index of an input data vector.

DSP\_VectorSqrt Computes the square root of the first N elements of inVector, and stores the result in outVector.

DSP\_VectorStdDev16 Computes the Standard Deviation of a Vector.

DSP\_VectorSub16 Calculate the difference of two vectors.

DSP\_VectorSub32 Calculate the difference of two vectors.

DSP\_VectorSumSquares16 Computes the sum of squares of a vector, and scales the output by a binary factor.

DSP\_VectorSumSquares32 Computes the sum of squares of a vector, and scales the output by a binary factor.

DSP\_VectorVari16 Computes the variance of N elements of a Vector.

DSP\_VectorVariance Computes the variance of N elements of inVector.

DSP\_VectorZeroPad Fills an input vector with zeros.

mul16 multiply and shift integer

mul16r multiply and shift Q15

mul32 multiply and shift Q31

SAT16 saturate both positive and negative Q15

SAT16N saturate negative Q15

SAT16P saturate positive Q15

**Description**

\_ **Functions** \_

**DSP\_ComplexAdd32 Function**

Calculates the sum of two complex numbers.

**Description**

Function DSP\_ComplexAdd32:

void DSP\_ComplexAdd32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the sum of two complex numbers, indata1 and indata2, and stores the complex result in Output. Complex numbers must be in the structural form that includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. All values are in Q31 fractional data format. (a + bi) + (c + di) =\> (a + c) + (b + d)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

int32c test\_complex\_2 = \{0x73333333,0xB3333334\};

*// (0.9 - 0.6i)*

res=&result;

input1=&test\_complex\_1;

input2=&test\_complex\_2;

DSP\_ComplexAdd32(input1, input2, res);

*// result = \{0x73333333, 0xC0000000\} = (0.9 - 0.5i)*

**C**

**void** **DSP\_ComplexAdd32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP\_ComplexConj16 Function**

Calculates the complex conjugate of a complex number.

**Description**

DSP\_ComplexConj16:

void DSP\_ComplexConj16(int16c \*indata, int16c \*Output);

CCalculates the complex conjugate of Indata, and stores the result in Outdata. Both numbers must be in the complex number data structure which includes real and imaginary components. Values are in Q15 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =\> (a - bi)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata pointer to input complex number (int16c)

**Returns**

pointer to result complex numbers (int16c)

None.

**Remarks**

None.

**Example**

int16c \*res, result;

int16c \*input1;

int16c test\_complex\_1 = \{0x4000,0x0CCC\};

*// (0.5 + 0.1i)*

res=&result;

input1=&test\_complex\_1;

DSP\_ComplexConj16(input1, res);

*// result = \{0x4000, 0xF334\} = (0.5 - 0.1i)*

**C**

**void** **DSP\_ComplexConj16** (int16c \* **indata** , int16c \* **Output** );

**DSP\_ComplexConj32 Function**

Calculates the complex conjugate of a complex number.

**Description**

Function DSP\_ComplexConj32:

void DSP\_ComplexConj32(int32c \*indata, int32c \*Output);

Calculates the complex conjugate of indata, and stores the result in Output. Both numbers must be in the complex number data structure, which includes real and imaginary components. Values are in Q31 fractional data format. The function will saturate the output if maximum or minimum values are exceeded. (a + bi) =\> (a - bi)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1;

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

res=&result;

input1=&test\_complex\_1;

DSP\_ComplexConj32(input1, res);

*// result = \{0x40000000, 0xF3333334\} = (0.5 - 0.1i)*

**C**

**void** **DSP\_ComplexConj32** (int32c \* **indata** , int32c \* **Output** );

**DSP\_ComplexDotProd32 Function**

Calculates the dot product of two complex numbers.

**Description**

Function DSP\_ComplexDotProd32:

void DSP\_ComplexDotProd32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the dot product of two complex numbers, indata1 and indata2, and stores the result in Output. All numbers must be in complex structural format that includes real and imaginary components, and the numbers are in fractional Q31 format. The function will saturate the output if it exceeds maximum or minimum ratings. The formula for the dot product is as follows:

Output(real) = (Input1.re \* Input2.re) + (Input1.im \* Input2.im); Output(img) = i (a +

bi) dot (c + di) =\> (a \* c + b \* d) + (a \* d - b \* c)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

int32c test\_complex\_2 = \{0x73333333,0xB3333334\};

*// (0.9 - 0.6i)*

res=&result;

input1=&test\_complex\_1;

input2=&test\_complex\_2;

DSP\_ComplexDotProd32(input1, input2, res);

*// result = \{0x31EB851E, 0xCE147AE3\} = (0.39 - 0.39i)*

**C**

**void** **DSP\_ComplexDotProd32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP\_ComplexMult32 Function**

Multiplies two complex numbers.

**Description**

Function DSP\_ComplexMult32:

void DSP\_ComplexMult32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Multiplies two complex numbers, indata1 and indata2, and stores the complex result in Output. All numbers must be in the int32c complex data structure. All data is in Q31 fractional format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re \* Input2.re) - (Input1.im \* Input2.im); Output(img) = \[(Input1.re \* Input2.im) + (Input1.im \*

Input2.re)\]i (a + bi) x (c + di) =\> (a \* c - b \* d) + (a \* d + b \* c)i

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

int32c test\_complex\_2 = \{0x73333333,0xB3333334\};

*// (0.9 - 0.6i)*

res=&result;

input1=&test\_complex\_1;

input2=&test\_complex\_2;

DSP\_ComplexMult32(input1, input2, res);

*// result = \{0x4147AE14, 0xE51EB8551\} = (0.51 - 0.21i)*

**C**

**void** **DSP\_ComplexMult32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP\_ComplexScalarMult32 Function**

Multiplies a complex number and a scalar number.

**Description**

Function DSP\_ComplexScalarMult32:

void DSP\_ComplexScalarMult32(int32c \*indata, int32\_t Scalar, int32c \*Output);

Multiplies a complex number, indata, by a scalar number, Scalar, and stores the result in Output. indata and Output must be in

int32c structure with real and imaginary components. All data must be in the fractional Q31 format. The function will saturate if maximum or minimum values are exceeded. Output(real) = (Input1.re \* Scalar); Output(img) = i (a + bi) \* C =\>

(a \* C + b \* Ci)

**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata pointer to input complex number (int32c)

Scalar fractional scalar input value (int32\_t)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1;

int32\_t scalarInput = 0x20000000; *// 0.25*

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

res=&result;

input1=&test\_complex\_1;

DSP\_ComplexScalarMult32(input1, scalarInput, res);

*// result = \{0x10000000, 0x03333333\} = (0.125 + 0.025i)*

**C**

**void** **DSP\_ComplexScalarMult32** (int32c \* **indata** , int32\_t **Scalar** , int32c \* **Output** );

**DSP\_ComplexSub32 Function**

Calculates the difference of two complex numbers.

**Description**

Function DSP\_ComplexSub32:

void DSP\_ComplexSub32(int32c \*indata1, int32c \*indata2, int32c \*Output);

Calculates the difference of two complex numbers, indata1 less indata2, and stores the complex result in Output. Both numbers must be in a complex data structure, which includes real and imaginary components. The function saturates the output values if maximum or minimum are exceeded. Real and imaginary components are in the Q31 fractional data format. (a + bi) - (c + di) =\> (a

-   c) + (b - d)i


**Preconditions**

Complex numbers must be in the int32c format.

**Parameters**

**Parameters Description**

indata1 pointer to input complex number (int32c)

indata2 pointer to input complex number (int32c)

**Returns**

pointer to result complex numbers (int32c)

None.

**Remarks**

None.

**Example**

int32c \*res, result;

int32c \*input1, \*input2;

int32c test\_complex\_1 = \{0x40000000,0x0CCCCCCC\};

*// (0.5 + 0.1i)*

int32c test\_complex\_2 = \{0x73333333,0xB3333334\};

*// (0.9 - 0.6i)*

res=&result;

input1=&test\_complex\_1;

input2=&test\_complex\_2;

DSP\_ComplexSub32(input1, input2, res);

*// result = \{0xCCCCCCCD, 0x59999998\} = (-0.4 + 0.7i)*

**C**

**void** **DSP\_ComplexSub32** (int32c \* **indata1** , int32c \* **indata2** , int32c \* **Output** );

**DSP\_FilterFIR32 Function**

Performs a Finite Infinite Response (FIR) filter on a vector.

**Description**

Function DSP\_FilterFIR32:

void DSP\_FilterFIR32(int32\_t \*outdata, int32\_t \*indata, int32\_t \*coeffs2x, int32\_t \*delayline, int N, int K, int scale);

Performs an FIR filter on the vector indata, and stores the output in the vector outdata. The number of samples processed in the array is given by N. The number of filter taps is given by K. The values are scaled upon input by the binary scaling factor (right shift), scale. The array of 2\*K coefficients is contained in the array coeffs2x, where the values are in order b0, b1, b2... and repeated. Lastly the delayline is an array of K values that are initialized to zero and represent previous values. All values are in fractional Q31 data format. The function will saturate results if minimum or maximum values are exceeded.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four. K must be greater than 2 and a multiple of 2. delayline must have K elements, and be initialized to zero. coeffs2x must have 2\*K elements.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32\_t)

indata pointer to source array of elements (int32\_t)

coeffs2x pointer to an array of coefficients (int32\_t)

delayline pointer to an array of delay variables (int32\_t)

N number of points in the array to process (int) number of samples (int)

K number of filter taps

scale binary scaler divisor (1 / 2^scale) (int)

**Returns**

None.

**Remarks**

Filter coefs must be repeated within the array. The array is twice as large as the number of taps, and the values are repeated in order b0, b1, b2,...bn, b0, b1, b2,... bn. The function updates the delayline array, which must be K elements long. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.

**Example**

**\#define** TAPS 4

**\#define** numPOINTS 256

int filterN = numPOINTS;

int filterK = TAPS;

int filterScale = 1; *// scale output by 1/2^1 =\> output \* 0.5*

int32\_t FilterCoefs = \{0x40000000, 0x20000000, 0x20000000, 0x20000000,

0x40000000, 0x20000000, 0x20000000, 0x20000000\};

*// note repeated filter coefs, A B C D A B C D*

*// 0.5, 0.25, 0.25, 0.25, 0.5, 0.25, 0.25, 0.25*

int32\_t outFilterData=\{0\};

int32\_t inFilterData;

int filterDelayLine=\{0\};

while ( **true** )

\{

*// put some data into input array, inFilterData, here //*

DSP\_FilterFIR32(outFilterData, inFilterData, FilterCoefs, filterDelayLine,

filterN, filterK, filterScale);

\}

**C**

**void** **DSP\_FilterFIR32** (int32\_t \* **outdata** , int32\_t \* **indata** , int32\_t \* **coeffs2x** , int32\_t \*

**delayline** , int **N** , int **K** , int **scale** );

**DSP\_FilterFIRDecim32 Function**

Performs a decimating FIR filter on the input array.

**Description**

Function DSP\_FilterFIRDecim32:

void DSP\_FilterFIRDecim32(int32\_t \*outdata, int32\_t \*indata, int32\_t \*coeffs, int32\_t \*delayline, int N, int K, int scale, int rate);

Compute a FIR decimation filter on the input vector indata, and store the results to the vector outdata. The total number of output elements is set by N, and therefore the outdata array must be at least N in length. The decimation ratio is given by rate. The input is sampled every integer value of rate, skipping every (rate-1) input samples. The input array must therefore be (rate\*N) samples long. The amount of filter taps is specified by K. Coeffs specifies the coefficients array. The delayline array holds delay inputs for calculation, and must be initialized to zero prior to calling the filter. Both coeffs and delayline must be K in length. Scale divides the input by a scaling factor by right shifting the number of bits (1/2^scale). All values of input, output, and coeffs are given in Q31 fractional data format. The function will saturate if the output value exceeds the maximum or minimum value.

Y = b0 \* X0 + (b1 \* X(-1)) + (b2 \* X(-2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have K elements, and be initialized to zero.

coeffs must have K elements. outdata must have N elements indata must have (N\*rate) elements

**Parameters**

**Parameters Description**

outdata pointer to output array of elements (int32\_t)

indata pointer to input array of elements (int32\_t)

coeffs pointer to an array of coefficients (int32\_t)

delayline pointer to an array of delay variables (int32\_t)

N number of output elements to be processed (int)

K number of filter taps and coeffs (int)

scale binary scaler divisor (1 / 2^scale) (int)

rate decimation ratio (int)

**Returns**

None.

**Remarks**

Coefs are loaded into the array with corresponding to the least delay first (C0, C(-1), C(-2)). K must be greater than rate. Even while decimating the input stream, every input passes through the delayline. So FIR filters of arbitrary length will give the same

output as a non-decimating FIR, just with fewer responses.

**Example**

**\#define** N 8 *// number of output samples*

**\#define** TAPS 5

**\#define** SKIP 3

int testFilterN = N; *// number of output elements*

int testFilterK = TAPS; *// number of taps*

int testFilterRate = SKIP; *// decimation rate R*

int32\_t outFiltDataDec=\{0\};

int32\_t \*inTestFilter;

int filtScaleNum = 1; *// scale output (1 /2^n) =\> Y \* 0.5*

int32\_t filtDelayTest=\{0\}; *// always initialize to zero*

*// get pointer to input buffer here //*

inTestFilter = &inputBuffer;

DSP\_FilterFIRDecim32(outFiltDataDec, inTestFilter, inTestCoefs,

filtDelayTest, testFilterN, testFilterK, filtScaleNum, testFilterRate);

**C**

**void** **DSP\_FilterFIRDecim32** (int32\_t \* **outdata** , int32\_t \* **indata** , int32\_t \* **coeffs** , int32\_t \*

**delayline** , int **N** , int **K** , int **scale** , int **rate** );

**DSP\_FilterFIRInterp32 Function**

Performs an interpolating FIR filter on the input array.

**Description**

Function DSP\_FilterFIRInterp32:

void DSP\_FilterFIRInterp32(int32\_t \*outdata, int32\_t \*indata, int32\_t \*coeffs, int32\_t \*delayline, int N, int K, int scale, int rate);

Perform an interpolating FIR filter on the first N samples of indata, and stores the result in outdata. The number of output elements is N\*rate. The number of filter taps, K, must be an even multiple of N. The coefficients array, Coeffs, must be K elements long. The delay line array, delayline, must be K/R elements long, and be initialized to zero. All data elements must be in Q31 fractional data format. Scaling is performed via binary shift on the input equivalent to (1/2^shift). The function will saturate the output if it exceeds maximum or minimum values. The function creates R output values for each input value processed. The delayline of previous values is processed with R elements of the coefficient array. Numerically:

Y(1,0) = X(0)\*C(0) + X(-1)\*C(rate) + X(-2)*C(2*rate) ... Y(1,1) = X(0)\*C(1) + X(-1)\*C(rate+1) + X(-2)*C(2*rate + 1) ... Y(1,rate) =

X(0)\*C(N) + X(-1)\*C(rate+N) + X(-2)*C(2*rate + N) ...

where output Y corresponds to (input,rate) different outputs, input X has (M/rate) sample delays and C is the coefficient array.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K/R) elements, and be initialized to zero. K (taps) must be an even multiple of R (rate). outdata must have R\*N elements.

**Parameters**

**Parameters Description**

outdata pointer to output array of elements (int32\_t)

indata pointer to input array of elements (int32\_t)

coeffs pointer to an array of coefficients (int32\_t)

delayline pointer to an array of delay variables (int32\_t)

N number of output elements to be processed (int)

K number of filter taps and coeffs (int)

scale binary scaler divisor (1 / 2^scale) (int)

rate decimation ratio (int)

**Returns**

None.

**Remarks**

The function processes each input (rate) times. With each pass, coefficients are offset so that (K/rate) multiply accumulate cycles

occur.

**Example**

*// interpret evenly 1/3 spaced values*

**\#define** N 4 *// number of output samples*

**\#define** TAPS 6

**\#define** INTERP 3

int ifiltN = N;

int ifiltK = TAPS; *// k must be an even multiple of R*

int ifiltR = INTERP;

int32\_t ifiltOut=\{0\};

int32\_t ifiltDelay=\{0\}; *// must be initialized to zero*

int ifiltScale = 0; *// no scaling*

int32\_t ifiltCoefsThirds=\{0x2AAAAAA9, 0x55555555,0x7FFFFFFE,

0x55555555,0x2AAAAAA9,0x00000000\};

*// 0.333333, 0.6666667, 0.99999999, 0.6666667, 0.33333333, 0*

int32\_t ifiltInput=\{0x0CCCCCCD, 0x19999999, 0x26666666, 0x33333333\};

*// 0.1, 0.2, 0.3, 0.4*

DSP\_FilterFIRInterp32(ifiltOut, ifiltInput, ifiltCoefsThirds, ifiltDelay,

ifiltN, ifiltK, ifiltScale, ifiltR);

*// ifiltOut = \{0x04444444, 0x08888889, 0x0CCCCCCD, 0x11111111, 0x15555555, 0x19999999,*

*// 0x1DDDDDDD, 0x22222221, 0x26666665, 0x2AAAAAAA,0x2EEEEEEE, 0x33333332\}*

*// = 0.0333, 0.0667, 0.1, 0.1333, 0.1667, 0.2, 0.2333, 0.2667, 0.3, 0.3333, 0.3667, 0.4*

**C**

**void** **DSP\_FilterFIRInterp32** (int32\_t \* **outdata** , int32\_t \* **indata** , int32\_t \* **coeffs** , int32\_t \*

**delayline** , int **N** , int **K** , int **scale** , int **rate** );

**DSP\_FilterIIR16 Function**

Performs a single-sample cascaded biquad Infinite Impulse Response (IIR) filter.

**Description**

Function DSP\_FilterIIR16:

int16\_t DSP\_FilterIIR16(int16\_t in, int16\_t \*coeffs, int16\_t \*delayline, int B, int scale);

Performs a single element cascaded biquad IIR filter on the input, in. The filter contains B number of biquad sections, and cascades the output of one to the input of the next. B must be greater than 2 and a multiple of 2. The int16\_t output generated by the function is the computation from the final biquad stage. Delay pipeline array delayline must contain 2*B values and be initialized to zero prior to use. The coefficient array must contain 4*B elements, and must be set up in order of biquad a1, a2, b1, b2. A binary (right shift) factor, scale, will scale the output equivalent to (1/2^scale). All numerical values must be in Q15 fractional data format. The function will saturate values if maximum or minimum values are exceeded.

Y = X0 + (b1 \* X(-1)) + (b2 \* X(-2) + (a1 \* Y(-1)) + (a2 \* Y(-2))

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. B must be greater than 2 and a multiple of 2. delayline

must have 2*B elements, and be initialized to zero. coeffs must have 4*B elements.

**Parameters**

**Parameters Description**

in input data element X (int16\_t)

coeffs pointer to an array of coefficients (int16\_t)

delayline pointer to an array of delay variables (int16\_t)

B number of cascaded biquad filter groups to process (int)

scale binary scaler divisor (1 / 2^scale) (int)

**Returns**

Sample output Y (int16\_t)

**Example**

**\#define** B 8 *// use \* biquad filters in cascade*

int dataSamples = 256;

int i, j;

biquad16 bquad;

int16\_t coefs= \{0\};

int16\_t delaylines= \{0\};

int16\_t Y, X;

int scaleBquad = 1; *// scale output (1 /2^n) =\> Y \* 0.5*

*// do something to set up coefs, for instance this example //*

for (j=0; jRemarks:Filter coefs must be stored within the array as a1, a2, b1, b2, a1, a2, b1, b2, in order of biquads form input to output. A function to translate the coeffs from biquad structure to coeffs is available in DSP\_FilterIIRSetup16. The function updates the delayline array, which must be 2\*B elements **long**. The array should be initialized to zero prior to the first processing. It will contain values for processing cascaded filters within a loop.

**C**

int16\_t **DSP\_FilterIIR16** (int16\_t **in** , int16\_t \* **coeffs** , int16\_t \* **delayline** , int **B** , int **scale** );

**DSP\_FilterIIRBQ16 Function**

Performs a single-pass IIR Biquad Filter.

**Description**

Function DSP\_FilterIIRBQ16:

int16\_t DSP\_FilterIIRBQ16(int16\_t Xin, PARM\_EQUAL\_FILTER \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.

All values are fractional Q15 and Q31, see data structure for specifics.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER \*ptrFilterEQ;

PARM\_EQUAL\_FILTER FilterEQ;

uint16\_t DataIn, DataOut;

ptrFilterEQ = &FilterEQ;

*// 48KHz sampling; 1 KHz bandpass filter; Q=0.9*

*// divide by 2 and convert to Q15*

*// b0 = 0.06761171785499065*

*// b1 = 0*

*// b2 = -0.06761171785499065*

*// a1 = -1.848823142275648*

*// a2 = 0.8647765642900187*

*// note all coefs are half value of original design, gain handled in algorithm*

ptrFiltEQ32-\>b=0x0453; *// feed forward b0 coef*

ptrFiltEQ32-\>b=0; *// feed forward b1 coef*

ptrFiltEQ32-\>b=0xFBAD; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

ptrFiltEQ32-\>a=0x89AD; *// feedback a1 coef*

ptrFiltEQ32-\>a=0x3758; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get some input data here*

DataIn32 = three\_hundred\_hz;

DataOut = DSP\_FilterIIRBQ16(DataIn, ptrFilterEQ);

*// \*\*\* do something with the DataOut here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16** (int16\_t **Xin** , PARM\_EQUAL\_FILTER \* **pFilter** );

**DSP\_FilterIIRBQ16\_cascade8 Function**

Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

**Description**

Function DSP\_FilterIIRBQ16\_cascade8:

int16\_t DSP\_FilterIIRBQ16\_cascade8(int16\_t Xin, PARM\_EQUAL\_FILTER \*pFilter\_Array);

Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 32 bit delay lines are maintained for each. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. Global gain values are available on the output. Fracgain is a Q15 fractional gain value and expgain is a binary shift gain value. The combination of the two can be utilized to normalize the output as desired. All values are fractional Q15 and Q31, see data structure for specifics.

Y = Y7 <- Y6 <- Y5 <- Y4 <- Y3 <- Y2 <- Y1 <- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)\*b0 +

(b1 \* Y(n-2)) + (b2 \* Y(n-3)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2)) and: for Y0; Y(n-1) = Xin(0)

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER filtArray;

uint16\_t dataY, dataX;

*// example to use 2 filter blocks as notch filters*

*// fill entire Filter Array with coefs*

for (i=0;i<8;i++)

\{

filtArray.Z=0;

filtArray.Z=0;

*// note all coefs are half value of original design, gain handled in algorithm*

*// all pass*

filtArray.b=0x4000;

filtArray.b=0; *// feed forward b1 coef*

filtArray.b=0; *// feed forward b2 coef*

filtArray.a=0; *// feedback a1 coef*

filtArray.a=0; *// feedback a2 coef*

\}

*// Unique filters for example*

*// 10KHz notch filter -- divide coefs by 2*

b0 = 0.5883783602332997

b1 = -0.17124071441396285

b2 = 0.5883783602332997

a1 = -0.17124071441396285

a2 = 0.1767567204665992

*// note all coefs are half value of original design, gain handled in algorithm*

filtArray.b=0x25a7; *// feed forward b0 coef*

filtArray.b=0xf508; *// feed forward b1 coef*

filtArray.b=0x25a7; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArray.a=0xf508; *// feedback a1 coef*

filtArray.a=0x0b4f; *// feedback a2 coef*

*// 1 KHz notch filter -- divide coefs by 2*

b0 = 0.9087554064944908

b1 = -1.7990948352036205

b2 = 0.9087554064944908

a1 = -1.7990948352036205

a2 = 0.8175108129889816

*// note all coefs are half value of original design, gain handled in algorithm*

filtArray.b=0x3a29; *// feed forward b0 coef*

filtArray.b=0x8cdc; *// feed forward b1 coef*

filtArray.b=0x3a29; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArray.a=0x8cdc; *// feedback a1 coef*

filtArray.a=0x3452; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get input data here*

dataX = compound\_300\_1K\_hz16;

dataY = DSP\_FilterIIRBQ16\_cascade8(dataX, filtArray);

*// \*\*\* do something with the DataY here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16\_cascade8** (int16\_t **Xin** , PARM\_EQUAL\_FILTER \* **pFilter\_Array** );

**DSP\_FilterIIRBQ16\_cascade8\_fast Function**

Performs a single-sample IIR Biquad Filter as a cascade of 8 series filters.

**Description**

Function DSP\_FilterIIRBQ16\_cascade8\_fast:

int16\_t DSP\_FilterIIRBQ16\_cascade8\_fast(int16\_t Xin, PARM\_EQUAL\_FILTER\_16 \*pFilter\_Array);

Calculates a single pass IIR biquad cascade filter on Xin, and delivers the result as a 16-bit output. The cascade of filters is 8 unique biquad filters arranged in series such that the output of one is provided as the input to the next. A unique filter coefficient set is provided to each, and 16 bit delay lines are maintained for each. All math is performed using 16 bit instructions, which results rounded to 16-bits for the output. All values are fractional Q15, see data structure for specifics. The function will saturate the output should it exceed maximum or minimum values.

Y = Y7 <- Y6 <- Y5 <- Y4 <- Y3 <- Y2 <- Y1 <- Y0 where each Yn filter element represents a unique IIR biquad: Yn = Y(n-1)\*b0 +

(b1 \* Y(n-2)) + (b2 \* Y(n-3)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2)) and: for Y0; Y(n-1) = Xin(0)

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input a t half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER\_16 filtArray;

uint16\_t dataY, dataX;

*// example to use 2 filter blocks as notch filters*

*// fill entire Filter Array with coefs*

for (i=0;i<8;i++)

\{

filtArray.Z=0;

filtArray.Z=0;

*// note all coefs are half value of original design, gain handled in algorithm*

*// all pass*

filtArray.b=0x4000;

filtArray.b=0; *// feed forward b1 coef*

filtArray.b=0; *// feed forward b2 coef*

filtArray.a=0; *// feedback a1 coef*

filtArray.a=0; *// feedback a2 coef*

\}

*// Unique filters for example*

*// 10KHz notch filter -- divide coefs by 2*

b0 = 0.5883783602332997

b1 = -0.17124071441396285

b2 = 0.5883783602332997

a1 = -0.17124071441396285

a2 = 0.1767567204665992

*// note all coefs are half value of original design, gain handled in algorithm*

filtArray.b=0x25a7; *// feed forward b0 coef*

filtArray.b=0xf508; *// feed forward b1 coef*

filtArray.b=0x25a7; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArray.a=0xf508; *// feedback a1 coef*

filtArray.a=0x0b4f; *// feedback a2 coef*

*// 1 KHz notch filter -- divide coefs by 2*

b0 = 0.9087554064944908

b1 = -1.7990948352036205

b2 = 0.9087554064944908

a1 = -1.7990948352036205

a2 = 0.8175108129889816

*// note all coefs are half value of original design, gain handled in algorithm*

filtArray.b=0x3a29; *// feed forward b0 coef*

filtArray.b=0x8cdc; *// feed forward b1 coef*

filtArray.b=0x3a29; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArray.a=0x8cdc; *// feedback a1 coef*

filtArray.a=0x3452; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get input data here*

dataX = compound\_300\_1K\_hz16;

dataY = DSP\_FilterIIRBQ16\_cascade8\_fast(dataX, filtArray);

*// \*\*\* do something with the DataY here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16\_cascade8\_fast** (int16\_t **Xin** , PARM\_EQUAL\_FILTER\_16 \* **pFilter\_Array** );

**DSP\_FilterIIRBQ16\_fast Function**

Performs a single-pass IIR Biquad Filter.

**Description**

Function DSP\_FilterIIRBQ16\_fast:

int16\_t DSP\_FilterIIRBQ16\_fast(int16\_t Xin, PARM\_EQUAL\_FILTER\_16 \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 16 bit instructions, with results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions.

The function will saturate the results if maximum or minimum fractional values are exceeded. All values are fractional Q15 format.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER\_16 \*ptrFilterEQ;

PARM\_EQUAL\_FILTER\_16 FilterEQ;

uint16\_t DataIn, DataOut;

ptrFilterEQ = &FilterEQ;

*// 48KHz sampling; 1 KHz bandpass filter; Q=0.9*

*// divide by 2 and convert to Q15*

*// b0 = 0.06761171785499065*

*// b1 = 0*

*// b2 = -0.06761171785499065*

*// a1 = -1.848823142275648*

*// a2 = 0.8647765642900187*

*// note all coefs are half value of original design, gain handled in algorithm*

ptrFiltEQ32-\>b=0x0453; *// feed forward b0 coef*

ptrFiltEQ32-\>b=0; *// feed forward b1 coef*

ptrFiltEQ32-\>b=0xFBAD; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

ptrFiltEQ32-\>a=0x89AD; *// feedback a1 coef*

ptrFiltEQ32-\>a=0x3758; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get some input data here*

DataIn32 = three\_hundred\_hz;

DataOut = DSP\_FilterIIRBQ16\_fast(DataIn, ptrFilterEQ);

*// \*\*\* do something with the DataOut here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16\_fast** (int16\_t **Xin** , PARM\_EQUAL\_FILTER\_16 \* **pFilter** );

**DSP\_FilterIIRBQ16\_parallel8 Function**

Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

**Description**

Function DSP\_FilterIIRBQ16\_parallel8:

int16\_t DSP\_FilterIIRBQ16\_parallel8(int16\_t Xin, PARM\_EQUAL\_FILTER \*pFilter);

Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, which results truncated to 16-bits for the output. The delay register is stored as a 32-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15 and Q31, see data structure for specifics.

Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =

X(0)\*b0 + (b1 \* X(n-1)) + (b2 \* X(n-2)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2))

**Preconditions**

Delay register values should be initialized to zero. The sum of all fracgain should be <= 1

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2

has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER filtArrayPara;

uint16\_t dataY, dataX;

*// fill entire Filter Array with coefs*

for (i=0;i<8;i++)

\{

filtArrayPara.Z=0;

filtArrayPara.Z=0;

filtArrayPara.G.fracGain = 0x7FFF; *// gain = 1 default*

filtArrayPara.G.expGain = 1; *// == 2^N; gain of 2*

*// note all coefs are half value of original design, gain handled in algorithm*

*// none pass -- default*

filtArrayPara.b=0; *// feed forward b0 coef*

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0; *// feedback a1 coef*

filtArrayPara.a=0; *// feedback a2 coef*

\}

*// 1K bandpass Q=0.9*

filtArrayPara.G.fracGain = 0x4000; *// gain = 0.5 because using 2 outputs*

*// note all coefs are half value of original design, gain handled in algorithm*

filtArrayPara.b=0x04ad;

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0xfb53; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0x8a90; *// feedback a1 coef*

filtArrayPara.a=0x36a4; *// feedback a2 coef*

*// 300 Hz bandpass Q=0.9*

filtArrayPara.G.fracGain = 0x1000; *// gain = 0.125 as an example*

*// note all coefs are half value of original design, gain handled in algorithm*

filtArrayPara.b=0x017b; *// feed forward b0 coef*

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0xfe85; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0x8316; *// feedback a1 coef*

filtArrayPara.a=0x3d08; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get input data here*

dataX = compound\_300\_1K\_hz16;

dataY = DSP\_FilterIIRBQ16\_cascade8\_fast(dataX, filtArray);

*// \*\*\* do something with the DataY here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16\_parallel8** (int16\_t **Xin** , PARM\_EQUAL\_FILTER \* **pFilter** );

**DSP\_FilterIIRBQ16\_parallel8\_fast Function**

Performs a 8 parallel single-pass IIR Biquad Filters, and sums the result.

**Description**

Function DSP\_FilterIIRBQ16\_parallel8\_fast:

int16\_t DSP\_FilterIIRBQ16\_parallel8\_fast(int16\_t Xin, PARM\_EQUAL\_FILTER\_16 \*pFilter);

Calculates a 8 parallel, single pass IIR biquad filters on Xin, sums the result and delivers the result as a 16-bit output. All math is

performed using 16 bit instructions, which results rounded to 16-bits for the output. The delay register is stored as a 16-bit value for subsequent functions. Output is tuned by 2 multiplier factors. First each parallel section has a fractional gain (attenuation) that enables individual scaling of that section. Second, a global binary (log2N) gain is applied to the result. The combination of gain factors enable both gain and attenuation. All values are fractional Q15. The function will round outputs and saturate if maximum or minimum values are exceeded.

Y = Y7/8 + Y6/8 + Y5/8 + Y4/8 + Y3/8 + Y2/8 + Y1/8 + Y0/8 where each Yn filter element represents a unique IIR biquad: Yn =

X(0)\*b0 + (b1 \* X(n-1)) + (b2 \* X(n-2)) - (a1 \* Yn(-1)) - (a2 \* Yn(-2))

**Preconditions**

Delay register values should be initialized to zero. The sum of all fracgain should be <= 1

**Parameters**

**Parameters Description**

Xin input data element X (int16\_t)

pFilter pointer to filter coef and delay structure

**Returns**

Sample output Y (int16\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER\_16 filtArrayPara; *// note change in data structure*

uint16\_t dataY, dataX;

*// fill entire Filter Array with coefs*

for (i=0;i<8;i++)

\{

filtArrayPara.Z=0;

filtArrayPara.Z=0;

filtArrayPara.G.fracGain = 0x7FFF; *// gain = 1 default*

filtArrayPara.G.expGain = 1; *// log2N; gain of 2*

*// note all coefs are half value of original design, gain handled in algorithm*

*// none pass -- default*

filtArrayPara.b=0; *// feed forward b0 coef*

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0; *// feedback a1 coef*

filtArrayPara.a=0; *// feedback a2 coef*

\}

*// 1K bandpass Q=0.9*

filtArrayPara.G.fracGain = 0x4000; *// gain = 0.5 because using 2 outputs*

*// note all coefs are half value of original design, gain handled in algorithm*

filtArrayPara.b=0x04ad;

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0xfb53; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0x8a90; *// feedback a1 coef*

filtArrayPara.a=0x36a4; *// feedback a2 coef*

*// 300 Hz bandpass Q=0.9*

filtArrayPara.G.fracGain = 0x1000; *// gain = 0.125 as an example*

*// note all coefs are half value of original design, gain handled in algorithm*

filtArrayPara.b=0x017b; *// feed forward b0 coef*

filtArrayPara.b=0; *// feed forward b1 coef*

filtArrayPara.b=0xfe85; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

filtArrayPara.a=0x8316; *// feedback a1 coef*

filtArrayPara.a=0x3d08; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get input data here*

dataX = compound\_300\_1K\_hz16;

dataY = DSP\_FilterIIRBQ16\_cascade8\_fast(dataX, filtArray);

*// \*\*\* do something with the DataY here*

\}

**C**

int16\_t **DSP\_FilterIIRBQ16\_parallel8\_fast** (int16\_t **Xin** , PARM\_EQUAL\_FILTER\_16 \* **pFilter** );

**DSP\_FilterIIRBQ32 Function**

Performs a high resolution single-pass IIR Biquad Filter.

**Description**

Function DSP\_FilterIIRBQ32:

int32\_t DSP\_FilterIIRBQ32(int32\_t Xin, PARM\_EQUAL\_FILTER\_32 \*pFilter);

Calculates a single pass IIR biquad filter on Xin, and delivers the result as a 16-bit output. All math is performed using 32 bit instructions, with results truncated to 32-bits for the output. The delay register is stored as a 32-bit value for subsequent functions.

All values are fractional Q31, see data structure for specifics.

Y = X(0)\*b0 + (b1 \* X(-1)) + (b2 \* X(-2)) - (a1 \* Y(-1)) - (a2 \* Y(-2))

**Preconditions**

Delay register values should be initialized to zero.

**Parameters**

**Parameters Description**

Xin input data element X (int32\_t)

pFilter pointer to high resolution filter coef and delay structure

**Returns**

Sample output Y (int32\_t)

**Remarks**

The delay register values should be initialized to zero prior to the first call to the function, they are updated each pass. A gain of 2 has been hard coded into the function. This implies that all coefs should be input at half value. This is purposeful, since many filter designs need a div2 to have each coef between the required -1

**Example**

PARM\_EQUAL\_FILTER\_32 \*ptrFiltEQ32;

PARM\_EQUAL\_FILTER\_32 FilterEQ32;

int32\_t DataIn32, DataOut32;

ptrFiltEQ32 = &FilterEQ32;

ptrFiltEQ32-\>Z=0;

ptrFiltEQ32-\>Z=0;

*// 1000 Hz Q= 0.9 BP filter design, 44.1K sampling*

*//*

*// b0 = 0.07311778239751009 forward*

*// b1 = 0*

*// b2 = -0.07311778239751009*

*// a1 = -1.8349811166056893 back*

*// a2 = 0.8537644352049799*

*// note all coefs are half value of original design, gain handled in algorithm*

ptrFiltEQ32-\>b=0x04ADF635; *// feed forward b0 coef*

ptrFiltEQ32-\>b=0; *// feed forward b1 coef*

ptrFiltEQ32-\>b=0xFB5209CB; *// feed forward b2 coef*

*// note all coefs are half value of original design, gain handled in algorithm*

*// note subtract is handled in algorithm, so coefs go in at actual value*

ptrFiltEQ32-\>a=0x8A8FAB5D; *// feedback a1 coef*

ptrFiltEQ32-\>a=0x36A41395; *// feedback a2 coef*

for (i=0;i<256;i++)

\{

*// \*\*\* get input data here*

DataIn32 = three\_hundred\_hz;

DataOut32 = DSP\_FilterIIRBQ32(DataIn32, ptrFiltEQ32);

*// \*\*\* do something with the DataOut32 here*

\}

**C**

int32\_t **DSP\_FilterIIRBQ32** (int32\_t **Xin** , PARM\_EQUAL\_FILTER\_32 \* **pFilter** );

**DSP\_FilterIIRSetup16 Function**

Converts biquad structure to coeffs array to set up IIR filter.

**Description**

Function DSP\_FilterIIRSetup16:

void DSP\_FilterIIRSetup16(int16\_t \*coeffs, biquad16 \*bq, int B);

Converts an array of biquad coefficients, bq, into an linear array of coefficients, coeffs. The output array must be 4\*B elements long. The number of biquads in the resulting factor is given by B. All numerical values must be in Q15 fractional data format.

**Preconditions**

coeffs must have 4\*B elements.

**Parameters**

**Parameters Description**

coeffs pointer to an array of coefficients (int16\_t)

bq pointer to array of biquad structure filter coefs (biquad16)

B number of cascaded biquad filter groups to process (int)

**Returns**

None.

**Remarks**

None.

**Example**

see DSP\_FilterIIR16 for example.

**C**

**void** **DSP\_FilterIIRSetup16** (int16\_t \* **coeffs** , biquad16 \* **bq** , int **B** );

**DSP\_FilterLMS16 Function**

Performs a single sample Least Mean Squares FIR Filter.

**Description**

Function DSP\_FilterLMS16:

int16\_t DSP\_FilterLMS16(int16\_t in, int16\_t ref, int16\_t \*coeffs, int16\_t \*delayline, int16\_t \*error, int K, int16\_t mu);

Computes an LMS adaptive filter on the input in. Filter output of the FIR is given as a 16 bit value. The filter target is ref, and the

calculation difference between the output and the target is error. The filter adapts its coefficients, coefs, on each pass. Th number of coefficients (filter taps) is given by the value K. The delayline array should be initialized to zero prior to calling the filter for the first time, and have K elements. The value mu is the rate at which the filter adapts. All values are Q15 fractional numbers.

The function will saturate the output if it exceeds maximum or minimum values. The LMS will adapt its coefs to attempt to drive the output value toward the ref value. The rate of adaption on each pass depends on mu and the error from the previous calculation.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. delayline must have (K) elements, and be initialized to

zero. K (taps) must be a multiple of 4, and \>= 8. mu must be positive.

**Parameters**

**Parameters Description**

in input data value (int16\_t)

ref target output value (int16\_t)

coeffs pointer to an array of coefficients (int16\_t)

delayline pointer to an array of delay variables (int16\_t)

error output minus reference (int16\_t)

K number of filter taps and coeffs (int)

mu adaption rate (int16\_t)

**Returns**

(int16\_t) - FIR filter output

**Remarks**

Filter coefs may start at random or zero value, but convergence is dependent on the amount of update required.

**Example**

**\#define** lmsTAPS 8

int16\_t lmsOut;

int lmsTaps = lmsTAPS;

int16\_t lmsCoefs=\{0x5000, 0x4000,0x3000, 0x2000,0x1000, 0x0000,0xF000, 0xE000\};

int16\_t lmsDelay=\{0\};

int16\_t \*ptrLMSError;

int16\_t lmsError = 0x0200;

int16\_t inVal=0;

int16\_t refVal = 0x0CCC; *// some target value = 0.1*

int16\_t lmsAdapt = 0x3000;

ptrLMSError = &lmsError;

for (i=0;i<200;i++)

\{

*// get some input value here //*

**if** (i < 100)

\{

inVal = 0x4233;

\}

**else**

\{

inVal = 0xCF10;

\}

lmsOut = DSP\_FilterLMS16(inVal, refVal, lmsCoefs, lmsDelay,

ptrLMSError, lmsTaps, lmsAdapt);

\}

**C**

int16\_t **DSP\_FilterLMS16** (int16\_t **in** , int16\_t **ref** , int16\_t \* **coeffs** , int16\_t \* **delayline** , int16\_t

-   **error** , int **K** , int16\_t **mu** );


**DSP\_MatrixAdd32 Function**

Addition of two matrices C = (A + B).

**Description**

Function DSP\_MatrixAdd32:

void DSP\_MatrixAdd32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Vector summation of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.

**Preconditions**

Both matrices must be equivalent in rows and columns. Both Matrices must be set into structure (ROWS, COLUMNS,

vector\_pointer).

**Parameters**

**Parameters Description**

resMat pointer to new sum Matrix C (\*int32\_t)

srcMat1 pointer to the Matrix A structure (\*int32\_t)

srcMat2 pointer to the Matrix B structure (\*int32\_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 225 cycles + 23 / matrix\_element. The function will saturate the output value if it exceeds maximum limits

per element.

**Example**

**\#define** ROW 2

**\#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32\_t result;

int32\_t matA = \{1,2,3,4\};

int32\_t matB = \{2,4,6,8\};

matrix32 mat, mat2, mat3;

resMat=&mat;

srcMat1=&mat2;

srcMat2=&mat3;

srcMat1-\>row=ROW;

srcMat1-\>col=COL;

srcMat1-\>pMatrix=matA;

srcMat2-\>col=COL;

srcMat2-\>row=ROW;

srcMat2-\>pMatrix=matB;

resMat-\>row=ROW;

resMat-\>col=COL;

resMat-\>pMatrix=result;

DSP\_MatrixAdd32(resMat, srcMat1, srcMat2);

*// result = matA + matB = \{3,6,9,0xA\}*

**C**

**void** **DSP\_MatrixAdd32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP\_MatrixEqual32 Function**

Equality of two matrices C = (A).

**Description**

Function DSP\_MatrixEqual32:

void DSP\_MatrixEqual32(matrix32 \*resMat, matrix32 \*srcMat);

Vector copy of all elements from one matrix to another. C is a duplicate of A.

**Preconditions**

None.

**Parameters**

**Parameters Description**

resMat pointer to completed new Matrix C (\*int32\_t)

srcMat pointer to the Matrix A structure (\*int32\_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 163 cycles + 12 / matrix\_element.

**Example**

**\#define** ROW 2

**\#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32\_t result;

int32\_t matA = \{5,2,-3,8\};

matrix32 mat, mat2;

resMat=&mat;

srcMat1=&mat2;

srcMat1-\>row=ROW;

srcMat1-\>col=COL;

srcMat1-\>pMatrix=matA;

resMat-\>row=ROW;

resMat-\>col=COL;

resMat-\>pMatrix=result;

DSP\_MatrixEqual32(resMat, srcMat1, srcMat2);

*// result = matA = \{5, 2, -3, 8\}*

**C**

**void** **DSP\_MatrixEqual32** (matrix32 \* **resMat** , matrix32 \* **srcMat** );

**DSP\_MatrixInit32 Function**

Initializes the first N elements of a Matrix to the value num.

**Description**

Function DSP\_MatrixInit32:

void DSP\_MatrixInit32(int32\_t \*data\_buffer, int N, int32\_t num);

Copy the value num into the first N Matrix elements of data\_buffer.

**Preconditions**

data\_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or it will truncate to the nearest factor of four.

**Parameters**

**Parameters Description**

data\_buffer pointer to the Matrix to be initialized (int32\_t)

N number of elements to be initialized (int32\_t)

num value to be initialized into the matrix (int32\_t)

**Returns**

None.

**Remarks**

None.

**Example**

**\#define** ROW 3

**\#define** COL 3

int32\_t numElements = 4; *// multiple of 4*

int valueElements = -1;

int32\_t matA = \{5,2,-3,8,4,2,-6,8,9\};

DSP\_MatrixInit32(matA, numElements, valueElements);

*// matA = \{-1,-1,-1,-1,4,2,-6,8,9\}*

**C**

**void** **DSP\_MatrixInit32** (int32\_t \* **data\_buffer** , int **N** , int32\_t **num** );

**DSP\_MatrixMul32 Function**

Multiplication of two matrices C = A x B.

**Description**

Function DSP\_MatrixMul32:

void DSP\_MatrixMul32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Multiplication of two matrices, with inputs and outputs being in fractional Q31 numerical format. The output elements will saturate if the dot product exceeds maximum or minimum fractional values.

**Preconditions**

Matrices must be aligned such that columns of A = rows of B. resMat must have the format of rows of A, columns of B. All Matrices must be set into structure (ROWS, COLUMNS, vector\_pointer).

**Parameters**

**Parameters Description**

resMat pointer to different Matrix C structure (\*int32\_t)

srcMat1 pointer to the Matrix A structure (\*int32\_t)

srcMat2 pointer to the Matrix B structure (\*int32\_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 319 cycles + 38 / output matrix\_element. The function will saturate the output value if it exceeds maximum limits per element.

**Example**

**\#define** ROW1 3

**\#define** COL1 2

**\#define** ROW2 2

**\#define** COL2 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32\_t result;

int32\_t test\_MatrixA=

\{

0x40000000,0x20000000, *// 0.5, 0.25*

0xD999999A,0x4CCCCCCC, *// -0.3, 0.6*

0xC0000000,0x0CCCCCCD *// -0.5 0.1*

\};

int32\_t test\_MatrixB=

\{

0x40000000,0x20000000, *// 0.5, 0.25*

0x0CCCCCCD,0xCCCCCCCD *// 0.1, -0.4*

\};

matrix32 mat, mat2, mat3;

resMat=&mat;

srcMat1=&mat2;

srcMat2=&mat3;

srcMat1-\>row=ROW1;

srcMat1-\>col=COL1;

srcMat1-\>pMatrix=test\_MatrixA;

srcMat2-\>col=COL2;

srcMat2-\>row=ROW2;

srcMat2-\>pMatrix=test\_MatrixB;

resMat-\>row=ROW1; *// note resulting matrix MUST have ROW1 & COL2 format*

resMat-\>col=COL2;

resMat-\>pMatrix=result;

DSP\_MatrixMul32(resMat, srcMat1, srcMat2);

*// result = matA x matB =*

*// \{ 0x23333333, 0x03333333 // 0.275, 0.025*

*// 0xF47AE147, 0xD7AE147B // -0.9, -0.315*

*// 0xE147AE14, 0xEAE147AE \} // -0.24, -0.165*

**C**

**void** **DSP\_MatrixMul32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP\_MatrixScale32 Function**

Scales each element of an input buffer (matrix) by a fixed number.

**Description**

Function DSP\_MatrixScale32:

void DSP\_MatrixScale32(int32\_t \*data\_buffer, int N, int32\_t num);

Multiply the first N elements of an input buffer by a fixed scalar num. The resulting value is stored back into the input buffer. N number total samples of the input buffer are processed. All values are in Q31 fractional integer format. The result of calculations is saturated to the MAX32 or MIN32 value if exceeded.

**Preconditions**

data\_buffer must be predefined to be equal to or greater than N elements. N must be a factor of four, or will truncate to the nearest factor of four.

**Parameters**

**Parameters Description**

data\_buffer pointer to the Matrix to be initialized (int32\_t)

N number of elements to be initialized (int)

num value to be initialized into the matrix (int32\_t)

**Returns**

None.

**Remarks**

Execution time (cycles): 190 + 9 cycles / element, typical.

**Example**

int32\_t numScale = 0x40000000; *// 0.5*

int valN = 12;

int32\_t inputBufScale = \{0x40000000, 0x40000000, 0x20000000, 0x20000000,

0x19999999, 0xCCCCCCCD, 0xF3333333, 0x80000000,

0x7FFFFFFF, 0x00000000, 0x40000000, 0x70000000 \};

*// 0.5, 0.5, 0.25, 0.25, 0.25, 0.2, -0.4, -0.1, -1, 1, 0, 0.5, 0.875*

DSP\_MatrixScale32(inputBufScale,valN,numScale);

*// inputBufScale = \{0x20000000, 0x20000000, 0x10000000, 0x10000000,*

*// 0x0CCCCCCC, 0xE6666666, 0xF9999999, 0xC0000000,*

*// 0x3FFFFFFF, 0x00000000, 0x20000000, 0x38000000\}*

*// 0.25, 0.25, 0.125, 0.125, 0.1, -0.2, -0.05, -0.5, 0.5, 0, 0.25, 0.4375*

**C**

**void** **DSP\_MatrixScale32** (int32\_t \* **data\_buffer** , int **N** , int32\_t **num** );

**DSP\_MatrixSub32 Function**

Subtraction of two matrices C = (A - B).

**Description**

Function DSP\_MatrixSub32:

void DSP\_MatrixSub32(matrix32 \*resMat, matrix32 \*srcMat1, matrix32 \*srcMat2);

Vector subtraction of two matrices, where both have 32-bit integer elements. The resulting output will saturate if element addition exceeds MAX32 or MIN32.

**Preconditions**

Both matrices must be equivalent in rows and columns. All Matrices must be set into structure (ROWS, COLUMNS, vector\_pointer)

**Parameters**

**Parameters Description**

resMat pointer to different Matrix C structure (\*int32\_t)

srcMat1 pointer to the Matrix A structure (\*int32\_t)

srcMat2 pointer to the Matrix B structure (\*int32\_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 222 cycles + 21 / matrix\_element. The function will saturate the output value if it exceeds maximum limits per element.

**Example**

**\#define** ROW 2

**\#define** COL 2

matrix32 \*resMat, \*srcMat1, \*srcMat2;

int32\_t result;

int32\_t matA = \{5,2,-3,8\};

int32\_t matB = \{2,2,2,2\};

matrix32 mat, mat2, mat3;

resMat=&mat;

srcMat1=&mat2;

srcMat2=&mat3;

srcMat1-\>row=ROW;

srcMat1-\>col=COL;

srcMat1-\>pMatrix=matA;

srcMat2-\>col=COL;

srcMat2-\>row=ROW;

srcMat2-\>pMatrix=matB;

resMat-\>row=ROW;

resMat-\>col=COL;

resMat-\>pMatrix=result;

DSP\_MatrixSub32(resMat, srcMat1, srcMat2);

*// result = matA - matB = \{3,0,-5,6\}*

**C**

**void** **DSP\_MatrixSub32** (matrix32 \* **resMat** , matrix32 \* **srcMat1** , matrix32 \* **srcMat2** );

**DSP\_MatrixTranspose32 Function**

Transpose of a Matrix C = A (T).

**Description**

Function DSP\_MatrixTranspose32:

void DSP\_MatrixTranspose32(matrix32 \*desMat, matrix32 \*srcMat);

Transpose of rows and columns of a matrix.

**Preconditions**

Matrix definitions for ROWS and COLS must be transposed prior to the function call.

**Parameters**

**Parameters Description**

desMat pointer to transposed new Matrix C (\*int32\_t)

srcMat pointer to the Matrix A structure (\*int32\_t)

**Returns**

None.

**Remarks**

Execution Time (cycles): 210 cycles + 10 / matrix\_element.

**Example**

**\#define** ROW 3

**\#define** COL 4

matrix32 \*resMat, \*srcMat1;

int32\_t result;

int32\_t matA = \{ 1, 2, 3, 4,

5, 6, 7, 8,

-1, -3, -5, -7\};

matrix32 mat, mat2;

resMat=&mat;

srcMat1=&mat2;

srcMat1-\>row=ROW;

srcMat1-\>col=COL;

srcMat1-\>pMatrix=matA;

resMat-\>row=COL; *// note the shift in columns and rows*

resMat-\>col=ROW;

resMat-\>pMatrix=result;

DSP\_MatrixTranspose32(resMat, srcMat1);

*// result = matA(T) = \{ 1, 5, -1,*

*// 2, 6, -3,*

*// 3, 7, -5,*

*// 4, 8, -7\}*

**C**

**void** **DSP\_MatrixTranspose32** (matrix32 \* **desMat** , matrix32 \* **srcMat** );

**DSP\_TransformFFT16 Function**

Creates an Fast Fourier Transform (FFT) from a time domain input.

**Description**

Function DSP\_TransformFFT16:

void DSP\_TransformFFT16(int16c \*dout, int16c \*din, int16c \*twiddles, int16c \*scratch, int log2N);

Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP\_TransformFFT16\_setup. All values are 16 bit (Q15) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be \>= 3 FFT factors must be calculated in advance, use DSP\_TransformFFT16\_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int16c)

din pointer to complex input array (int16c)

twiddles pointer to an complex array of factors (int16c)

scratch pointer to a complex scratch pad buffer (int16c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.

**Example**

int log2N = 8; *// log2(256) = 8*

int fftSamples = 256;

int16c \*fftDin;

int16c fftDout;

int16c scratch;

int16c fftCoefs;

int16c \*fftc;

fftc = &fftCoefs;

DSP\_TransformFFT16\_setup(fftc, log2N); *// call setup function*

while (1)

\{

fftDin = &fftin\_8Khz\_long\_window16; *// get 256 point complex data*

DSP\_TransformFFT16(fftDout, fftDin, fftc, scratch, log2N);

*// do something with the output, fftDout*

\};

**C**

**void** **DSP\_TransformFFT16** (int16c \* **dout** , int16c \* **din** , int16c \* **twiddles** , int16c \* **scratch** , int

**log2N** );

**DSP\_TransformFFT16\_setup Function**

Creates FFT coefficients for use in the FFT16 function.

**Description**

Function DSP\_TransformFFT16\_setup:

void DSP\_TransformFFT16\_setup(int16c \*twiddles, int log2N);

Calculates the N twiddle factors required to operate the FFT16 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a

buffer.

**Preconditions**

twiddles must be N in length N is calculated (2^log2N)

**Parameters**

**Parameters Description**

twiddles pointer to a complex array of factors (int16c)

log2N binary exponent of number of data points (int)

**Returns**

None.

**Remarks**

This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.

**Example**

see DSP\_TransformFFT16 for example.

**C**

**void** **DSP\_TransformFFT16\_setup** (int16c \* **twiddles** , int **log2N** );

**DSP\_TransformFFT32 Function**

Creates an Fast Fourier Transform (FFT) from a time domain input.

**Description**

Function DSP\_TransformFFT32:

void DSP\_TransformFFT32(int32c \*dout, int32c \*din, int32c \*twiddles, int32c \*scratch, int log2N);

Performs an complex FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP\_TransformFFT16\_setup. All values are 16 bit (Q31) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be \>= 3 FFT factors must be calculated in advance, use DSP\_TransformFFT32\_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int32c)

din pointer to complex input array (int32c)

twiddles pointer to an complex array of FFT factors (int32c)

scratch pointer to a complex scratch pad buffer (int32c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. Din is a complex number array, but may be loaded solely with real numbers if no phase information is available.

**Example**

int log2N = 8; *// log2(256) = 8*

int fftSamples = 256;

int32c \*fftDin;

int32c fftDout;

int32c scratch;

int32c fftCoefs;

int32c \*fftc;

fftc = &fftCoefs;

DSP\_TransformFFT32\_setup(fftc, log2N); *// call setup function*

while (1)

\{

fftDin = &fftin\_5Khz\_long\_window32; *// get 256 point complex data*

DSP\_TransformFFT32(fftDout, fftDin, fftc, scratch, log2N);

*// do something with the output, fftDout*

\};

**C**

**void** **DSP\_TransformFFT32** (int32c \* **dout** , int32c \* **din** , int32c \* **twiddles** , int32c \* **scratch** , int

**log2N** );

**DSP\_TransformFFT32\_setup Function**

Creates FFT coefficients for use in the FFT32 function.

**Description**

Function DSP\_TransformFFT32\_setup:

void DSP\_TransformFFT32\_setup(int32c \*twiddles, int log2N);

Calculates the N FFT twiddle factors required to operate the FFT32 function. These factors are done in serial fashion, and require considerable processing power. Ideally this function would be run only once prior to an ongoing FFT, and the results held in a buffer.

**Preconditions**

twiddles must be N in length N is calculated (2^log2N)

**Parameters**

**Parameters Description**

twiddles pointer to a complex array of coefficients (int32c)

log2N binary exponent of number of data points (int)

**Returns**

None.

**Remarks**

This function is of considerable length and executed in C. It is recommended it only be called once for any given FFT length in time sensitive applications.

**Example**

see DSP\_TransformFFT32 for example.

**C**

**void** **DSP\_TransformFFT32\_setup** (int32c \* **twiddles** , int **log2N** );

**DSP\_TransformIFFT16 Function**

Creates an Inverse Fast Fourier Transform (FFT) from a frequency domain input.

**Description**

Function DSP\_TransformIFFT16:

void DSP\_TransformIFFT16(int16c \*dout, int16c \*din, int16c \*twiddles, int16c \*scratch, int log2N);

Performs an complex Inverse FFT on the input, din, and stores the complex result in dout. Performs 2^log2N point calculation, and the working buffer scratch as well as the input and output must be 2^log2N in length. Coefficient twiddle factors come from twiddles, and may be loaded with the use of DSP\_TransformFFT16\_setup. All values are 16 bit (Q15) fractional.

**Preconditions**

din, dout, twiddles and scratch must have N elements N is calculated as 2^(log2N) log2N must be \>= 3 FFT factors must be calculated in advance, use DSP\_TransformFFT16\_setup

**Parameters**

**Parameters Description**

dout pointer to complex output array (int16c)

din pointer to complex input array (int16c)

twiddles pointer to an complex array of factors (int16c)

scratch pointer to a complex scratch pad buffer (int16c)

log2N binary exponent of number of samples (int)

**Returns**

None.

**Remarks**

Scratch must be declared but need not be initialized. Din may be aided with a window function prior to calling the FFT, but is not required. A very similar function to the FFT is executed for the inverse FFT. This requires twiddle factors set in advance with the same method as used in the FFT. Complex conjugate and scaling are handled within the algorithm. The output is scaled using binary shifting based on log2N. Since the algorithm reduces the output by a scale factor of log2N, the resolution is reduced proportionally to the number of data points.

**Example**

int ilog2N = 10; *// log2(64) = 6; log2(256) = 8; log2(1024) = 10;*

int ifftSamples = pow(2,ilog2N);

int16c \*ifftDin;

int16c ifftDout;

int16c iscratch;

int16c ifftCoefs;

int16c ifftTimeOut;

*// set up twiddle factors, these are used for both FFT and iFFT*

int16c \*ifftc;

ifftc = &ifftCoefs;

DSP\_TransformFFT16\_setup( ifftc, ilog2N); *// call to coef setup*

*// in this example, we take an FFT of an original time domain (sine wave)*

*// the output of the FFT is used as the input of the iFFT for comparison*

ifftDin = &fftin\_800hz\_verylong16;

DSP\_TransformFFT16(ifftDout, ifftDin, ifftc, iscratch, ilog2N);

*// ifftDout = frequency domain output, complex number array*

DSP\_TransformIFFT16(ifftTimeOut, ifftDout, ifftc, iscratch, ilog2N);

*// do something with the output, fftTimeOut, time domain*

**C**

**void** **DSP\_TransformIFFT16** (int16c \* **dout** , int16c \* **din** , int16c \* **twiddles** , int16c \* **scratch** , int

**log2N** );

**DSP\_TransformWindow\_Bart16 Function**

Perform a Bartlett window on a vector.

**Description**

Function DSP\_TransformWindow\_Bart16:

void DSP\_TransformWindow\_Bart16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.

Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Bart16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x0000, 0x1000, 0x2000, 0x3000, 0x4000, 0x3000, 0x2000, 0x1000*

**C**

**void** **DSP\_TransformWindow\_Bart16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Bart32 Function**

Perform a Bartlett window on a vector.

**Description**

Function DSP\_TransformWindow\_Bart32:

void DSP\_TransformWindow\_Bart32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Bartlett (Triangle) Window on the first N samples of the input vector, InVector. The output is stored in OutVector.

Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Bart32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x0, 0x10000000, 0x20000000, 0x30000000, 0x40000000,*

*// 0x30000000, 0x20000000, 0x10000000*

**C**

**void** **DSP\_TransformWindow\_Bart32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Black16 Function**

Perform a Blackman window on a vector.

**Description**

Function DSP\_TransformWindow\_Black16:

void DSP\_TransformWindow\_Black16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2*Pi*n/(N-1)) + 0.076849 \* COS(4*Pi*n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Black16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x0071, 0x0665, 0x1DF1, 0x3B00, 0x3B00, 0x1DF1, 0x0665, 0x0071*

**C**

**void** **DSP\_TransformWindow\_Black16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Black32 Function**

Perform a Blackman window on a vector.

**Description**

Function DSP\_TransformWindow\_Black32:

void DSP\_TransformWindow\_Black32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Blackman Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2*Pi*n/(N-1)) + 0.076849 \* COS(4*Pi*n/(N-1)) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Black32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x0070B490, 0x06649680, 0x1DF13240, 0x3B003D80, 0x3B003D80,*

*// 0x1DF13240, 0x06649680, 0x0070B490*

**C**

**void** **DSP\_TransformWindow\_Black32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Cosine16 Function**

Perform a Cosine (Sine) window on a vector.

**Description**

Function DSP\_TransformWindow\_Cosine16:

void DSP\_TransformWindow\_Cosine16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Cosine16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x0000, 0x1BC5, 0x320A, 0x3E65, 0x3E65, 0x320A, 0x1BC5, 0x0071*

**C**

**void** **DSP\_TransformWindow\_Cosine16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Cosine32 Function**

Perform a Cosine (Sine) window on a vector.

**Description**

Function DSP\_TransformWindow\_Cosine32:

void DSP\_TransformWindow\_Cosine32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Cosine Window on the first N samples of the input vector, InVector. The output is stored in OutWindow. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples The functional output

computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Cosine32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x00000000, 0x1BC4C060, 0x32098700, 0x3E653800, 0x3E653800,*

*// 0x32098700, 0x1BC4C060, 0x00000000*

**C**

**void** **DSP\_TransformWindow\_Cosine32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Hamm16 Function**

Perform a Hamming window on a vector.

**Description**

Function DSP\_TransformWindow\_Hamm16:

void DSP\_TransformWindow\_Hamm16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Hamm16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x051F, 0x0DBE, 0x228F, 0x3761, 0x4000, 0x3761, 0x228F, 0x0DBE*

**C**

**void** **DSP\_TransformWindow\_Hamm16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Hamm32 Function**

Perform a Hamming window on a vector.

**Description**

Function DSP\_TransformWindow\_Hamm32:

void DSP\_TransformWindow\_Hamm32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Hamming Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples The functional

output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Hamm32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x051EB860, 0x0DBE26C0, 0x228F5C40, 0x37609200, 0x40000000,*

*// 0x37609200, 0x228F5C40, 0x0DBE26C0*

**C**

**void** **DSP\_TransformWindow\_Hamm32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Hann16 Function**

Perform a Hanning window on a vector.

**Description**

Function DSP\_TransformWindow\_Hann16:

void DSP\_TransformWindow\_Hann16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Hann16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x0000, 0x095F, 0x2000, 0x36A1, 0x4000, 0x36A1, 0x2000, 0x095F*

**C**

**void** **DSP\_TransformWindow\_Hann16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Hann32 Function**

Perform a Hanning window on a vector.

**Description**

Function DSP\_TransformWindow\_Hann32:

void DSP\_TransformWindow\_Hann32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Hanning Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples The functional

output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Hann32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x00000000, 0x095F61C0, 0x20000000, 0x36A09E80, 0x40000000,*

*// 0x36A09E80, 0x20000000, 0x095F61C0*

**C**

**void** **DSP\_TransformWindow\_Hann32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Kaiser16 Function**

Perform a Kaiser window on a vector.

**Description**

Function DSP\_TransformWindow\_Kaiser16:

void DSP\_TransformWindow\_Kaiser16(int16\_t \*OutVector, int16\_t \*InVector, int N);

Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q15 fractional format.

The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2*Pi*n/N) + 0.098 \* cos(4*Pi*n/N) + 0.001 \* cos(6*Pi*n/N) where n is the window sample number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int16\_t OutVector16=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector16= 0x4000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Kaiser16(OutVector16, InVector16, WindowN);

*// OutWindow = 0x0031, 0x0325, 0x1375, 0x304F, 0x3FCF, 0x304F, 0x1375, 0x0325*

**C**

**void** **DSP\_TransformWindow\_Kaiser16** (int16\_t \* **OutVector** , int16\_t \* **InVector** , int **N** );

**DSP\_TransformWindow\_Kaiser32 Function**

Perform a Kaiser window on a vector.

**Description**

Function DSP\_TransformWindow\_Kaiser32:

void DSP\_TransformWindow\_Kaiser32(int32\_t \*OutVector, int32\_t \*InVector, int N);

Compute a Kaiser Window on the first N samples of the input vector, InVector. The output is stored in OutVector. Operations are performed at higher resolution and rounded for the most accuracy possible. Input and output values are in Q31 fractional format.

The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2*Pi*n/N) + 0.098 \* cos(4*Pi*n/N) + 0.001 \* cos(6*Pi*n/N) where n is the window sample

number N is the total number of samples The functional output computes WinVector(n) = Window(n) \* InVector(n)

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

**Example**

int32\_t OutVector32=\{0\};

int WindowN = 8;

for (i=0;i<WindowN;i++)

\{

InVector32= 0x40000000; *// constant 0.5 for functional testing*

\}

DSP\_TransformWindow\_Kaiser32(OutVector32, InVector32, WindowN);

*// OutWindow = 0x003126F6, 0x032555C8, 0x1374BCA0, 0x304F66C0, 0x3FCED900,*

*// 0x304F66C0, 0x1374BCA0, 0x032555C8*

**C**

**void** **DSP\_TransformWindow\_Kaiser32** (int32\_t \* **OutVector** , int32\_t \* **InVector** , int **N** );

**DSP\_TransformWinInit\_Bart16 Function**

Create a Bartlett window.

**Description**

Function DSP\_TransformWinInit\_Bart16:

void DSP\_TransformWinInit\_Bart16(int16\_t \*OutWindow, int N);

Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Bartlett Window follows

the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of

significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during

recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Bart16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Bart32 Function**

Create a Bartlett window.

**Description**

Function DSP\_TransformWinInit\_Bart32:

void DSP\_TransformWinInit\_Bart32(int32\_t \*OutWindow, int N);

Create a N-element Bartlett (Triangle) Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values Q31 fractional format. The Bartlett Window follows the equation:

Window(n) = 1 - (abs(2\*n - N)/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Bart32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Black16 Function**

Create a Blackman window.

**Description**

Function DSP\_TransformWinInit\_Black16:

void DSP\_TransformWinInit\_Black16(int16\_t \*OutWindow, int N);

Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating

point, and rounded for the most accuracy possible. Output values are Q16 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2*Pi*n/(N-1)) + 0.076849 \* COS(4*Pi*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Black16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Black32 Function**

Create a Blackman window.

**Description**

Function DSP\_TransformWinInit\_Black32:

void DSP\_TransformWinInit\_Black32(int32\_t \*OutWindow, int N);

Create a N-element Blackman Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are Q31 fractional format. The Blackman Window follows the equation:

Window(n) = 0.42659 - 0.49656 \* COS(2*Pi*n/(N-1)) + 0.076849 \* COS(4*Pi*n/(N-1)) where n is the window sample number N is

the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Black32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Cosine16 Function**

Create a Cosine (Sine) window.

**Description**

Function DSP\_TransformWinInit\_Cosine16:

void DSP\_TransformWinInit\_Cosine16(int16\_t \*OutWindow, int N);

Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Cosine16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Cosine32 Function**

Create a Cosine (Sine) window.

**Description**

Function DSP\_TransformWinInit\_Cosine32:

void DSP\_TransformWinInit\_Cosine32(int32\_t \*OutWindow, int N);

Create a N-element Cosine Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Cosine Window follows the equation:

Window(n) = SIN(Pi\*n/(N-1)) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Cosine32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Hamm16 Function**

Create a Hamming window.

**Description**

Function DSP\_TransformWinInit\_Hamm16:

void DSP\_TransformWinInit\_Hamm16(int16\_t \*OutWindow, int N);

Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Hamm16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Hamm32 Function**

Create a Hamming window.

**Description**

Function DSP\_TransformWinInit\_Hamm32:

void DSP\_TransformWinInit\_Hamm32(int32\_t \*OutWindow, int N);

Create a N-element Hamming Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hamming Window follows the equation:

Window(n) = 0.54 - 0.46 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Hamm32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Hann16 Function**

Create a Hanning window.

**Description**

Function DSP\_TransformWinInit\_Hann16:

void DSP\_TransformWinInit\_Hann16(int16\_t \*OutWindow, int N);

Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Hann16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Hann32 Function**

Create a Hanning window.

**Description**

Function DSP\_TransformWinInit\_Hann32:

void DSP\_TransformWinInit\_Hann32(int32\_t \*OutWindow, int N);

Create a N-element Hanning Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Hanning Window follows the equation:

Window(n) = 0.5 - 0.5 \* COS(2*Pi*n/N) where n is the window sample number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Hann32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Kaiser16 Function**

Create a Kaiser window.

**Description**

Function DSP\_TransformWinInit\_Kaiser16:

void DSP\_TransformWinInit\_Kaiser16(int16\_t \*OutWindow, int N);

Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q15 fractional format. The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2*Pi*n/N) + 0.098 \* cos(4*Pi*n/N) + 0.001 \* cos(6*Pi*n/N) where n is the window sample

number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Kaiser16** (int16\_t \* **OutWindow** , int **N** );

**DSP\_TransformWinInit\_Kaiser32 Function**

Create a Kaiser window.

**Description**

Function DSP\_TransformWinInit\_Kaiser32:

void DSP\_TransformWinInit\_Kaiser32(int32\_t \*OutWindow, int N);

Create a N-element Kaiser Window, and store the output to OutWindow. Operations are performed at higher resolution floating point, and rounded for the most accuracy possible. Output values are in Q31 fractional format. The Kaiser Window follows the equation:

Window(n) = 0.402 - 0.498 \* COS(2*Pi*n/N) + 0.098 \* cos(4*Pi*n/N) + 0.001 \* cos(6*Pi*n/N) where n is the window sample

number N is the total number of samples

**Preconditions**

N must be a positive number. OutWindow must be declared with N elements or larger.

**Parameters**

**Parameters Description**

OutWindow pointer to output array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This function is performed in C. The function may be optimized for the library. It is dependent on the floating point math library.

The functional window is an intermediate result that needs to be multiplied by an input vector prior to FFT processing. Because of significant processing time the window need only be computed once and the multiply of the (window \* input) vector done during recurring loop processing.

**Example**

**C**

**void** **DSP\_TransformWinInit\_Kaiser32** (int32\_t \* **OutWindow** , int **N** );

**DSP\_VectorAbs16 Function**

Calculate the absolute value of a vector.

**Description**

Function DSP\_VectorAbs16:

void DSP\_VectorAbs16(int16\_t \*outdata, int16\_t \*indata, int N);

Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata filled with the absolute value of elements of indata **Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of

eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAbs16(pOutdata, inBufTest, Num);

*// outVal = \{5,2,3,4,1,0,2,8\}*

**C**

**void** **DSP\_VectorAbs16** (int16\_t \* **outdata** , int16\_t \* **indata** , int **N** );

**DSP\_VectorAbs32 Function**

Calculate the absolute value of a vector.

**Description**

Function DSP\_VectorAbs32:

void DSP\_VectorAbs32(int32\_t \*outdata, int32\_t \*indata, int N);

Computes the absolute value of each element of indata and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata filled with N elements of abs(indata)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata pointer to input array of 16-bit elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100,200,127,-127,-2\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAbs32(pOutdata, inBufTest, Num);

*// outVal = \{5,2,3,4,1,0,2,8\}*

**C**

**void** **DSP\_VectorAbs32** (int32\_t \* **outdata** , int32\_t \* **indata** , int **N** );

**DSP\_VectorAdd16 Function**

Calculate the sum of two vectors.

**Description**

Function DSP\_VectorAdd16:

void DSP\_VectorAdd16(int16\_t \*outdata, int16\_t \*indata1, int16\_t \*indata2, int N);

Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata filled with N elements of indata1 + indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata1 pointer to input array of 16-bit elements (int16\_t)

indata2 pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int16\_t inBuf2= \{ 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAdd16(pOutdata, inBufTest, inBuf2, Num);

*// outVal = inBufTest + inBuf2 = \{-4,4,0,8,4,6,5,0\}*

**C**

**void** **DSP\_VectorAdd16** (int16\_t \* **outdata** , int16\_t \* **indata1** , int16\_t \* **indata2** , int **N** );

**DSP\_VectorAdd32 Function**

Calculate the sum of two vectors.

**Description**

Function DSP\_VectorAdd32:

void DSP\_VectorAdd32(int32\_t \*outdata, int32\_t \*indata1, int32\_t \*indata2, int N);

Computes the sum value of each element of indata1 + indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata filled with N elements of indata1 + indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata1 pointer to input array of 16-bit elements (int32\_t)

indata2 pointer to input array of 16-bit elements (int32\_t)

N number of samples

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int32\_t inBuf2= \{ 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAdd32(pOutdata, inBufTest, inBuf2, Num);

*// outVal = inBufTest + inBuf2 = \{-4,4,0,8,4,6,5,0\}*

**C**

**void** **DSP\_VectorAdd32** (int32\_t \* **outdata** , int32\_t \* **indata1** , int32\_t \* **indata2** , int **N** );

**DSP\_VectorAddc16 Function**

Calculate the sum of a vector and a constant.

**Description**

Function DSP\_VectorAddc16:

void DSP\_VectorAddc16(int16\_t \*outdata, int16\_t \*indata, int16\_t c, int N);

Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata filled with N elements of indata + c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata pointer to input array of 16-bit elements (int16\_t)

c constant value added to all indata1 elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int16\_t constValue = 3;

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAddc16(pOutdata, inBufTest, constValue, Num);

*// outVal = inBufTest + constValue = \{-2,5,0,7,2,3,1,-5\}*

**C**

**void** **DSP\_VectorAddc16** (int16\_t \* **outdata** , int16\_t \* **indata** , int16\_t **c** , int **N** );

**DSP\_VectorAddc32 Function**

Calculate the sum of a vector and a constant.

**Description**

Function DSP\_VectorAddc32:

void DSP\_VectorAddc32(int32\_t \*outdata, int32\_t \*indata, int32\_t c, int N);

Computes the sum value of each element of (indata + c) and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata filled with N elements of indata1 + c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata pointer to input array of 16-bit elements (int32\_t)

c constant value added to all indata1 elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int32\_t constValue = 3;

int Num = 8;

pOutdata = &outVal;

DSP\_VectorAddc32(pOutdata, inBufTest, constValue, Num);

*// outVal = inBufTest + constValue = \{-2,5,0,7,2,3,1,-5\}*

**C**

**void** **DSP\_VectorAddc32** (int32\_t \* **outdata** , int32\_t \* **indata** , int32\_t **c** , int **N** );

**DSP\_VectorAutocorr16 Function**

Computes the Autocorrelation of a Vector.

**Description**

Function DSP\_VectorAutocorr16:

void DSP\_VectorAutocorr16(int16\_t \*outCorr, int16\_t \*inVector, int N, int K);

Calculates the autocorrelation, with a lag of 1 to K, on the first N elements of inVector and returns the 16-bit scalar result in outCorr. The autocorrelation is calculated from other statistical equations including mean and variance. While in some cases these equations exist inside the DSP library, the functions are executed in a serial fashion within this code to provide enhanced performance. The unbiased function has the form -

mean (M) = sum(x(n) / N) variance (V) = sum((x(n) - M)^2) / (N-1) autocovariance (ACV) = sum((x(n) -

M) \* (x(n+k) - M) / (N-k)) autocorrelation (AC) = CV / V where N is the number of vector elements, n is the index of those elements x(n) is a single element in the input vector M is the mean of the N elements of the vector k is the lag or series index

The output of the function will return K elements, and the outCorr array should be sized to accept those 16-bit results. The outputs correspond to k=1, k=2, .., k=K delay states. The function returns a 16-bit value in rounded, saturated Q15 format.

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. outCorr must be an array with at least K values. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outCorr pointer to output array (int16\_t)

inVector pointer to source array of elements (int16\_t)

N number of samples (int)

K lag value, number of output elements (int)

**Returns**

None.

**Remarks**

This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the \_LIBQ\_Q16Div specifically.

**Example**

int autocvN = 16; *// N value, number of samples in array*

int autocvLag = 4; *// Lag value, output shifts to observe*

int16\_t outAC=\{0\};

int16\_t CVIn16 = \{0x1999, 0xD99A, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666,

0x3333, 0x1000, 0x6000, 0x1999, 0x1999, 0x2666, 0x3333, 0x1999, 0x0CCC\};

*// = \{ .2, -.3, .125, .75, .2, .2, .3, .4, .125, .75, .2, .2, .3, .4, .2, .1\};*

DSP\_VectorAutocorr16(outAC, CVIn16, autocvN, autocvLag);

*// outAC = \{0xF406, D46C, 0x098F, 0x191A\}*

*// = -0.093567, -0.34045, 0.07468, 0.19611*

**C**

**void** **DSP\_VectorAutocorr16** (int16\_t \* **outCorr** , int16\_t \* **inVector** , int **N** , int **K** );

**DSP\_VectorBexp16 Function**

Computes the maximum binary exponent of a vector.

**Description**

Function DSP\_VectorBexp16:

int DSP\_VectorBexp16(int16\_t \*DataIn, int N);

Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q15 fractional data format.

**Preconditions**

N must be a multiple of 2 and greater or equal to 2.

**Parameters**

**Parameters Description**

DataIn pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

Binary exponent  (int)

**Remarks**

None.

**Example**

int valN = 4;

int16\_t dummy16=\{0x3004, 0x00CC, 0xFC04, 0xFFF0\};

*// 0.375, 0.0062, -0.0311, -0.00049*

int answer;

answer = DSP\_VectorBexp16(dummy16, valN);

*// answer = 1, maximum binary gain is 2.*

**C**

int **DSP\_VectorBexp16** (int16\_t \* **DataIn** , int **N** );

**DSP\_VectorBexp32 Function**

Computes the maximum binary exponent of a vector.

**Description**

Function DSP\_VectorBexp32:

int DSP\_VectorBexp32(int32\_t \*DataIn, int N);

Calculates the maximum binary exponent on the first N elements of the input vector DataIn, and stores the integer result. The returned value represents the potential binary scaling of the vector, and may be used with other functions that auto scale their output without saturation. Inputs are given in Q31 fractional data format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

DataIn pointer to input array of 16-bit elements (int32\_t)

N number of samples (int)

**Returns**

Binary exponent  (int)

**Remarks**

None.

**Example**

int valN=4;

int32\_t datInput32=\{0xFF000000, 0x07000000,0x000CCCCC, 0x08000000\};

*// -0.007183, 0.054688, 0.0003906, 0.0625*

int answer32;

answer32 = DSP\_VectorBexp32(datInput32, valN);

*// answer = 3, maximum binary gain is 8.*

**C**

int **DSP\_VectorBexp32** (int32\_t \* **DataIn** , int **N** );

**DSP\_VectorChkEqu32 Function**

Compares two input vectors, returns an integer 1 if equal, and 0 if not equal.

**Description**

Function DSP\_VectorChkEqu32:

int DSP\_VectorChkEqu32(int32\_t \*indata1, int32\_t \*indata2, int N);

Compares the first N values of indata1 to the same elements of indata2. The comparison requires that all numbers be in Q31 fractional data format. Returns the integer value 1 if all numbers are equal, and 0 if they are not equal. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata1 pointer to input array 1 of elements (int32\_t)

indata2 pointer to input array 2 of elements (int32\_t)

N number of samples (int)

**Returns**

(int) - 1 if vectors are equal, 0 if vectors are not equal

**Remarks**

None.

**Example**

int outCheck;

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufTestB=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x80000000, 0x40000000, 0x7FFFFFFF, 0x20000000\};

*// 1, -1, 0.9, 0.8, -1, 0.5, 1, 0.25*

outCheck = DSP\_VectorChkEqu32(inBufTestA, inBufTestB, Num);

*// outCheck = 1 // true for first 4 numbers of series*

**C**

int **DSP\_VectorChkEqu32** (int32\_t \* **indata1** , int32\_t \* **indata2** , int **N** );

**DSP\_VectorCopy Function**

Copies the elements of one vector to another.

**Description**

Function DSP\_VectorCopy:

void DSP\_VectorCopy(int32\_t \*outdata, int32\_t \*indata, int N);

Fills the first N values of an input vector outdata with the elements from indata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of values (int32\_t)

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufTestB=\{0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000\};

*// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25*

DSP\_VectorCopy(inBufTestA, inBufTestB, Num);

*// inBufTestA = \{0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,*

*// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\} // first 4 values copied*

**C**

**void** **DSP\_VectorCopy** (int32\_t \* **outdata** , int32\_t \* **indata** , int **N** );

**DSP\_VectorCopyReverse32 Function**

Reverses the order of elements in one vector and copies them into another.

**Description**

Function DSP\_VectorCopyReverse32:

void DSP\_VectorCopyReverse32(int32\_t \*outdata, int32\_t \*indata, int N);

Fills the first N values of an input vector Outdata with the reverse elements from INDATA. N must be a multiple of 4 and greater than 4 or will be truncated to the nearest multiple of 4. The vectors are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of values (int32\_t)

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufTestB=\{0x00000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000\};

*// 0, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25*

DSP\_VectorCopyReverse32(inBufTestA, inBufTestB, Num);

*// inBufTestA = \{0x0CCCCCCC, 0x40000000, 0x7FFFFFFF, 0x00000000,*

*// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\}*

*// first 4 values copied reverse order*

**C**

**void** **DSP\_VectorCopyReverse32** (int32\_t \* **outdata** , int32\_t \* **indata** , int **N** );

**DSP\_VectorDivC Function**

Divides the first N elements of inVector by a constant divisor, and stores the result in outVector.

**Description**

Function DSP\_VectorDivC:

void DSP\_VectorDivC(\_Q16 \*outVector, \_Q16 \*inVector, \_Q16 divisor, int N);

Divides each element of the first N elements of inVector by a constant, divisor. The output is stored to outVector. Both vectors and the scalar are \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q16)

divisor scalar divisor for the input vector (\_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for \_LIBQ\_Q16Div.

**Example**

int divNum = 4;

\_Q16 divScalar = 0x00020000; *// 2.0*

\_Q16 inDivVec = \{0x08000000, 0xfffc0000,0x00024000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000\};

*// 2048, -4, 2.25, 16, 3.5, 64, -2, 5.5*

\_Q16 outDivVec = \{0\};

DSP\_VectorDivC(outDivVec, inDivVec, divScalar, divNum);

*// outDivVec = 0x04000000, 0xFFFFE0000, 0x00012000, 0x00080000, 0, 0, 0, 0*

*// 1024.0, -2.0, 1.125, 16.0, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorDivC** (\_Q16 \* **outVector** , \_Q16 \* **inVector** , \_Q16 **divisor** , int **N** );

**DSP\_VectorDotp16 Function**

Computes the dot product of two vectors, and scales the output by a binary factor.

**Description**

Function DSP\_VectorDotp16:

int16\_t DSP\_VectorDotp16(int16\_t \*indata1, int16\_t \*indata2, int N, int scale);

Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in Q15 fractional format.

return = 1/(2^scale) \* sum(indata1 \* indata2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of

eight.

**Parameters**

**Parameters Description**

indata1 pointer to input array of 16-bit elements (int16\_t)

indata2 pointer to input array of 16-bit elements (int16\_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16\_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t inBufMultA=\{0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int16\_t inBufMultB=\{0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD\};

*// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1*

int Num = 8;

int scaleVal = 2;

int16\_t outScalar;

int Num = 8;

outScalar = DSP\_VectorDotp16(inBufMultA, inBufMultB, Num, scaleVal);

*// outScalar = 1/(2^scaleVal)\*(inBufMultA dot inBufMultB) =*

*// (1/4) \* (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 \* 0.20 = 0.05*

*// = (int16\_t)0x0666*

**C**

int16\_t **DSP\_VectorDotp16** (int16\_t \* **indata1** , int16\_t \* **indata2** , int **N** , int **scale** );

**DSP\_VectorDotp32 Function**

Computes the dot product of two vectors, and scales the output by a binary factor

**Description**

Function DSP\_VectorDotp32:

int32\_t DSP\_VectorDotp32(int32\_t \*indata1, int32\_t \*indata2, int N, int scale);

Calculates the dot product of two input vectors, and scales the output. Function will saturate if it exceeds maximum or minimum

values. Scaling is done by binary shifting, after calculation of the result. All calculations are done in Q31 fractional format. return =

1/(2^scale) \* sum(indata1 \* indata2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata1 pointer to input array of 16-bit elements (int32\_t)

indata2 pointer to input array of 16-bit elements (int32\_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16\_t - scaled output of calculation, Q31 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int32\_t inBufMultA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufMultB=\{0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD\};

*// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1*

int Num = 8;

int scaleVal = 2;

int32\_t outScalar;

int Num = 8;

outScalar = DSP\_VectorDotp32(inBufMultA, inBufMultB, Num, scaleVal);

*// outScalar = 1/(2^scaleVal)\*(inBufMultA dot inBufMultB) =*

*// (1/4) \* (0.1 + -0.1 + 0.45 + -0.4 + -0.04 + 0.25 + 0 + -0.06) = 0.25 \* 0.20 = 0.05*

*// = (int32\_t)0x06666666*

**C**

int32\_t **DSP\_VectorDotp32** (int32\_t \* **indata1** , int32\_t \* **indata2** , int **N** , int **scale** );

**DSP\_VectorExp Function**

Computes the EXP (e^x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorExp:

void DSP\_VectorExp(\_Q16 \*outVector, \_Q16 \*inVector, int N);

Computes the Exp value, e to the power of X, on the first N elements of inVector. The output is stored to outVector. Both vectors are \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Exp and Div functions from the LibQ library. That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

Inclusion of the LibQ header file and library is mandatory to use this function.

**Example**

int expNum = 4;

\_Q16 inExpVec = \{0x00010000, 0xffff0000,0x00020000,0x00030000,0x00038000,

0x00040000,0xfffe0000,0x00058000\};

*// 1.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5*

\_Q16 outExpVec = \{0\};

DSP\_VectorExp(outExpVec, inExpVec, expNum);

*// outExpVec = 0x0002B7E1, 0x00005E2D, 0x00076399, 0x001415E6, 0, 0, 0, 0*

*// 2.71828, 0.26787, 7.3891, 20.0855, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorExp** (\_Q16 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorFill Function**

Fills an input vector with scalar data.

**Description**

Function DSP\_VectorFill:

void DSP\_VectorFill(int32\_t \*indata, int32\_t data, int N);

Fills the first N values of an input vector indata with the value data. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32\_t)

data scalar value to fill the array (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int32\_t fillValue = 0x3FFFFFFF;

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

DSP\_VectorFill(inBufTestA, fillValue, Num);

*// inBufTestA = \{0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF,*

*// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\} // first 4 values filled*

**C**

**void** **DSP\_VectorFill** (int32\_t \* **indata** , int32\_t **data** , int **N** );

**DSP\_VectorLn Function**

Computes the Natural Log, Ln(x), of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorLn:

void DSP\_VectorLn(\_Q4\_11 \*outVector, \_Q16 \*inVector, int N);

Computes the Ln(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q4.11 format, which is a 16-bit integer format with 11 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Ln function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q4\_11)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the

design in order to operate this function. For more information on the Ln function see the LibQ documentation for \_LIBQ\_Q4\_11\_ln\_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int lnNum = 4;

\_Q16 inLnVal = \{0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000\};

*// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5*

\_Q4\_11 outLnVal = \{0\};

DSP\_VectorLn(outLnVal, inLnVal, lnNum);

*// outLnVal = 0x4DA2, 0x8000, 0x058C, 0x162E, 0, 0, 0, 0*

*// 9.704, sat negative, 0.6934, 2.772, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorLn** (\_Q4\_11 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorLog10 Function**

Computes the Log10(x), of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorLog10:

void DSP\_VectorLog10(\_Q3\_12 \*outVector, \_Q16 \*inVector, int N);

Computes the Log10(x) value, on the first N elements of inVector. The output is stored to outVector. Input vector is \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q3.12 format, which is a 16-bit integer format with 12 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log10 function from the LibQ library. That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q3\_12)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log10 function see the LibQ documentation for \_LIBQ\_Q3\_12\_log10\_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int logNum = 4;

\_Q16 inLogVal = \{0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000\};

*// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5*

\_Q3\_12 outLogVal = \{0\};

DSP\_VectorLog10(outLogVal, inLogVal, logNum);

*// outLogVal = 0x436E, 0x8000, 0x04D1, 0x1344, 0, 0, 0, 0*

*// 4.2144, sat negative, 0.3010, 1.2041, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorLog10** (\_Q3\_12 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorLog2 Function**

Computes the Log2(x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorLog2:

void DSP\_VectorLog2(\_Q5\_10 \*outVector, \_Q16 \*inVector, int N);

Computes the Log2 value, where log2(x) = ln(x) \* log2(e), on the first N elements of inVector. The output is stored to outVector.

Input vector is \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. The output vector is reduced resolution Q5.10 format, which is a 16-bit integer format with 10 bits representing the fractional resolution. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Log2 function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q5\_10)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Log2 function see the LibQ documentation for \_LIBQ\_Q5\_10\_log2\_Q16. A negative number input will return a saturated negative value (0x8000).

**Example**

int log2Num = 4;

\_Q16 inLog2Val = \{0x40000000, 0xffff0000,0x00020000,0x00030000,0x00038000,

0x00040000,0xfffe0000,0x00058000\};

*// 16384.0, -1.0, 2.0, 3.0, 3.5, 4.0, -2.0, 5.5*

\_Q5\_10 outLog2Val = \{0\};

DSP\_VectorLog2(outLog2Val, inLog2Val, log2Num);

*// outLog2Val = 0x3800, 0x8000, 0x0400, 0x0657, 0, 0, 0, 0*

*// 14.0, sat negative, 1.0, 1.585, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorLog2** (\_Q5\_10 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorMax32 Function**

Returns the maximum value of a vector.

**Description**

Function DSP\_VectorMax32:

int32\_t DSP\_VectorMax32(int32\_t \*indata, int N);

Returns the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of elements (int32\_t)

N number of samples (int)

**Returns**

(int32\_t) - maximum value within the vector, Q31 format

**Remarks**

None.

**Example**

int32\_t outCheck;

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

outCheck = DSP\_VectorMax32(inBufTestA, Num);

*// outCheck = 0x7FFFFFFF // first 4 values*

**C**

int32\_t **DSP\_VectorMax32** (int32\_t \* **indata** , int **N** );

**DSP\_VectorMaxIndex32 Function**

Returns the index of the maximum value of a vector.

**Description**

Function DSP\_VectorMaxIndex32:

int DSP\_VectorMaxIndex32(int32\_t \*indata, int N);

Returns the index of the highest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

int - index of the position of the maximum array element

**Remarks**

Index values range from 0 .. (n-1).

**Example**

int indexValue;

int Num = 8;

int32\_t inBufTestA=\{0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

indexValue = DSP\_VectorMaxIndex32(inBufTestA, Num);

*// returnValue = 6 (position corresponding to 0x7FFFFFFF)*

**C**

int **DSP\_VectorMaxIndex32** (int32\_t \* **indata** , int **N** );

**DSP\_VectorMean32 Function**

Calculates the mean average of an input vector.

**Description**

Function DSP\_VectorMean32:

int32\_t DSP\_VectorMean32(int32\_t \*indata, int N);

Calculates the mean average of the first N elements of the vector indata. The values of indata1 are in Q31 fractional format. The value N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

int32\_t - mean average value of the vector

**Remarks**

None.

**Example**

int32\_t returnValue;

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

returnValue = DSP\_VectorMean32(inBufTestA, Num);

*// returnValue = 0x36666666 = (1-1+0.9+0.8)/4 = 0.425*

**C**

int32\_t **DSP\_VectorMean32** (int32\_t \* **indata1** , int **N** );

**DSP\_VectorMin32 Function**

Returns the minimum value of a vector.

**Description**

Function DSP\_VectorMin32:

int32\_t DSP\_VectorMin32(int32\_t \*indata, int N);

Returns the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of elements (int32\_t)

N number of samples (int)

**Returns**

(int32\_t) - minimum value within the vector, Q31 format

**Remarks**

None.

**Example**

int32\_t outCheck;

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

outCheck = DSP\_VectorMin32(inBufTestA, Num);

*// outCheck = 0x80000000 // first 4 values*

**C**

int32\_t **DSP\_VectorMin32** (int32\_t \* **input** , int **N** );

**DSP\_VectorMinIndex32 Function**

Returns the index of the minimum value of a vector.

**Description**

Function DSP\_VectorMinIndex32:

int DSP\_VectorMinIndex32(int32\_t \*indata, int N);

Returns the relative position index of the lowest value of the first N elements of the vector indata. The comparison requires that all numbers be in Q31 fractional data format. N must be greater than or equal to four and a multiple of four, or it will be truncated to the nearest multiple of four.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

int32\_t - mean average value of the vector

**Remarks**

Index values range from 0 .. (n-1).

**Example**

int indexValue;

int Num = 8;

int32\_t inBufTestA=\{0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

indexValue = DSP\_VectorMinIndex32(inBufTestA, Num);

*// returnValue = 1 (position corresponding to 0x80000000)*

**C**

int **DSP\_VectorMinIndex32** (int32\_t \* **indata** , int **N** );

**DSP\_VectorMul16 Function**

Multiplication of a series of numbers in one vector to another vector.

**Description**

Function DSP\_VectorMul16:

void DSP\_VectorMul16(int16\_t \*outdata, int16\_t \*indata1, int16\_t \*indata2, int N);

Multiples the value of each element of indata1 \* indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q15 fractional format. outdata filled with N elements of indata1 \* indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata1 pointer to input array of 16-bit elements (int16\_t)

indata2 pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufMultA=\{0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int16\_t inBufMultB=\{0x0CCD, 0x0CCD, 0x4000, 0xC000, 0xE667, 0x4000, 0x0000, 0x0CCD\};

*// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1*

int Num = 8;

pOutdata = &outVal;

DSP\_VectorMul16(pOutdata, inBufMultA, inBufMultB, Num);

*// outVal = inBufTest \* inBuf2 =*

*// \{0x0CCD, 0xF333, 0x399A, 0xCCCD, 0xFAE2, 0x2000, 0x0000, 0xF852\}*

*// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06*

**C**

**void** **DSP\_VectorMul16** (int16\_t \* **outdata** , int16\_t \* **indata1** , int16\_t \* **indata2** , int **N** );

**DSP\_VectorMul32 Function**

Multiplication of a series of numbers in one vector to another vector.

**Description**

Function DSP\_VectorMul32:

void DSP\_VectorMul32(int32\_t \*outdata, int32\_t \*indata1, int32\_t \*indata2, int N);

Multiples the value of each element of indata1 \* indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in the Q31 fractional format. outdata filled with N elements of indata1 \* indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata1 pointer to input array of 16-bit elements (int32\_t)

indata2 pointer to input array of 16-bit elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufMultA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufMultB=\{0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD\};

*// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1*

int Num = 8;

pOutdata = &outVal;

DSP\_VectorMul32(pOutdata, inBufMultA, inBufMultB, Num);

*// outVal = inBufTest \* inBuf2 =*

*// \{0x0CCCCCCD, 0xF3333333, 0x3999999A, 0xCCCCCCCD, 0xFAE147AE,*

*// 0x20000000, 0x00000000, 0xF851EB86\}*

*// 0.1, -0.1, 0.45, -0.4, -0.04, 0.25, 0, -0.06*

**C**

**void** **DSP\_VectorMul32** (int32\_t \* **outdata** , int32\_t \* **indata1** , int32\_t \* **indata2** , int **N** );

**DSP\_VectorMulc16 Function**

Multiplication of a series of numbers in one vector to a scalar value.

**Description**

Function DSP\_VectorMulc16:

void DSP\_VectorMulc16(int16\_t \*outdata, int16\_t \*indata, int16\_t c, int N);

Multiples the value of each element of indata1 \* c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata filled with N elements of indata \* c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata pointer to input array of 16-bit elements (int16\_t)

c scalar multiplicand (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufMultA=\{0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x0000, 0xB334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 0, -0.6*

int16\_t constValue = 0x4000;

int Num = 8;

pOutdata = &outVal;

DSP\_VectorMulc16(pOutdata, inBufMultA, constValue, Num);

*// outVal = inBufTest \* constValue =*

*// \{0x4000, 0xC000, 0x399A, 0x3333, 0x1999, 0x2000, 0x0000, 0xD99A\}*

*// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3*

**C**

**void** **DSP\_VectorMulc16** (int16\_t \* **outdata** , int16\_t \* **indata** , int16\_t **c** , int **N** );

**DSP\_VectorMulc32 Function**

Multiplication of a series of numbers in one vector to a scalar value.

**Description**

Function DSP\_VectorMulc32:

void DSP\_VectorMulc32(int32\_t \*outdata, int32\_t \*indata, int32\_t c, int N);

Multiples the value of each element of indata \* c and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata filled with N elements of indata \* c

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata pointer to input array of 16-bit elements (int32\_t)

c scalar multiplicand (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufMultA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x00000000, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t constValue = 0x4000;

int Num = 8;

pOutdata = &outVal;

DSP\_VectorMulc32(pOutdata, inBufMultA, constValue, Num);

*// outVal = inBufTest \* constValue =*

*// \{0x40000000, 0xC0000000, 0x3999999A, 0x33333333, 0x19999999,*

*// 0x20000000, 0x00000000, 0xD999999A\}*

*// 0.5, -0.5, 0.45, 0.4, 0.1, 0.25, 0, -0.3*

**C**

**void** **DSP\_VectorMulc32** (int32\_t \* **outdata** , int32\_t \* **indata** , int32\_t **c** , int **N** );

**DSP\_VectorNegate Function**

Inverses the sign (negates) the elements of a vector.

**Description**

Function DSP\_VectorNegate:

void DSP\_VectorNegate(int32\_t \*outdata, int32\_t \*indata, int N);

Sign inversion of the first N values of an indata are assigned to outdata. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result and the scalar value to fill are both Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32\_t)

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t outBufTest=\{0x0CCCCCCD, 0x0CCCCCCD, 0x40000000, 0xC0000000,

0xE6666667, 0x40000000, 0x00000000, 0x0CCCCCCD\};

*// 0.1, 0.1, 0.5, -0.5, -0.2, 0.5, 0, 0.1;*

DSP\_VectorNegate(outBufTest, inBufTestA, Num);

*// inBufTestA = \{0x80000000, 0x7FFFFFFF, 0x8CCCCCCD, 0x9999999A,*

*// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\} // first 4 values neg*

*// -1, 1, -0.9, -0.8, -0.2, 0.5, 0, 0.1*

**C**

**void** **DSP\_VectorNegate** (int32\_t \* **outdata** , int32\_t \* **indata** , int **N** );

**DSP\_VectorRecip Function**

Computes the reciprocal (1/x) of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorRecip:

void DSP\_VectorRecip(\_Q16 \*outVector, \_Q16 \*inVector, int N);

Computes the reciprocal (1/x) on the first N elements of inVector. The output is stored to outVector. Both vectors are \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or minimum respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Div function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Div function see the LibQ documentation for \_LIBQ\_Q16Div.

A value of zero in the array will not cause an error, but will return 0.

**Example**

int recNum = 4;

\_Q16 inRecVec = \{0x08000000, 0xfffc0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000\};

*// 2048.0, -4.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5*

\_Q16 outRecVec = \{0\};

DSP\_VectorRecip(outRecVec, inRecVec, recNum);

*// outRecVec = 0x00000020, 0xFFFFC0000, 0x00008000, 0x00001000, 0, 0, 0, 0*

*// 0.000488, -0.25, 0.5, 0.0625, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorRecip** (\_Q16 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorRMS16 Function**

Computes the root mean square (RMS) value of a vector.

**Description**

Function DSP\_VectorRMS16:

int16\_t DSP\_VectorRMS16(int16\_t \*inVector, int N);

Computes the root mean square value of the first N values of inVector. Both input and output are Q15 fractional values. The function will saturate if maximum or minimum values are exceeded.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of four.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

int16\_t - RMS function output, Q15 format

**Remarks**

This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and uses the \_LIBQ\_Q16Sqrt external function call.

**Example**

int16\_t vecRMSIn=\{0x1999, 0xD99A, 0x4000, 0x2666,0x1999,0x1999,0x2666, 0x3333\};

*// 0.2, -0.3, 0.5, 0.3, 0.2, 0.2, 0.3, 0.4*

int16\_t RMSOut=0;

int Nrms = 8;

RMSOut = DSP\_VectorRMS16(vecRMSIn, Nrms);

*// RMSOut = 0x287C (= 0.31628)*

**C**

int16\_t **DSP\_VectorRMS16** (int16\_t \* **inVector** , int **N** );

**DSP\_VectorShift Function**

Shifts the data index of an input data vector.

**Description**

Function DSP\_VectorShift:

void DSP\_VectorShift(int32\_t \*outdata, int32\_t \*indata, int N, int shift);

Shifts N data elements of indata to outdata, with an index change of shift. The amount of data shifted includes zero padding for

the first (shift) elements if shift is positive. The vector size of indata and outdata need not be the same, however, N must not exceed either array size.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must not exceed the amount of elements in the source array. shift must not exceed the number of elements in the destination array.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (int32\_t)

indata pointer to source array of elements (int32\_t)

N number of samples (int)

shift number of indexes to shift (int)

**Returns**

None.

**Remarks**

Destination array values shift to left (relative to the input vector) when shift is positive (back filled with zeros) and shift to the right when shift is negative. The total amount of values copied to the destination array is the length of N less the shift amount.

**Example**

int shiftValue = 3;

int Num = 8;

int32\_t inBufTestA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int32\_t inBufTestB=\{0x80000000, 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC,

0x40000000, 0x60000000, 0x80000000, 0x20000000\};

*// -1, 1, 0.5, 0.1, 0.75, 0.5, -1, 0.25*

DSP\_VectorShift(inBufTestA, inBufTestB, Num, shiftValue);

*// inBufTestA = \{0x00000000, 0x00000000, 0x00000000, 0x80000000,*

*// 0x7FFFFFFF, 0x40000000, 0x0CCCCCCC, 0x40000000\} // shifted 3 positive*

**C**

**void** **DSP\_VectorShift** (int32\_t \* **outdata** , int32\_t \* **indata** , int **N** , int **shift** );

**DSP\_VectorSqrt Function**

Computes the square root of the first N elements of inVector, and stores the result in outVector.

**Description**

Function DSP\_VectorSqrt:

void DSP\_VectorSqrt(\_Q16 \*outVector, \_Q16 \*inVector, int N);

Computes the Sqrt(x) on the first N elements of inVector. The output is stored to outVector. Both vectors are \_Q16 format, which is 32-bit data with 15 bits for the integer and 16 bits for the fractional portion. If values exceed maximum or minimum they will saturate to the maximum or zero respectively.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. This function uses the Sqrt function from the LibQ library.

That library must be compiled as part of the project.

**Parameters**

**Parameters Description**

outdata pointer to destination array of elements (\_Q16)

indata pointer to source array of elements (\_Q16)

N number of samples (int)

**Returns**

None.

**Remarks**

This function uses the Microchip PIC32MZ LibQ library to function. The user must include that library and header file into the design in order to operate this function. For more information on the Sqrt function see the LibQ documentation for \_LIBQ\_Q16Sqrt. A negative number input will return a saturated value (0x00FFFFxx).

**Example**

int sqrtNum = 4;

\_Q16 inSqrtVec = \{0x40000000, 0xffff0000,0x00020000,0x00100000,0x00038000,

0x00400000,0xfffe0000,0x00058000\};

*// 16384.0, -1.0, 2.0, 16.0, 3.5, 64.0, -2.0, 5.5*

\_Q16 outSqrtVec = \{0\};

DSP\_VectorSqrt(outSqrtVec, inSqrtVec, sqrtNum);

*// outSqrtVec = 0x00800000, 0x00FFFF80, 0x00016A0A, 0x00040000, 0, 0, 0, 0*

*// 128.0, sat negative, 1.41422, 4.0, 0, 0, 0, 0*

**C**

**void** **DSP\_VectorSqrt** (\_Q16 \* **outVector** , \_Q16 \* **inVector** , int **N** );

**DSP\_VectorStdDev16 Function**

Computes the Standard Deviation of a Vector.

**Description**

Function DSP\_VectorStdDev16:

int16\_t DSP\_VectorStdDev16(int16\_t \*inVector, int N);

Calculates the standard deviation on the first N elements of inVector and returns the 16-bit scalar result. The standard deviation is the square root of the variance, which is a measure of the delta from mean values. The mean value of the vector is computed in

the process. The function has the form -

StdDev = SQRT(sum((x(i) - M(N))^2) / (N-1)) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and ha internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

Dependent on use of the LibQ library.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int16\_t)

N number of samples (int)

**Returns**

int16\_t - Standard Deviation of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions. This function is dependent on the LibQ library, and the \_LIBQ\_Q16Sqrt specifically.

**Example**

int16\_t vecStDevIn=\{0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333\};

*// .2, -.3, .125, .75, .2, .2, .3, .4*

int16\_t StDevOut, Var16Out;

int Nstdev = 4;

StDevOut = DSP\_VectorStdDev16(vecStDevIn, Nstdev);

*// StDevOut = 0x3A9E (= 0.45797)*

**C**

int16\_t **DSP\_VectorStdDev16** (int16\_t \* **inVector** , int **N** );

**DSP\_VectorSub16 Function**

Calculate the difference of two vectors.

**Description**

Function DSP\_VectorSub16:

void DSP\_VectorSub16(int16\_t \*outdata, int16\_t \*indata1, int16\_t \*indata2, int N);

Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q15 fractional format. outdata filled with N elements of indata1 - indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int16\_t)

indata1 pointer to input array of 16-bit elements (int16\_t)

indata2 pointer to input array of 16-bit elements (int16\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int16\_t outVal;

int16\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int16\_t inBuf2= \{ 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorSub16(pOutdata, inBufTest, inBuf2, Num);

*// outVal = inBufTest - inBuf2 = \{-6,0,-6,0,-6,-6,-9,-16\}*

**C**

**void** **DSP\_VectorSub16** (int16\_t \* **outdata** , int16\_t \* **indata1** , int16\_t \* **indata2** , int **N** );

**DSP\_VectorSub32 Function**

Calculate the difference of two vectors.

**Description**

Function DSP\_VectorSub32:

void DSP\_VectorSub32(int32\_t \*outdata, int32\_t \*indata1, int32\_t \*indata2, int N);

Computes the difference value of each element of indata1 - indata2 and stores it to outdata. The number of samples to process is given by the parameter N. Data is in a Q31 fractional format. outdata filled with N elements of indata1 - indata2

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

outdata pointer to output array of 16-bit elements (int32\_t)

indata1 pointer to input array of 16-bit elements (int32\_t)

indata2 pointer to input array of 16-bit elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t \*pOutdata;

int32\_t outVal;

int32\_t inBufTest = \{-5,2,-3,4,-1,0,-2,-8,-21,21,10,100, 200, 127,-127,-2\};

int32\_t inBuf2= \{ 1,2, 3,4, 5,6, 7, 8, 9, 10,-1,-100,-127,127,-7, 0\};

int Num = 8;

pOutdata = &outVal;

DSP\_VectorSub32(pOutdata, inBufTest, inBuf2, Num);

*// outVal = inBufTest - inBuf2 = \{-6,0,-6,0,-6,-6,-9,-16\}*

**C**

**void** **DSP\_VectorSub32** (int32\_t \* **outdata** , int32\_t \* **indata1** , int32\_t \* **indata2** , int **N** );

**DSP\_VectorSumSquares16 Function**

Computes the sum of squares of a vector, and scales the output by a binary factor.

**Description**

Function DSP\_VectorSumSquares16:

int16\_t DSP\_VectorSumSquares16(int16\_t \*indata, int N, int scale);

Calculates the sum of the squares of each element of an input vector, and scales the output. Function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after accumulation in a 32 bit register. All calculations are done in

Q15 fractional format. return = 1/(2^scale) \* sum(indata^2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to eight and a multiple of eight.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int16\_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int16\_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int16\_t inBufMultA=\{0x7FFF, 0x8000, 0x7333, 0x6666, 0x1999, 0x4000, 0x7FFF, 0xB334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int Num = 8;

int scaleVal = 3;

int16\_t outScalar;

outScalar = DSP\_VectorSumSquares16(inBufMultA, Num, scaleVal);

*// outScalar = 1/(2^scaleVal)\* sum(inBufMultA^2) =*

*// (1/8) \* (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 \* 5.1 = 0.6375*

*// = (int16\_t)0x5199*

**C**

int16\_t **DSP\_VectorSumSquares16** (int16\_t \* **indata** , int **N** , int **scale** );

**DSP\_VectorSumSquares32 Function**

Computes the sum of squares of a vector, and scales the output by a binary factor.

**Description**

Function DSP\_VectorSumSquares32:

int32\_t DSP\_VectorSumSquares32(int32\_t \*indata, int N, int scale);

Calculates the sum of the squares of each element of an input vector, and scales the output. The function will saturate if it exceeds maximum or minimum values. Scaling is done by binary shifting, after calculation of the results. All calculations are done in Q31 fractional format. return = 1/(2^scale) \* sum(indata^2)

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and multiple of

four.

**Parameters**

**Parameters Description**

indata pointer to input array of 16-bit elements (int32\_t)

scale number of bits to shift return right (int)

N number of samples (int)

**Returns**

int32\_t - scaled output of calculation, Q15 format

**Remarks**

This must be assembled with .set microMIPS.

**Example**

int32\_t inBufMultA=\{0x7FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x00000000, 0xB3333334\};

*// 1, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

int Num = 8;

int scaleVal = 3;

int32\_t outScalar;

outScalar = DSP\_VectorSumSquares32(inBufMultA, Num, scaleVal);

*// outScalar = 1/(2^scaleVal)\* sum(inBufMultA^2) =*

*// (1/8) \* (1 + 1 + 0.81 + 0.64 + 0.04 + 0.25 + 1 + 0.36) = 0.125 \* 5.1 = 0.6375*

*// = (int32\_t)0x51999999*

**C**

int32\_t **DSP\_VectorSumSquares32** (int32\_t \* **indata** , int **N** , int **scale** );

**DSP\_VectorVari16 Function**

Computes the variance of N elements of a Vector.

**Description**

Function DSP\_VectorVari16:

int16\_t DSP\_VectorVari16(int16\_t \*inVector, int N);

Calculates the variance on the first N elements of inVector and returns the 16-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -

var = sum((x(i) - M(N))^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q15 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int16\_t)

N number of samples (int)

**Returns**

int16\_t - Variance of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.

**Example**

int16\_t vecStDevIn=\{0x4000, 0xD99A, 0x1000, 0x6000,0x1999,0x1999,0x2666, 0x3333\};

*// .2, -.3, .125, .75, .2, .2, .3, .4*

int16\_t Var16Out;

int Nvar = 4;

Var16Out= DSP\_VectorVari16(vecStDevIn, Nvar); *// 16-bit variance function*

*// Var16Out = 0x1AD8 (= 0.20974)*

**C**

int16\_t **DSP\_VectorVari16** (int16\_t \* **inVector** , int **N** );

**DSP\_VectorVariance Function**

Computes the variance of N elements of inVector.

**Description**

Function DSP\_VectorVariance:

int32\_t DSP\_VectorVariance(int32\_t \*inVector, int N);

Calculates the variance on the first N elements of inVector and returns the 32-bit scalar result. The variance is a measure of the delta from mean values, and the mean value of the vector is computed in the process. The function has the form -

var = sum((x(i) - M(N))^2) / (N-1) where N is the number of vector elements x(i) is a single element in the vector M(N) is the mean of the N elements of the vector

Input values of the vector and output scalar value is Q31 fractional format. This format has data that ranges from -1 to 1, and has internal saturation limits of those same values. Some care has been taken to reduce the impact of saturation by adding processing steps to effectively complete the processing in blocks. However, in some extreme cases of data variance it is still possible to reach the saturation limits.

**Preconditions**

The pointers inVector must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

inVector pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

int32\_t - Variance of N selected elements

**Remarks**

The input vector elements number, N, must be at least 4 and a multiple of 4. This function is optimized with microMIPS and M14KCe ASE DSP instructions.

**Example**

int varN = 8;

int32\_t inVarVec = \{0xE6666667, 0x40000000,0x40000000,0x0CCCCCCC,

0x00000000,0x59999999,0x20000000,0xC0000000\};

*// -0.2, 0.5, 0.5, 0.1, 0, 0.7, 0.25, -0.5*

int32\_t outVar = 0;

outVar = DSP\_VectorVariance(inVarVec, varN);

*// outVar == 0x1490D2A6, = 0.1606696*

**C**

int32\_t **DSP\_VectorVariance** (int32\_t \* **inVector** , int **N** );

**DSP\_VectorZeroPad Function**

Fills an input vector with zeros.

**Description**

Function DSP\_VectorZeroPad:

void DSP\_VectorZeroPad(int32\_t \*indata, int N);

Fills the first N values of an input vector indata with the value zero. N must be a multiple of four and greater than or equal to four or it will be truncated to the nearest multiple of four. The vector result is in Q31 fractional format.

**Preconditions**

The pointers outdata and indata must be aligned on 4-byte boundaries. N must be greater than or equal to four and a multiple of four.

**Parameters**

**Parameters Description**

indata pointer to source array of elements (int32\_t)

N number of samples (int)

**Returns**

None.

**Remarks**

None.

**Example**

int Num = 4;

int32\_t inBufTestA=\{0x3FFFFFFF, 0x80000000, 0x73333333, 0x66666666,

0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};

*// 0.5, -1, 0.9, 0.8, 0.2, 0.5, 1, -0.6*

DSP\_VectorZeroPad(inBufTestA, Num);

*// inBufTestA = \{0x00000000, 0x00000000, 0x00000000, 0x00000000,*

*// 0x19999999, 0x40000000, 0x7FFFFFFF, 0xB3333334\};*

*// 0, 0, 0, 0, 0.2, 0.5, 1, -0.6*

**C**

**void** **DSP\_VectorZeroPad** (int32\_t \* **indata** , int **N** );

**mul16 Function**

multiply and shift integer

**C**

**static inline** int16\_t **mul16** (int16\_t **a** , int16\_t **b** );

**mul16r Function**

multiply and shift Q15

**C**

**static inline** int16\_t **mul16r** (int16\_t **a** , int16\_t **b** );

**mul32 Function**

multiply and shift Q31

**C**

**static inline** int32\_t **mul32** (int32\_t **a** , int32\_t **b** );

**SAT16 Function**

saturate both positive and negative Q15

**C**

**static inline** int32\_t **SAT16** (int32\_t **x** );

**SAT16N Function**

saturate negative Q15

**C**

**static inline** int32\_t **SAT16N** (int32\_t **x** );

**SAT16P Function**

saturate positive Q15

**C**

**static inline** int32\_t **SAT16P** (int32\_t **x** );

## LibQ

### LibQ Fixed-Point Math Library

### Introduction

This topic describes the LibQ Fixed-Point Math Library.

### Description

The LibQ Fixed-Point Math Library is available for the PIC32MZ family of microcontrollers. This library was created from optimized assembly routines written specifically for devices with microAptiv™ core features.

The LibQ Fixed-Point Math Library simplifies writing fixed point algorithms, supporting Q15, Q31 and other 16-bit and 32-bit data formats. Using the simple, C callable functions contained in the library, fast fixed point mathematical operations can be easily executed. Fixed-point mathematical calculations may replace some functions implemented in the floating point library (math.h),

depending on performance and resolution requirements.

Functions included in the LibQ library include capabilities for trigonometric, power and logarithms, and data conversion. In many cases the functions are identical other than the precision of their operands and the corresponding value that they return.

These functions are implemented in efficient assembly, and generally tuned to optimize performance over code size. In some cases the library breaks out functions that enable one to be optimized for accuracy, while another version is optimized for speed.

These functions such as

\_LIBQ\_Q2\_29\_acos\_Q31 and \_LIBQ\_Q2\_29\_acos\_Q31\_Fast are otherwise identical and can be used interchangeably. Each of these functions are typically used in computationally intensive real-time applications where execution time is a critical parameter.

**Using the Library**

This topic describes the basic architecture of the LibQ Fixed-Point Math Library and provides information and examples on its use.

**Description**

**Interface Header File:** **libq.h**

The interface to the LibQ Fixed-Point Math Library is defined in the libq.h header file. Any C language source (.c) file that uses

the LibQ Fixed-Point Library should include libq.h.

Library File:

The LibQ Fixed-Point Math Library archive (.a) file is installed with MPLAB Harmony.

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq\_c, libq/dsp libraries, as shown below

The project configuration should now contain the Math Libraries block.

Either the Speed Optimized (as shown above) or the Space Optimized versions of the library can be selected (only 1) to be generated to the project.

### Library Overview

The LibQ Fixed-Point Math Library contains functions for manipulating Q15, Q31 and other intermediate integer representations of real numbers. The Library Interface section details the operation of the data formats and explains each function in detail.

The library interface routines are divided into various sub-sections, which address one of the blocks or the overall operation of the DSP Fixed-Point Math Library.

**Library Interface Section Description**

**Divide Functions**

\_Q16 fixed point divide function.

**Square Root Functions**

Square root of a positive \_Q16 fixed point value function.

**Log Functions**

Log calculation functions.

**Power Functions**

Power calculation functions.

**Exponential Functions** Exponential calculation functions.

**Sine Functions**

Sine calculation functions.

**Cosine Functions**

Cosine calculation functions.

**Target Functions**

Target calculation functions.

**Arcsin Functions**

Arcsin calculation functions.

**Arccos Functions**

Arccos calculation functions.

**Arctan2 Functions**

Arctan2 calculation functions.

**Random Number Functions**

\_Q15 and \_Q31 pseudo-random value functions.

**Float Functions**

Float conversion functions.

**String Functions**

ASCII to \_Q15 conversions.

Signed fixed-point types are defined as follows: Qn\_m where:

• n is the number of data bits to the left of the radix point

• m is the number of data bits to the right of the radix point

• a signed bit is implied

For convenience, short names are also defined:

**Exact Name Number of Bits Required Short Name**

\_Q0\_15 16 \_Q15

\_Q15\_16 16 \_Q16

\_Q0\_31 32 \_Q31

Qn\_m numerical values are used by the library processing data as integers. In this format the n represents the number of integer bits, and the m represents the number of fractional bits. All values assume a sign bit in the most significant bit. The range of the numerical value therefore is:

-2(n-1) to ; with a resolution of 2(-m).

A \_Q16 format number (\_Q15\_16) would range from -32768.0 (0x8000 0000) to 32767.99998474 with a precision of 0.000015259

(or 2-16). For example, a numerical representation of the number 3.14159 in \_Q2\_13 notation would be:

3.14159 \* 213 = 25735.9 =\> 0x6488

And converting from the \_Q7\_8 format with the value 0x1D89 would be:

0x1D89 / 28 = 7561 / 256 =\> 29.5316, accurate to 0.00391

Functions in the library are prefixed with the type of the return value. For example, \_LIBQ\_Q16Sqrt returns a \_Q16 value equal to the square root of its argument. Argument types do not always match the return type. Refer to the function prototype for a specification of its arguments.

In cases where the return value is not a fixed-point type, the argument type is appended to the function name. For example, \_LIBQ\_ToFloatQ31 accepts a type \_Q31 argument.

In some cases, both the return type and the argument type are specified within the function name. For example:

**Function Name Return Type Argument Type**

\_LIBQ\_Q15\_sin\_Q2\_13 \_Q15 Q2\_13

\_LIBQ\_Q31\_sin\_Q2\_29 \_Q31 \_Q2\_29

### Library Interface

**Functions**

**Name Description**

\_LIBQ\_Q15\_cos\_Q2\_13 Calculates the value of cosine(x).

\_LIBQ\_Q15\_sin\_Q2\_13 Calculates the value of sine(x).

\_LIBQ\_Q15FromFloat Converts a float to a \_Q15 value.

\_LIBQ\_Q15FromString ASCII to \_Q15 conversion.

\_LIBQ\_Q15Rand Generate a \_Q15 random number.

\_LIBQ\_Q16\_tan\_Q2\_29 Calculates the value of tan(x).

\_LIBQ\_Q16Div \_Q16 fixed point divide.

\_LIBQ\_Q16Exp Calculates the exponential function e^x.

\_LIBQ\_Q16Power Calculates the value of x raised to the y power (x^y).

\_LIBQ\_Q16Sqrt Square root of a positive \_Q16 fixed point value.

\_LIBQ\_Q2\_13\_acos\_Q15 Calculates the value of acos(x).

\_LIBQ\_Q2\_13\_asin\_Q15 Calculates the asin value of asin(x).

\_LIBQ\_Q2\_13\_atan\_Q7\_8 Calculates the value of atan(x).

\_LIBQ\_Q2\_13\_atan2\_Q7\_8 Calculates the value of atan2(y, x).

\_LIBQ\_Q2\_29\_acos\_Q31 Calculates the value of acos(x).

\_LIBQ\_Q2\_29\_acos\_Q31\_Fast Calculates the value of acos(x). This function executes faster than

\_LIBQ\_Q2\_29\_acos\_Q31 but is less precise.

\_LIBQ\_Q2\_29\_asin\_Q31 Calculates the value of asin(x).

\_LIBQ\_Q2\_29\_asin\_Q31\_Fast Calculates the value of asin(x). This function executes faster than the

\_LIBQ\_Q2\_29\_asin\_Q31 function, but is less precise.

\_LIBQ\_Q2\_29\_atan\_Q16 Calculates the value of atan(x).

\_LIBQ\_Q2\_29\_atan2\_Q16 Calculates the value of atan2(y, x).

\_LIBQ\_Q3\_12\_log10\_Q16 Calculates the value of Log10(x).

\_LIBQ\_Q31\_cos\_Q2\_29 Calculates the value of cosine(x).

\_LIBQ\_Q31\_sin\_Q2\_29 Calculates the value of sine(x).

\_LIBQ\_Q31FromFloat Converts a float to a \_Q31 value.

\_LIBQ\_Q31Rand Generate a \_Q31 random number.

\_LIBQ\_Q4\_11\_ln\_Q16 Calculates the natural logarithm ln(x).

\_LIBQ\_Q5\_10\_log2\_Q16 Calculates the value of log2(x).

\_LIBQ\_Q7\_8\_tan\_Q2\_13 Calculates the value of tan(x).

\_LIBQ\_ToFloatQ15 Converts a \_Q15 value to a float.

\_LIBQ\_ToFloatQ31 Converts a \_Q31 value to a float.

\_LIBQ\_ToStringQ15 \_Q15 to ASCII conversion.

**Description**

\_ **Functions** \_

**\_LIBQ\_Q15\_cos\_Q2\_13 Function**

Calculates the value of cosine(x).

**Description**

Function \_LIBQ\_Q15\_cos\_Q2\_13:

\_Q15 \_LIBQ\_Q15\_cos\_Q2\_13 (\_Q2\_13 x);

Calculates the cosine(x), where x is of type \_Q2\_13 radians and the resulting value is of type \_Q15.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The \_Q2\_13 input value from which to calculate cosine(x).

**Returns**

\_LIBQ\_Q15\_cos\_Q2\_13 returns the \_Q15 fixed point result from the calculation cosine(x).

**Remarks**

Execution Time (cycles): 102 cycles Program Memory 224 bytes

Error <= 0.00003052 (accurate to least significant \_Q15 bit)

**Example**

\_Q15 resultCos;

resultCos = \_LIBQ\_Q15\_cos\_Q2\_13 ((\_Q2\_13)0x2171); \_// *LIBQ\_Q15\_cos\_Q2\_13(1.045044) = 0.501862*

*(0x403d)*

**C**

\_Q15 **\_LIBQ\_Q15\_cos\_Q2\_13** (\_Q2\_13 **x** );

**\_LIBQ\_Q15\_sin\_Q2\_13 Function**

Calculates the value of sine(x).

**Description**

Function \_LIBQ\_Q15\_sin\_Q2\_13:

\_Q15 \_LIBQ\_Q15\_sin\_Q2\_13 (\_Q2\_13 x);

Calculates the sine(x), where x is of type \_Q2\_13 radians and the resulting value is of type \_Q15.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q2\_13 input value from which to calculate sine(x).

**Returns**

\_LIBQ\_Q15\_sin\_Q2\_13 returns the \_Q15 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 100 typical (100 to 102) Program Memory 220 bytes

Error <= 0.00003052 (accurate to least significant \_Q15 bit)

**Example**

\_Q15 resultSin;

resultSin = \_LIBQ\_Q15\_sin\_Q2\_13 ((\_Q2\_13)0x4093); \_// *LIBQ\_Q15\_sin\_Q2\_13(2.017944) = 0.901672*

*(0x736a)*

**C**

\_Q15 **\_LIBQ\_Q15\_sin\_Q2\_13** (\_Q2\_13 **x** );

**\_LIBQ\_Q15FromFloat Function**

Converts a float to a \_Q15 value.

**Description**

Function \_LIBQ\_Q15FromFloat:

\_Q15 \_LIBQ\_Q15FromFloat(float x);

Converts a floating point value to a \_Q15 fixed point representation. The \_Q15 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the \_Q15 representation.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The float point value to convert to \_Q15 fixed point

**Returns**

\_LIBQ\_Q15FromFloat returns the \_Q15 fixed point value corresponding to the floating point (float) input value.

**Remarks**

The C library functions \_\_gesf2, \_\_lesf2, \_\_addsf3, \_\_mulsf3, and \_\_fixsfsi are called by this routine and thus must be linked into

the executable image.

Execution Time (cycles): 213 typical (158 to 224) Program Memory 96 bytes

**Example**

\_Q15 q15;

q15 = \_LIBQ\_Q15FromFloat(( **float** )0.5); \_// q15 now equals (*Q15)0x4000*

q15 = \_LIBQ\_Q15FromFloat(( **float** )-1.0); \_// q15 now equals (*Q15)0x8000*

q15 = \_LIBQ\_Q15FromFloat(( **float** )-0.233828); \_// q15 now equals (*Q15)0xe212*

**C**

\_Q15 **\_LIBQ\_Q15FromFloat** ( **float** **x** );

**\_LIBQ\_Q15FromString Function**

ASCII to \_Q15 conversion.

**Description**

Function \_LIBQ\_Q15FromString:

\_Q15 \_LIBQ\_Q15FromString(char \*s);

Convert an ASCII string into a \_Q15 fixed point value. The ASCII string must be in an -N.NNNNNN format. Leading spaces are ignored. The conversion stops at either the first non-conforming character in the string or the Null string terminator. There must be no spaces within the string value itself.

**Preconditions**

None.

**Parameters**

**Parameters Description**

s A pointer to the ASCII input string representing the \_Q15 fixed point value.

**Returns**

\_LIBQ\_Q15FromString returns the \_Q15 fixed point value represented by the input string.

**Remarks**

Execution Time (cycles): 296 typical (28 to 346) Program Memory 172 bytes

**Example**

\_Q15 x;

x = \_LIBQ\_Q15FromString("0.125"); *// x will equal 0.125 using*

*// an internal value of 0x1000*

x = \_LIBQ\_Q15FromString("-1.0"); *// x will equal -1.0 using*

*// an internal value of 0x8000*

x = \_LIBQ\_Q15FromString("0.999969"); *// x will equal 0.999969 using*

*// an internal value of 0x7FFF*

**C**

\_Q15 **\_LIBQ\_Q15FromString** ( **char** \* **s** );

**\_LIBQ\_Q15Rand Function**

Generate a \_Q15 random number.

**Description**

Function \_LIBQ\_Q15Rand:

\_Q15 \_LIBQ\_Q15Rand (int64\_t \*pSeed);

Generates a \_Q15 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.

The function updates the \*pSeed value each time it is called. The updated \*pSeed value must be passed back to the function with each subsequent call.

Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.

**Preconditions**

None.

**Parameters**

**Parameters Description**

pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.

**Returns**

\_LIBQ\_Q15Rand returns a random \_Q15 value. \_LIBQ\_Q15Rand also updates the int64\_t \*pSeed value.

**Remarks**

Execution Time (cycles): 32 Program Memory 92 bytes

**Example**

*// Initialize seed to a constant or random value*

**static** int64\_t randomSeed = 0xA71078BE72D4C1F1;

\_Q15 randomValue;

randomValue = \_LIBQ\_Q15Rand(&randomSeed);

...

randomValue = \_LIBQ\_Q15Rand(&randomSeed);

**C**

\_Q15 **\_LIBQ\_Q15Rand** (int64\_t \* **pSeed** );

**\_LIBQ\_Q16\_tan\_Q2\_29 Function**

Calculates the value of tan(x).

**Description**

Function \_LIBQ\_Q16\_tan\_Q2\_29:

\_Q16 \_LIBQ\_Q16\_tan\_Q2\_29 (\_Q2\_29 x);

Calculates the tan(x), where x is of type \_Q2\_29 radians and the resulting value is of type \_Q16.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The \_Q2\_29 input value from which to calculate tan(x).

**Returns**

\_LIBQ\_Q16\_tan\_Q2\_29 returns the \_Q16 fixed point result from the calculation tan(x). The resulting value is saturated.

**Remarks**

The functions \_LIBQ\_Q31\_sin\_Q2\_29, \_LIBQ\_Q31\_cos\_Q2\_29, and \_LIBQ\_Q16Div are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 703 typical (22 to 796) Program Memory 88 bytes

Error <= 0.000015259 (accurate to least significant \_Q16 bit for the input range -1.568 .. 1.568) Error rises from 0.0 to 0.065 for

the input range -1.568 .. -1.570765808 and 1.568 .. 1.570765808)

**Example**

\_Q16 resultTan;

resultTan = \_LIBQ\_Q16\_tan\_Q2\_29 ((\_Q2\_29)0x16720c36); \_// *LIBQ\_Q16\_tan\_Q2\_29( 0.701421838) =*

*0.844726562 (0x0000d840)*

**C**

\_Q16 **\_LIBQ\_Q16\_tan\_Q2\_29** (\_Q2\_29 **x** );

**\_LIBQ\_Q16Div Function**

\_Q16 fixed point divide.

**Description**

Function \_LIBQ\_Q16Div:

\_Q16 \_LIBQ\_Q16Div (\_Q16 dividend, \_Q16 divisor);

Quotient (\_Q16) = Dividend (\_Q16) / Divisor (\_Q16).

**Preconditions**

Divisor must not equal 0.

**Parameters**

**Parameters Description**

dividend The divide operation dividend (\_Q16)

divisor The divide operation divisor (\_Q16)

**Returns**

\_Q16 quotient of the divide operation

**Remarks**

The \_LIBQ\_Q16Div operation saturates its result.

Execution Time (cycles): 143 typical (80 to 244) Program Memory 204 bytes

Error <= 0.000015258789 (accurate to least significant \_Q16 bit within the non-saturated range)

**Example**

\_Q16 quotient, dividend, divisor;

dividend = (\_Q16)0x00010000; *// 1*

divisor = (\_Q16)0x00008000; *// 0.5*

quotient = \_LIBQ\_Q16Div (dividend, divisor);

\_// quotient now equals 2; i.e., (*Q16)0x00020000;*

**C**

\_Q16 **\_LIBQ\_Q16Div** (\_Q16 **dividend** , \_Q16 **divisor** );

**\_LIBQ\_Q16Exp Function**

Calculates the exponential function e^x.

**Description**

Function \_LIBQ\_Q16Exp:

\_Q16 \_LIBQ\_Q16Exp(\_Q16 x);

Calculates the exponential function e^x. The calculation will saturate if the resulting value is outside the range of the \_Q16 representation. For x \> 10.3972015380859375, the resulting value will be saturated to 0x7fffffff. For x < -10.3972015380859375 the resulting value will be saturated to 0.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The exponent value

**Returns**

\_LIBQ\_Q16Exp returns the \_Q16 fixed point result from the calculation e^x.

**Remarks**

The function \_LIBQ\_Q16Div is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 170 typical (18 to 292) Program Memory 446 bytes

Error <= 0.000015258789 (accurate to least significant \_Q16 bit within the non-saturated range)

**Example**

\_Q16 expResult;

expResult = \_LIBQ\_Q16Exp((\_Q16)0x00010000); \_// *LIBQ\_Q16Exp(1.000000) = 2.718277 (0x0002b7e1)*

**C**

\_Q16 **\_LIBQ\_Q16Exp** (\_Q16 **x** );

**\_LIBQ\_Q16Power Function**

Calculates the value of x raised to the y power (x^y).

**Description**

Function \_LIBQ\_Q16Power:

\_Q16 \_LIBQ\_Q16Power (\_Q16 x, \_Q16 y);

Calculates the x raised to the y power. Both x and y are of type \_Q16. x must be positive. The calculation will saturate if the resulting value is outside the range of the \_Q16 representation.

**Preconditions**

x must be positive.

**Parameters**

**Parameters Description**

x The \_Q16 input value x from which to calculate x raised to the y.

y The \_Q16 input value y from which to calculate x raised to the y.

**Returns**

\_LIBQ\_Q16Power returns the \_Q16 fixed point result from the calculation x raised to the y.

**Remarks**

Execution Time (cycles): 882 typical (586 to 1042) Program Memory 1038 bytes

Error <= 0.000015258789 (accurate to least significant \_Q16 bit within the non-saturated range)

**Example**

\_Q16 resultPower;

resultPower = \_LIBQ\_Q16Power ((\_Q16)0x00020000, (\_Q16)0xffff0000); \_// *LIBQ\_Q16Power(2.000000,*

*-1.000000) = 0.500000 (0x00008000)*

**C**

\_Q16 **\_LIBQ\_Q16Power** (\_Q16 **x** , \_Q16 **y** );

**\_LIBQ\_Q16Sqrt Function**

Square root of a positive \_Q16 fixed point value.

**Description**

Function \_LIBQ\_Q16Sqrt:

\_Q16 \_LIBQ\_Q16Sqrt(\_Q16 x);

Calculate the square root of a positive \_Q16 fixed point value, and return the \_Q16 result.

**Preconditions**

The input value must be positive.

**Parameters**

**Parameters Description**

x The \_Q16 fixed point value input from which to find the square root.

**Returns**

\_LIBQ\_Q16Sqrt returns the \_Q16 fixed point value which is the square root of the input parameter.

**Remarks**

Execution Time (cycles): 240 typical (104 to 258) Program Memory 152 bytes

Error <= 0.000015258789 (accurate to least significant \_Q16 bit)

**Example**

\_Q16 squareRoot;

squareRoot = \_LIBQ\_Q16Sqrt((\_Q16)0x01000000); *// The square root of 256.0 is 16.0 (0x00100000)*

squareRoot = \_LIBQ\_Q16Sqrt((\_Q16)0x00004000); *// The square root of 0.25 is 0.5 (0x00008000)*

squareRoot = \_LIBQ\_Q16Sqrt((\_Q16)0x5851f42d); *// The square root of 22609.953125 is 150.366074*

*(0x00965db7)*

**C**

\_Q16 **\_LIBQ\_Q16Sqrt** (\_Q16 **x** );

**\_LIBQ\_Q2\_13\_acos\_Q15 Function**

Calculates the value of acos(x).

**Description**

Function \_LIBQ\_Q2\_13\_acos\_Q15:

\_Q2\_13 \_LIBQ\_Q2\_13\_acos\_Q15 (\_Q15 x);

Calculates the acos(x), where x is of type \_Q15 and the resulting value is of type \_Q2\_13. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q15 input value from which to calculate acos(x).

**Returns**

\_LIBQ\_Q2\_13\_acos\_Q15 returns the \_Q2\_13 fixed point result from the calculation acos(x).

**Remarks**

The function \_LIBQ\_Q2\_13\_asin\_Q15 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 588 typical (32 to 666) Program Memory 24 bytes

Error <= 0.00012207 (accurate to least significant \_Q2\_13 bit)

A higher precision function with equivalent performance exists, see \_LIBQ\_Q2\_29\_acos\_Q31\_Fast

**Example**

\_Q2\_13 resultAcos;

resultAcos = \_LIBQ\_Q2\_13\_acos\_Q15((\_Q15)0x2993); \_// *LIBQ\_Q2\_13\_acos\_Q15(0.324799) = 1.239990*

*(0x27ae)*

**C**

\_Q2\_13 **\_LIBQ\_Q2\_13\_acos\_Q15** (\_Q15 **x** );

**\_LIBQ\_Q2\_13\_asin\_Q15 Function**

Calculates the asin value of asin(x).

**Description**

Function \_LIBQ\_Q2\_13\_asin\_Q15:

\_Q2\_13 \_LIBQ\_Q2\_13\_asin\_Q15 (\_Q15 x);

Calculates asin(x), where x is of type \_Q15 and the resulting value is of type \_Q2\_13. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q15 input value from which to calculate asin(x).

**Returns**

\_LIBQ\_Q2\_13\_asin\_Q15 returns the \_Q2\_13 fixed point result from the calculation asin(x).

**Remarks**

The functions \_LIBQ\_Q16Sqrt and \_LIBQ\_Q16Div are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 578 typical (22 to 656) Program Memory 336 bytes

Error <= 0.00012207 (accurate to least significant \_Q2\_13 bit)

A higher resolution version of this function exists with equivalent performance, see \_LIBQ\_Q2\_29\_asin\_Q31\_Fast

**Example**

\_Q2\_13 resultAsin;

resultAsin = \_LIBQ\_Q2\_13\_asin\_Q15 ((\_Q15)0x3231); \_// *LIBQ\_Q2\_13\_asin\_Q15(0.392120) = 0.402954*

*(0x0ce5)*

**C**

\_Q2\_13 **\_LIBQ\_Q2\_13\_asin\_Q15** (\_Q15 **x** );

**\_LIBQ\_Q2\_13\_atan\_Q7\_8 Function**

Calculates the value of atan(x).

**Description**

Function \_LIBQ\_Q2\_13\_atan\_Q7\_8:

\_Q2\_13 \_LIBQ\_Q2\_13\_atan\_Q7\_8 (\_Q7\_8 x);

Calculates the atan(x), where x is of type \_Q7\_8 and the resulting value is of type \_Q2\_13. The output value will be radians in the

range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q7\_8 input value from which to calculate atan(x).

**Returns**

\_LIBQ\_Q2\_13\_atan\_Q7\_8 returns the \_Q2\_13 fixed point result from the calculation atan(x).

**Remarks**

The function \_LIBQ\_Q2\_13\_atan2\_Q7\_8 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 240 typical (202 to 256) Program Memory 16 bytes

Error <= 0.00012207 (accurate to least significant \_Q2\_13 bit)

**Example**

\_Q2\_13 resultAtan;

resultAtan = \_LIBQ\_Q2\_13\_atan\_Q7\_8 ((\_Q7\_8)0x0097); \_// *LIBQ\_Q2\_13\_atan\_Q7\_8(0.589844) =*

*0.532959 (0x110e)*

**C**

\_Q2\_13 **\_LIBQ\_Q2\_13\_atan\_Q7\_8** (\_Q7\_8 **x** );

**\_LIBQ\_Q2\_13\_atan2\_Q7\_8 Function**

Calculates the value of atan2(y, x).

**Description**

Function \_LIBQ\_Q2\_13\_atan2\_Q7\_8:

\_Q2\_13 \_LIBQ\_Q2\_13\_atan2\_Q7\_8 (\_Q7\_8 y, \_Q7\_8 x);

Calculates the atan2(y, x), where y and x are of type \_Q7\_8 and the resulting value is of type \_Q2\_13. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

y The \_Q7\_8 input value from which to calculate atan2(y, x).

x The \_Q7\_8 input value from which to calculate atan2(y, x).

**Returns**

\_LIBQ\_Q2\_13\_atan2\_Q7\_8 returns the \_Q2\_13 fixed point result from the calculation atan2(y, x).

**Remarks**

The function \_LIBQ\_Q16Div is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 220 typical (22 to 250) Program Memory 288 bytes

Error <= 0.00012207 (accurate to least significant \_Q2\_13 bit)

**Example**

\_Q2\_13 resultAtan2;

resultAtan2 = \_LIBQ\_Q2\_13\_atan2\_Q7\_8 ((\_Q7\_8)0x589d, (\_Q7\_8)0xf878); *//*

\_*LIBQ\_Q2\_13\_atan2\_Q7\_8(88.613281, -7.531250) = 1.655518 (0x34fa)*

**C**

\_Q2\_13 **\_LIBQ\_Q2\_13\_atan2\_Q7\_8** (\_Q7\_8 **y** , \_Q7\_8 **x** );

**\_LIBQ\_Q2\_29\_acos\_Q31 Function**

Calculates the value of acos(x).

**Description**

Function \_LIBQ\_Q2\_29\_acos\_Q31:

\_Q2\_29 \_LIBQ\_Q2\_29\_acos\_Q31 (\_Q31 x);

Calculates the acos(x), where x is of type \_Q31 and the resulting value is of type \_Q2\_29. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q31 input value from which to calculate acos(x).

**Returns**

\_LIBQ\_Q2\_29\_acos\_Q31 returns the \_Q2\_29 fixed point result from the calculation acos(x).

**Remarks**

The functions \_LIBQ\_Q2\_29\_asin\_Q31\_Fast and \_LIBQ\_Q31\_cos\_Q2\_29 are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 3370 typical (70 to 4824) Program Memory 142 bytes

Error <= 0.0000000019 (accurate to least significant \_Q2\_29 bit for the range -0.9993..0.9993) Error <= 0.0000000355 (accurate to 5th least significant \_Q2\_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)

A similar function with higher performance and reduced precision exists, see \_LIBQ\_Q2\_29\_acos\_Q31\_Fast

**Example**

\_Q2\_29 resultAcos;

resultAcos = \_LIBQ\_Q2\_29\_acos\_Q31 ((\_Q31)0xee63708c); \_// *LIBQ\_Q2\_29\_acos\_Q31(-0.1375903431)*

*= 1.7088244837 (0x36aeb0af)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_acos\_Q31** (\_Q31 **x** );

**\_LIBQ\_Q2\_29\_acos\_Q31\_Fast Function**

Calculates the value of acos(x). This function executes faster than \_LIBQ\_Q2\_29\_acos\_Q31 but is less precise.

**Description**

Function \_LIBQ\_Q2\_29\_acos\_Q31\_Fast:

\_Q2\_29 \_LIBQ\_Q2\_29\_acos\_Q31\_Fast (\_Q31 x);

Calculates the acos(x), where x is of type \_Q31 and the resulting value is of type \_Q2\_29. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q31 input value from which to calculate acos(x).

**Returns**

\_LIBQ\_Q2\_29\_acos\_Q31\_Fast returns the \_Q2\_29 fixed point result from the calculation acos(x).

**Remarks**

The function \_LIBQ\_Q2\_29\_asin\_Q31\_Fast is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 517 typical (32 to 1310) Program Memory 28 bytes

Error <= 0.000000911 (accurate to 9 least significant \_Q2\_29 bits)

A higher precision function with reduced performance exists, see \_LIBQ\_Q2\_29\_acos\_Q31

**Example**

\_Q2\_29 resultAcos;

resultAcos = \_LIBQ\_Q2\_29\_acos\_Q31\_Fast ((\_Q31)0xee63708c); *//*

\_*LIBQ\_Q2\_29\_acos\_Q31\_Fast(-0.1375903431) = 1.7088244837 (0x36aeb0af)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_acos\_Q31\_Fast** (\_Q31 **x** );

**\_LIBQ\_Q2\_29\_asin\_Q31 Function**

Calculates the value of asin(x).

**Description**

Function \_LIBQ\_Q2\_29\_asin\_Q31:

\_Q2\_29 \_LIBQ\_Q2\_29\_asin\_Q31 (\_Q31 x);

Calculates the asin(x), where x is of type \_Q31 and the resulting value is of type \_Q2\_29. The output value will be in radians the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q31 input value from which to calculate asin(x).

**Returns**

\_LIBQ\_Q2\_29\_asin\_Q31 returns the \_Q2\_29 fixed point result from the calculation asin(x).

**Remarks**

The functions \_LIBQ\_Q2\_29\_asin\_Q31\_Fast and\_LIBQ\_Q31\_sin\_Q2\_29 are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 2525 typical (286 to 4330) Program Memory 138 bytes

Error <= 0.0000000019 (accurate to least significant \_Q2\_29 bit for the range -0.9993..0.9993) Error <= 0.0000000346 (accurate to 5th least significant \_Q2\_29 bit for the range -1.0 .. -0.9993 and 0.9993 .. 1.0)

A faster version of this function exists with modestly reduced accuracy, see \_LIBQ\_Q2\_29\_asin\_Q31\_Fast

**Example**

\_Q2\_29 resultAsin;

resultAsin = \_LIBQ\_Q2\_29\_asin\_Q31 ((\_Q31)0x7fe50658); \_// *LIBQ\_Q2\_29\_asin\_Q31( 0.9991767816)*

*= 1.5302172359 (0x30f78a23)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_asin\_Q31** (\_Q31 **x** );

**\_LIBQ\_Q2\_29\_asin\_Q31\_Fast Function**

Calculates the value of asin(x). This function executes faster than the \_LIBQ\_Q2\_29\_asin\_Q31 function, but is less precise.

**Description**

Function \_LIBQ\_Q2\_29\_asin\_Q31\_Fast:

\_Q2\_29 \_LIBQ\_Q2\_29\_asin\_Q31\_Fast (\_Q31 x);

Calculates the asin(x), where x is of type \_Q31 and the resulting value is of type \_Q2\_29. The output value will be in radians the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q31 input value from which to calculate asin(x).

**Returns**

\_LIBQ\_Q2\_29\_asin\_Q31\_Fast returns the \_Q2\_29 fixed point result from the calculation asin(x).

**Remarks**

Execution Time (cycles): 507 typical (22 to 1300) Program Memory 638 bytes

Error <= 0.000000911 (accurate to 9 least significant \_Q2\_29 bits)

A higher resolution version of this function exists with reduced performance, see \_LIBQ\_Q2\_29\_asin\_Q31

**Example**

\_Q2\_29 resultAsin;

resultAsin = \_LIBQ\_Q2\_29\_asin\_Q31\_Fast ((\_Q31)0x7fe50658); \_// *LIBQ\_Q2\_29\_asin\_Q31\_Fast(*

*0.9991767816) = 1.5302172359 (0x30f78a23)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_asin\_Q31\_Fast** (\_Q31 **x** );

**\_LIBQ\_Q2\_29\_atan\_Q16 Function**

Calculates the value of atan(x).

**Description**

Function \_LIBQ\_Q2\_29\_atan\_Q16:

\_Q2\_29 \_LIBQ\_Q2\_29\_atan\_Q16 (\_Q16 x);

Calculates the atan(x), where x is of type \_Q16 and the resulting value is of type \_Q2\_29. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q16 input value from which to calculate atan(x).

**Returns**

\_LIBQ\_Q2\_29\_atan\_Q16 returns the \_Q2\_29 fixed point result from the calculation atan(x).

**Remarks**

The function \_LIBQ\_Q2\_29\_atan2\_Q16 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 354 typical (178 to 360) Program Memory 16 bytes

Error <= 0.000000003 (accurate within one least significant \_Q2\_29 bit)

**Example**

\_Q2\_29 resultAtan;

resultAtan = \_LIBQ\_Q2\_29\_atan\_Q16 ((\_Q16)0x00098b31); \_// *LIBQ\_Q2\_29\_atan\_Q16(9.543716) =*

*1.466396 (0x2eecb7ee)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_atan\_Q16** (\_Q16 **x** );

**\_LIBQ\_Q2\_29\_atan2\_Q16 Function**

Calculates the value of atan2(y, x).

**Description**

Function \_LIBQ\_Q2\_29\_atan2\_Q16:

\_Q2\_29 \_LIBQ\_Q2\_29\_atan2\_Q16 (\_Q16 y, \_Q16 x);

Calculates the atan(y, x), where y and x are of type \_Q16 and the resulting value is of type \_Q2\_29. The output value will be radians in the range pi \>= result \>= -pi.

**Preconditions**

None.

**Parameters**

**Parameters Description**

y The \_Q16 input value from which to calculate atan2(y, x).

x The \_Q16 input value from which to calculate atan2(y, x).

**Returns**

\_LIBQ\_Q2\_29\_atan2\_Q16 returns the \_Q2\_29 fixed point result from the calculation atan2(y, x).

**Remarks**

The C function \_\_divdi3 is called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 348 typical (20 to 376) Program Memory 464 bytes

Error <= 0.000000003 (accurate within one least significant \_Q2\_29 bit)

**Example**

\_Q2\_29 resultAtan2;

resultAtan2 = \_LIBQ\_Q2\_29\_atan2\_Q16 ((\_Q16)0xf6276270, x(\_Q16)0x34b4b4c0); *//*

\_*LIBQ\_Q2\_29\_atan2\_Q16(-2520.615479, 13492.706055) = -0.184684 (0xfa1710c7)*

**C**

\_Q2\_29 **\_LIBQ\_Q2\_29\_atan2\_Q16** (\_Q16 **y** , \_Q16 **x** );

**\_LIBQ\_Q3\_12\_log10\_Q16 Function**

Calculates the value of Log10(x).

**Description**

Function \_LIBQ\_Q3\_12\_log10\_Q16:

\_Q3\_12 \_LIBQ\_Q3\_12\_log10\_Q16 (\_Q16 x);

Calculates the log10(x), where log10(x) = ln(x) \* log10(e). x is of type \_Q16 and must be positive. The resulting value is of type \_Q3\_12.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate log10(x).

**Returns**

\_LIBQ\_Q3\_12\_log10\_Q16 returns the \_Q3\_12 fixed point result from the calculation log10(x).

**Remarks**

Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes

Error <= 0.000244140625 (accurate to least significant \_Q3\_12 bit)

**Example**

\_Q3\_12 resultLog10;

resultLog10 = \_LIBQ\_Q3\_12\_log10\_Q16 ((\_Q16)0x12ed7d91); \_// *LIBQ\_Q3\_12\_log10\_Q16(4845.490494)*

*= 3.685303 (0x3af7)*

**C**

\_Q3\_12 **\_LIBQ\_Q3\_12\_log10\_Q16** (\_Q16 **x** );

**\_LIBQ\_Q31\_cos\_Q2\_29 Function**

Calculates the value of cosine(x).

**Description**

Function \_LIBQ\_Q31\_cos\_Q2\_29:

\_Q31 \_LIBQ\_Q31\_cos\_Q2\_29 (\_Q2\_29 x);

Calculates the cosine(x), where x is of type \_Q2\_29 radians and the resulting value is of type \_Q31.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q2\_29 input value from which to calculate cosine(x).

**Returns**

\_LIBQ\_Q31\_cos\_Q2\_29 returns the \_Q31 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 265 typical (22 to 288) Program Memory 746 bytes

Error <= 0.00000000047 (accurate to least significant \_Q31 bit)

**Example**

\_Q31 resultCos;

resultCos = \_LIBQ\_Q31\_cos\_Q2\_29 ((\_Q2\_29)0x07e2e1c2); \_// *LIBQ\_Q31\_cos\_Q2\_29( 0.246445540) =*

*0.969785686 (0x7c21eff7)*

**C**

\_Q31 **\_LIBQ\_Q31\_cos\_Q2\_29** (\_Q2\_29 **x** );

**\_LIBQ\_Q31\_sin\_Q2\_29 Function**

Calculates the value of sine(x).

**Description**

Function \_LIBQ\_Q31\_sin\_Q2\_29:

\_Q31 \_LIBQ\_Q31\_sin\_Q2\_29 (\_Q2\_29 x);

Calculates the sine(x), where x is of type \_Q2\_29 radians and the resulting value is of type \_Q31.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q2\_29 input value from which to calculate sine(x).

**Returns**

\_LIBQ\_Q31\_sin\_Q2\_29 returns the \_Q31 fixed point result from the calculation sine(x).

**Remarks**

Execution Time (cycles): 246 typical (244 to 266) Program Memory 598 bytes

Error <= 0.00000000047 (accurate to least significant \_Q31 bit)

**Example**

\_Q31 resultSin;

resultSin = \_LIBQ\_Q31\_sin\_Q2\_29 ((\_Q2\_29)0x5a637cfe); \_// *LIBQ\_Q31\_sin\_Q2\_29( 2.824644562) =*

*0.311668121 (0x27e4bdb1)*

**C**

\_Q31 **\_LIBQ\_Q31\_sin\_Q2\_29** (\_Q2\_29 **x** );

**\_LIBQ\_Q31FromFloat Function**

Converts a float to a \_Q31 value.

**Description**

Function \_LIBQ\_Q31FromFloat:

\_Q31 \_LIBQ\_Q31FromFloat(float x);

Converts a floating point value to a \_Q31 fixed point representation. The \_Q31 fixed point value is returned by the function. The conversion will saturate if the value is outside the range of the \_Q31 representation.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The floating point value to convert to \_Q31 fixed point.

**Returns**

\_LIBQ\_Q31FromFloat returns the \_Q31 fixed point value corresponding to the floating point (float) input value.

**Remarks**

The C library functions \_\_gesf2, \_\_lesf2, \_\_addsf3, \_\_mulsf3, and \_\_fixsfsi are called by this routine and thus must be linked into the executable image.

Execution Time (cycles): 210 typical (158 to 214) Program Memory 100 bytes

**Example**

\_Q31 q31;

q31 = \_LIBQ\_Q31FromFloat(( **float** )0.000008); \_// q31 now equals (*Q31)0x00004000*

q31 = \_LIBQ\_Q31FromFloat(( **float** )-1.0); \_// q31 now equals (*Q31)0x80000000*

q31 = \_LIBQ\_Q31FromFloat(( **float** )0.690001); \_// q31 now equals (*Q31)0x5851f400*

**C**

\_Q31 **\_LIBQ\_Q31FromFloat** ( **float** **x** );

**\_LIBQ\_Q31Rand Function**

Generate a \_Q31 random number.

**Description**

Function \_LIBQ\_Q31Rand:

\_Q31 \_LIBQ\_Q31Rand (int64\_t \*pSeed);

Generates a \_Q31 pseudo-random value based on the seed supplied as a parameter. The first time this function is called, the seed value must be supplied by the user; this initial seed value can either be constant or random, depending on whether the user wants to generate a repeatable or a non-repeatable pseudo-random sequence.

The function updates the \*pSeed value each time it is called. The updated \*pSeed value must be passed back to the function with each subsequent call.

Warning: The pseudo-random sequence generated by this function may be insufficient for cryptographic use.

**Preconditions**

None.

**Parameters**

**Parameters Description**

pSeed A pointer to the seed value used by the function to generate a pseudo-random sequence.

**Returns**

\_LIBQ\_Q31Rand returns a pseudo-random \_Q31 value. \_LIBQ\_Q31Rand also updates the int64\_t \*pSeed value.

**Remarks**

Execution Time (cycles): 32 Program Memory 88 bytes

**Example**

*// Initialize seed to a constant or random value*

**static** int64\_t randomSeed = 0x7F18BA710E72D4C1;

\_Q31 randomValue;

randomValue = \_LIBQ\_Q31Rand(&randomSeed);

...

randomValue = \_LIBQ\_Q31Rand(&randomSeed);

**C**

\_Q31 **\_LIBQ\_Q31Rand** (int64\_t \* **pSeed** );

**\_LIBQ\_Q4\_11\_ln\_Q16 Function**

Calculates the natural logarithm ln(x).

**Description**

Function \_LIBQ\_Q4\_11\_ln\_Q16:

\_Q4\_11 \_LIBQ\_Q4\_11\_ln\_Q16 (\_Q16 x);

Calculates the natural logarithm ln(x). x is of type \_Q16 and must be positive. The resulting value is of type \_Q4\_11.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate ln(x).

**Returns**

\_LIBQ\_Q4\_11\_ln\_Q16 returns the \_Q4\_11 fixed point result from the calculation ln(x).

**Remarks**

Execution Time (cycles): 301 typical (14 to 346) Program Memory 176 bytes

Error <= 0.00048828 (accurate to least significant \_Q4\_11 bit)

**Example**

\_Q4\_11 resultLN;

resultLN = \_LIBQ\_Q4\_11\_ln\_Q16 ((\_Q16)0x00004000); \_// *LIBQ\_Q4\_11\_LN\_Q16(0.250000) = -1.386230*

*(0xf4e9)*

**C**

\_Q4\_11 **\_LIBQ\_Q4\_11\_ln\_Q16** (\_Q16 **x** );

**\_LIBQ\_Q5\_10\_log2\_Q16 Function**

Calculates the value of log2(x).

**Description**

Function \_LIBQ\_Q5\_10\_log2\_Q16:

\_Q5\_10 \_LIBQ\_Q5\_10\_log2\_Q16 (\_Q16 x);

Calculates the log2(x), where log2(x) = ln(x) \* log2(e). x is of type \_Q16 and must be positive. The resulting value is of type \_Q5\_10.

**Preconditions**

The input x must be positive.

**Parameters**

**Parameters Description**

x The input value from which to calculate log2(x).

**Returns**

\_LIBQ\_Q5\_10\_log2\_Q16 returns the \_Q5\_10 fixed point result from the calculation log2(x).

**Remarks**

Execution Time (cycles): 227 typical (14 to 268) Program Memory 164 bytes

Error <= 0.0009765625 (accurate to least significant \_Q5\_10 bit)

**Example**

\_Q5\_10 resultLog2;

resultLog2 = \_LIBQ\_Q5\_10\_log2\_Q16 ((\_Q16)0x40000000); \_// *LIBQ\_Q5\_10\_log2\_Q16(16384.000000) =*

*14.000000 (0x3800)*

**C**

\_Q5\_10 **\_LIBQ\_Q5\_10\_log2\_Q16** (\_Q16 **x** );

**\_LIBQ\_Q7\_8\_tan\_Q2\_13 Function**

Calculates the value of tan(x).

**Description**

Function \_LIBQ\_Q7\_8\_tan\_Q2\_13:

\_Q7\_8 \_LIBQ\_Q7\_8\_tan\_Q2\_13 (\_Q2\_13 x);

Calculates the tan(x), where x is of type \_Q2\_13 radians and the resulting value is of type \_Q7\_8.

**Preconditions**

None

**Parameters**

**Parameters Description**

x The \_Q2\_13 input value from which to calculate tan(x).

**Returns**

\_LIBQ\_Q7\_8\_tan\_Q2\_13 returns the \_Q7\_8 fixed point result from the calculation tan(x).

**Remarks**

Execution Time (cycles): 288 typical (18 to 346) Program Memory 980 bytes

Error <= 0.00390625 (accurate to least significant \_Q7\_8 bit)

**Example**

\_Q7\_8 resultTan;

resultTan = \_LIBQ\_Q7\_8\_tan\_Q2\_13 ((\_Q2\_13)0x2e20); \_// *LIBQ\_Q7\_8\_tan\_Q2\_13(1.441406) =*

*7.683594 (0x07af)*

**C**

\_Q7\_8 **\_LIBQ\_Q7\_8\_tan\_Q2\_13** (\_Q2\_13 **x** );

**\_LIBQ\_ToFloatQ15 Function**

Converts a \_Q15 value to a float.

**Description**

Function \_LIBQ\_ToFloatQ15:

float \_LIBQ\_ToFloatQ15(\_Q15 x);

Converts a \_Q15 fixed point value to a floating point representation. The floating point value is returned by the function.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q15 fixed point value to convert to float

**Returns**

\_LIBQ\_ToFloatQ15 returns the floating point (float) value corresponding to the \_Q15 input value.

**Remarks**

The C library functions \_\_floatsisf and \_\_divsf3 are called by this routine and thus must be linked in to the executable image.

Execution Time (cycles): 158 typical (54 to 176) Program Memory 28 bytes

**Example**

**float** f;

f = \_LIBQ\_ToFloatQ15((\_Q15)0x4000); *// f now equals 0.5*

f = \_LIBQ\_ToFloatQ15((\_Q15)0x8000); *// f now equals -1.0*

f = \_LIBQ\_ToFloatQ15((\_Q15)0xb7ff); *// f now equals -0.562531*

**C**

**float** **\_LIBQ\_ToFloatQ15** (\_Q15 **x** );

**\_LIBQ\_ToFloatQ31 Function**

Converts a \_Q31 value to a float.

**Description**

Function \_LIBQ\_ToFloatQ31:

float \_LIBQ\_ToFloatQ31(\_Q31 x);

Converts a \_Q31 fixed point value to a floating point representation. The floating point value is returned by the function.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x The \_Q31 fixed point value to convert to float

**Returns**

\_LIBQ\_ToFloatQ31 returns the floating point (float) value corresponding to the \_Q31 input value.

**Remarks**

The C library functions \_\_floatsisf and \_\_divsf3 are called by this routine and thus must be linked in to the executable image.

Execution Time (cycles): 163 typical (54 to 176) Program Memory 28 bytes

**Example**

**float** f;

f = \_LIBQ\_ToFloatQ31((\_Q31)0x00004000); *// f now equals 0.000008*

f = \_LIBQ\_ToFloatQ31((\_Q31)0x80000000); *// f now equals -1.0*

f = \_LIBQ\_ToFloatQ31((\_Q31)0x5851f42d); *// f now equals 0.690001*

**C**

**float** **\_LIBQ\_ToFloatQ31** (\_Q31 **x** );

**\_LIBQ\_ToStringQ15 Function**

\_Q15 to ASCII conversion.

**Description**

Function \_LIBQ\_ToStringQ15:

void \_LIBQ\_ToStringQ15(\_Q15 x, char \*s);

Convert a \_Q15 fixed point value to an ASCII string representation in a -N.NNNNNN format.

**Preconditions**

The character string "s" must be at least 10 characters long, including the Null string terminator.

**Parameters**

**Parameters Description**

x The fixed point value to be converted into an ASCII string (\_Q15)

s A pointer to the output string of at least 10 characters

**Returns**

An ASCII string that represents the \_Q15 fixed point value in -N.NNNNNN format. The output string will be terminated by a Null

(0x00) character.

**Remarks**

Execution Time (cycles): 118 typical (28 to 132) Program Memory 200 bytes

**Example**

**char** s;

\_LIBQ\_ToStringQ15((\_Q15)0x1000, s); *// s will equal "0.125000"*

\_LIBQ\_ToStringQ15((\_Q15)0x8000, s); *// s will equal "-1.000000"*

\_LIBQ\_ToStringQ15((\_Q15)0x7FFF, s); *// s will equal "0.999969"*

**C**

**void** **\_LIBQ\_ToStringQ15** (\_Q15 **x** , **char** \* **s** );

## LibQ\_c

### LibQ Fixed-Point "C" Math Library

### Introduction

This topic describes the LibQ Fixed-Point C Math Library.

### Description

The LibQ Fixed-Point C Math Library is written in C and is available for all processors supported by Harmony 3.

The libq\_c Fixed-Point Math Library provides fixed-point math functions written in C for portability between core processors. The

library uses signed fixed point types (fractional Q types specified by Qn.m) which are specifed as follows in the library names:

Qndm where:

• n is the number of data bits to the left of the radix point

• m is the number of data bits to the right of the radix point

• a signed bit is implied (unless stated otherwise)

For convenience, short names are also defined for arbitrary scaled fractional types:

• q15 is signed fractional 16 bit value

• q31 is signed fractional 32 bit value

• i16 is signed integer, i.e. Q16d0

In addition, A pseudo floating point 32 bit format (FxQFloat32) is defined that consists of 16 mantissa and a 16 bit exponent (base

2). Functions in the library are prefixed with the type of the return value and followed by argument types (in order):

libq\_<result\>*<name\>*<args\>

For example, libq\_q1d15\_Sin\_q10d6 returns a Q1.15 value equal to the to the sine of an angle specified as a Q10.6 value (in degrees between 0 and 360).

For arbitrary scaled types (q15, q16, q31, and q32) the scaling of the result will depend on the function and the scaling of the

arguments. For instance, libq\_q15\_Add\_q15\_q15(a,b) will return a scaled value type that is the two input types (which must have

equivalent scaled value type).

**Using the Library**

**Configuring the Library using MHC**

Select the Audio/Math/Math Libraries component to load the libq\_c, libq/dsp libraries, as shown below

The project configuration should now contain the Math Libraries block.

The configuration window (when the block is selected) looks like the following:

**Remarks**

The libq\_c functions do not correspond to the libq fixed-point library optimized for the microaptive core processor and written in

asm.

### Library Overview

**Table of LIBQ\_C math functions:**

Sine: libq\_q1d15\_Sin\_q10d6 libq\_q20d12\_Sin\_q20d12 Abs: libq\_q15\_Abs\_q15 libq\_q31\_Abs\_q31

Negate: libq\_q15\_Negate\_q15 libq\_q31\_Negate\_q31 Round: libq\_q15\_RoundL\_q31

Deposit: libq\_q31\_DepositH\_q15 libq\_q31\_DepositL\_q15 Extract: libq\_q15\_ExtractH\_q31 libq\_q15\_ExtractL\_q31 Add:

libq\_q15\_Add\_q15\_q15 libq\_q31\_Add\_q31\_q31 Subtract: libq\_q15\_Sub\_q15\_q15 libq\_q31\_Sub\_q31\_q31

Shift(Scale): libq\_q15\_ShiftLeft\_q15\_q15 libq\_q31\_ShiftLeft\_q31\_q15 libq\_q15\_ShiftRight\_q15\_q15

libq\_q31\_ShiftRight\_q31\_q15 libq\_q15\_ShiftRightRound\_q15\_q15 libq\_q31\_ShiftRightRound\_q31\_q15

Multiply: libq\_q15\_Mult\_q15\_q15 libq\_q15\_MultipyR2\_q15\_q15 libq\_q31\_Multi\_q15\_q31 Divide:

libq\_q15\_DivisionWithSaturation\_q15\_q15

Multiply-Accumulate: libq\_q31\_Mac\_q31\_q15\_q15 libq\_q15\_MacR\_q31\_q15\_q15 Multiply-Subtract: libq\_q31\_Msu\_q31\_q15\_q15

libq\_q15\_MsuR\_q31\_q15\_q15 Exponential-Averaging: libq\_q15\_ExpAvg\_q15\_q15\_q1d15

Table of LIBQ\_C conversion functions: Normalize Q value: Fx16Norm Fx32Norm

Float-to-Q value: Fl2Fract16 Fl2Fract32 Fl2FxPnt16 Fl2FxPnt32 Fl2FxPnt Float-To-Integer: Fl2Int16 Fl2Int32

### Library Interface

**Functions**

**Name Description**

CosInDegs Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in

degrees (Q8.6 fixed point)

Fract\_10toX\_Q15bfp Calculates pow(2,x) with fixed point math.

Fract\_10toX\_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.

Fract\_10toX\_Q15d16 Calculates pow(2,x) with fixed point math.

Fract\_2toMinusX\_Q15 Calculates pow(2,-x) with fixed point math.

Fract\_2toX\_Q15bfp Calculates pow(2,x) with fixed point math.

Fract\_2toX\_Q15bfpFromQ15d16 Calculates pow(2,x) with fixed point math.

Fract\_2toX\_Q15d16 Calculates pow(2,x) with fixed point math.

Fract\_Convert\_Q15bfpToQ15d16 Convert Q15 block floating point to Q15.16 fixed point.

Fract\_Convert\_Q15bfpToQ31 Convert Q15 block floating point to Q31 fixed point.

Fract\_Convert\_Q15d16ToQ15bfp Convert from Q15.16 fixed point to Q15 Block Floating Point

Fract\_Convert\_Q15ToQ15bfp Convert from Q15 fixed point to Q15 Block Floating Point

Fract\_InversePower Computes pow(nBase,-nExponent).

Fract\_log10fix Calculates fixed point base 10 logarithm using number of fractional bits

specified by precision argument. Log base 10 is calculated using the log

base 2 function Fract\_log2fix.

Fract\_log2fix Calculates fixed point base 2 logarithm using number of fractional bits

specified by precision argument.

Fract\_Power Computes pow(nBase,nExponent) using for loop.

Fract\_sqrtQ15 Fixed point Q15 squareroot.

Fract\_XminusY\_Q15bfp Subtract two Q15 block floating point numbers.

Fract\_XoverY\_Q15bfp Division x/y as Q15 block floating point.

Fract\_XoverY\_Q15bfpFromQ15 Calculate ratio of X/Y as Q15s but return result as Q15 block floating

point.

Fract\_XoverY\_Q15d16FromQ15 Calculates ratio X/Y for two Q15 fixed points

Fract\_XplusY\_Q15bfp Add two Q15 block floating point numbers.

Fract\_XtimesY\_Q15 Calculates product of X\*Y for Q15 fixed point

Fract\_XtimesY\_Q15bfp Multiply X times Y, for Q15 block floating point arguments.

Fract\_XtimesY\_Q15d16 Calculates product of X\*Y for Q15.16 fixed point

Fract\_XtimesY\_Q31 Calculates product of X\*Y for Q31 fixed point

Fx16Norm Normalize the 16-bit fractional value.

Fx32Norm Normalize the 32-bit number.

libq\_q15\_Abs\_q15 Saturated Absolute value.

libq\_q15\_Add\_q15\_q15 Add two 16-bit 2s-complement fractional values.

libq\_q15\_DivisionWithSaturation\_q15\_q15 Fractional division with saturation.

libq\_q15\_ExpAvg\_q15\_q15\_q1d15 Exponential averaging

libq\_q15\_ExtractH\_q31 Extracts upper 16 bits of input 32-bit fractional value.

libq\_q15\_ExtractL\_q31 Extracts lower 16-bits of input 32-bit fractional value.

Descriptionf Extracts lower 16-bits of input 32-bit fractional value and

returns them as 16-bit fractional value. This is a bit-for-bit extraction of

the bottom 16-bits of the 32-bit input. This function relates to the ETSI

extract\_l function.

libq\_q15\_MacR\_q31\_q15\_q15 Multiply accumulate with rounding.

libq\_q15\_MsuR\_q31\_q15\_q15 Multiply-Subtraction with rounding

libq\_q15\_MultiplyR2\_q15\_q15 fractional multiplication of two 16-bit fractional values giving a 16 bit

rounded result.

libq\_q15\_Negate\_q15 Negate 16-bit 2s-complement fractional value with saturation.

libq\_q15\_RoundL\_q31 Rounds the lower 16-bits of the 32-bit fractional input.

libq\_q15\_ShiftLeft\_q15\_i16 Arithmetic Shift of the 16-bit input argument.

libq\_q15\_ShiftRight\_q15\_i16 Arithmetic RIGHT Shift on a 16-bit value.

libq\_q15\_ShiftRightR\_q15\_i16 Performs an Arithmetic RIGHT Shift on a 16-bit input.

libq\_q15\_Sub\_q15\_q15 Subtract two 16-bit 2s-complement fractional values

libq\_q1d15\_Sin\_q10d6 Approximates the sine of an angle.

libq\_q20d12\_Sin\_q20d12 3rd order Polynomial apprx. of a sine function

libq\_q31\_Abs\_q31 Saturated Absolute value.

libq\_q31\_Add\_q31\_q31 Add two 32-bit 2s-complement fractional values.

libq\_q31\_DepositH\_q15 Place 16 bits in the upper half of 32 bit word.

libq\_q31\_DepositL\_q15 Place 16 bits in the lower half of 32 bit word.

libq\_q31\_Mac\_q31\_q15\_q15 Multiply-Accumulate function WITH saturation

libq\_q31\_Msu\_q31\_q15\_q15 L\_msu(a,b,c)

libq\_q31\_Mult2\_q15\_q15 fractional multiplication of two 16-bit fractional values.

libq\_q31\_Multi\_q15\_q31 Implement 16 bit by 32 bit multiply.

libq\_q31\_Negate\_q31 Negate 32-bit 2s-complement fractional value with saturation.

libq\_q31\_ShiftLeft\_q31\_i16 Arithmetic Shift of the 32-bit value.

libq\_q31\_ShiftRight\_q31\_i16 Arithmetic RIGHT Shift on a 32-bit value.

libq\_q31\_ShiftRightR\_q31\_i16 Arithmetic RIGHT Shift on a 32-bit value

libq\_q31\_Sub\_q31\_q31 Subtract two 32-bit 2s-complement fractional values

LUTwInterpolation\_Q15 Calculates calculates y = f(x) based on a lookup table with linear

interpolation between table entries.

SinInDegs Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in

degrees (Q8.6 fixed point)

**Description**

\_ **Functions** \_

**CosInDegs Function**

fract\_q0d15\_t CosInDegs( fract\_q9d6\_t theta );

**Summary**

Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Description**

Calculates fixed point Cos(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Preconditions**

None

**Parameters**

**Parameters Description**

theta Q9.6 fixed point angle

**Returns**

cos(theta) in Q0.15 fixed point

**Remarks**

CosInDegs uses SinInDegs.

**Example**

int32\_t nTests = 400;

**float** theta;

**float** delta\_theta = 360.0/(nTests-1);

**float** theta0 = 0;

int32\_t i;

int32\_t x;

for ( i = 0; i < nTests; i++ )

\{

theta = theta0 + i\*delta\_theta;

x = theta\*(32768/512); *//Q9.6*

printf("%d, %d rn",( int )x,CosInDegs(x));

\}

**C**

fract\_q0d15\_t **CosInDegs** (fract\_q9d6\_t **theta** );

**Fract\_10toX\_Q15bfp Function**

fract\_q15bfp\_t Fract\_10toX\_Q15bfp( fract\_q15bfp\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15 block floating point, returning the result in the same format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15 block floating point format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

Fract\_10toX(x) is basically Fract\_2toX( log2(10)\*x ).

**Example**

fract\_q15bfp\_t X,Y;

X.m = 0x4000; *// 1/2*

X.e = 0;

Y = Fract\_10toX\_Q15bfp(X);

*// Y.m = 0x6532 = 25906*

*// Y.e = 2*

*// Y = ( 25906 / 32768 )<<2 = 3.162353 (vs. 3.162277) , rel error = 1/41688*

X.m = 0x6488; *// (3.14159/4)*

X.e = 2;

Y = Fract\_10toX\_Q15bfp(X);

*// Y.m = 0x5697 = 22167 / 32768 = 0.676483*

*// Y.e = 0x000B = 11*

*// Y = (22167 / 32768)<<11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023*

**C**

fract\_q15bfp\_t **Fract\_10toX\_Q15bfp** (fract\_q15bfp\_t **x** );

**Fract\_10toX\_Q15bfpFromQ15d16 Function**

fract\_q15bfp\_t Fract\_10toX\_Q15bfpFromQ15d16( fract\_q15d16\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent as Q15.16

**Returns**

pow(2,x) as Q15 block floating point

**Remarks**

Fract\_10toX(x) is basically Fract\_2toX( log2(10)\*x ).

**Example**

fract\_q15bfp\_t Y;

x = 0x00008000; *// 0.5*

Y = Fract\_10toX\_Q15bfpFromQ15d16(x);

*// Y.m = 0x6532 = 25906*

*// Y.e = 2*

*// Y = ( 25906 / 32768 )<<2 = 3.162353 (vs. 3.162277) , rel error = 1/41688*

x = 0x0003243F; *// 205,887 / 65536 = 3.141586 (vs. 3.14159)*

Y = Fract\_10toX\_Q15bfpFromQ15d16(x);

*// Y.m = 0x5696 = 22167 / 32768 = 0.676483*

*// Y.e = 0x000B = 11*

*// Y = (22167 / 32768)<<11 = 1385.4375 (vs. 1385.435475), rel error = 1/684,023*

**C**

fract\_q15bfp\_t **Fract\_10toX\_Q15bfpFromQ15d16** (fract\_q15d16\_t **x** );

**Fract\_10toX\_Q15d16 Function**

fract\_q15d16\_t Fract\_10toX\_Q15d16( fract\_q15d16\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with x as Q15.16, returning result as Q15.16.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent as Q15.16

**Returns**

pow(2,x) as Q15.16

**Remarks**

Fract\_10toX(x) is basically Fract\_2toX( log2(10)\*x ).

**Example**

fract\_q15d16\_t x,y;

x = 0x00008000; *// 0.5*

y = Fract\_10toX\_Q15d16(x);

*// y = 0x0003 2990 = 207,248/65536 = 3.162353 (vs. 3.162277) , rel error = 1/41688*

x = 0x0003243F; *// 205,887 / 65536 = 3.141586 (vs. 3.14159)*

y = Fract\_10toX\_Q15d16(x);

*// y = 0x0569 6000 = 90,791,936/65536 = 1385.375 (vs. 1385.435475) , rel error = 1/22909*

**C**

fract\_q15d16\_t **Fract\_10toX\_Q15d16** (fract\_q15d16\_t **x** );

**Fract\_2toMinusX\_Q15 Function**

fract\_q15\_t Fract\_2toMinusX\_Q15( fract\_q15\_t x );

**Summary**

Calculates pow(2,-x) with fixed point math.

**Description**

Calculates pow(2,-x) with fixed point math, using three term Taylor Series and 256 entry lookup table.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Exponent in calculating 2^-x. If x < 0 then -x is used.

**Returns**

Value of pow(2,-x)

**Remarks**

If 0 <= x < 1, then pow(2,-x) is in the range 0.5 < pow(2,-x) <= 1.

**Example**

fract\_q15\_t x,y;

x = 3277; *// 0.1*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.1) = 0.933033 = 30574 / 32768*

*// y = 0x776D = 30573*

x = 6554; *// 0.2*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.2) = 0.870551 = 28526 / 32768*

*// y = 0x6F6E = 28526*

x = 9830; *// 0.3*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.3) = 0.812252 = 26616 / 32768*

*// y = 0x67F9 = 26617*

x = 13107; *// 0.4*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.4) = 0.757858 = 24834 / 32768*

*// y = 0x6102 = 24834*

x = 16384; *// 0.5*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.5) = 0.707107 = 23170 / 32768*

*// y = 0x5A81 = 23169*

x = 3277 + 16384; *// 0.1 + 0.5 = 0.6*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,0.6) = 0.659754 = 21619 / 32768*

*// y = 0x5472 = 21618*

x = 6554 + 16384; *// 0.2 + 0.5 = 0.7*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.7) = 0.615572 = 20171 / 32768*

*// y = 0x4ECA = 20170*

x = 9830 + 16384; *// 0.3 + 0.5 = 0.8*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.8) = 0.574349 = 18820 / 32768*

*// y = 0x4984 = 18820*

x = 13107 + 16384; *// 0.4 + 0.5 = 0.9*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-0.9) = 0.535887 = 17560 / 32768*

*// y = 0x4498 = 17560*

x = 32767; *// 0.5 + 0.5 = 1.0*

y = Fract\_2toMinusX\_Q15(x);

*// pow(2,-1.0) = 0.5 = 16384 / 32768*

*// y = 0x4001 = 16385*

**C**

fract\_q15\_t **Fract\_2toMinusX\_Q15** (fract\_q15\_t **x** );

**Fract\_2toX\_Q15bfp Function**

fract\_q15bfp\_t Fract\_2toX\_Q15bfp( fract\_q15bfp\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, from Q15 block floating point x, returning Q15 block floating point result.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x exponent, in Q15 block floating point format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

None.

**Example**

fract\_q15bfp\_t x, y;

x.m = 16384; *// 0.5*

x.e = 0;

y = Fract\_2toX\_Q15bfp(x);

*// pow(2,0.5) = sqrt(2) = 46341/32768;*

*// y.m = 0x5A85 = 23173*

*// y.e = 1*

*// y = (23173/32768)<<1 = 1.414368 (vs. 1.414214)*

x.m = 24576; *// 0.75*

x.e = 0;

y = Fract\_2toX\_Q15bfp(x);

*// pow(2,0.75) = 1.681793 = 55109/32768;*

*// y.m = 0x6BA4 = 27556*

*// y.e = 1*

*// y = (27556/32768)<<1 = 1.681885 (vs. 1.681793)*

**C**

fract\_q15bfp\_t **Fract\_2toX\_Q15bfp** (fract\_q15bfp\_t **x** );

**Fract\_2toX\_Q15bfpFromQ15d16 Function**

fract\_q15bfp\_t Fract\_2toX\_Q15bfpFromQ15d16( fract\_q15d16\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, based on input in Q15.16 format, returning result in Q15 block floating point format.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15.16 format

**Returns**

pow(2,x), in Q15 block floating point format

**Remarks**

None.

**Example**

fract\_q15d16\_t x;

fract\_q15bfp\_t Y;

x = 0x00008000; *// 0.5 in Q15.16*

Y = Fract\_2toX\_Q15bfpFromQ15d16(x);

*// pow(2,0.5) = sqrt(2) = 1.414213 = 46341 / 32768 = 0x5A82<<1*

*// Y.m = 0x5A85 = 23173*

*// Y.e = 1*

*// Y = ( 23173 / 32768 )<<1 = 1.414367 (vs. 1.414213)*

x = 0x00014000; *// 1.25 in Q15.16*

Y = Fract\_2toX\_Q15bfpFromQ15d16(x);

*// pow(2,1.25) = 2.378414 = 77936 / 32768 = 0x4C1C<<2*

*// Y.m = 0x4C1 = 19484*

*// Y.e = 2*

*// Y = ( 19484/32768 ) << 2 = 2.378418 (vs. 2.378414)*

**C**

fract\_q15bfp\_t **Fract\_2toX\_Q15bfpFromQ15d16** (fract\_q15d16\_t **x** );

**Fract\_2toX\_Q15d16 Function**

fract\_q15d16\_t Fract\_2toX\_Q15d16( fract\_q15d16\_t x )

**Summary**

Calculates pow(2,x) with fixed point math.

**Description**

Calculates pow(2,x) using fixed point math, with Q15.16 x, returning Q15.16 result

**Preconditions**

None.

**Parameters**

**Parameters Description**

x exponent, in Q15.16 format

**Returns**

pow(2,x), in Q15.16 format

**Remarks**

None.

**Example**

fract\_q15d16\_t x,y;

x = 0x00008000; *// 0.5 in Q15.16*

y = Fract\_2toX\_Q15d16(x);

*// pow(2,0.5) = sqrt(2) = 1.414213 = 92682/65536 = 0x0001 6A0A*

*// y = 0x0001 6A14 = 92692/65536 = 1.414367 (vs. 1.414213)*

x = 0x00014000; *// 1.25 in Q15.16*

y = Fract\_2toX\_Q15d16(x);

*// pow(2,1.25) = 2.378414 = 155,872 / 65536 = 0x0002 60E0*

*// y = 0x0002 60E0*

**C**

fract\_q15d16\_t **Fract\_2toX\_Q15d16** (fract\_q15d16\_t **x** );

**Fract\_Convert\_Q15bfpToQ15d16 Function**

fract\_q15d16\_t Fract\_Convert\_Q15bfpToQ15d16( fract\_q15bfp\_t x )

**Summary**

Convert Q15 block floating point to Q15.16 fixed point.

**Description**

Convert Q15 block floating point to Q15.16 fixed point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 Block Floating Point

**Returns**

Input converted to Q15.16 fixed point.

**Remarks**

No effort is made to trap overflows of underflows,

**Example**

fract\_q15d16\_t x\_Q15d16;

fract\_q15bfp\_t x\_Q15bfp;

x\_Q15bfp.m = 0x4000; *// 1/2*

x\_Q15bfp.e = -1; *// 1/2\>\>1 = 1/4*

x\_Q15d16 = Fract\_Convert\_Q15bfpToQ15d16( x\_Q15bfp );

*// x\_Q15d16 = 0x0000 4000*

**C**

fract\_q15d16\_t **Fract\_Convert\_Q15bfpToQ15d16** (fract\_q15bfp\_t **x** );

**Fract\_Convert\_Q15bfpToQ31 Function**

fract\_q31\_t Fract\_Convert\_Q15bfpToQ31( fract\_q15bfp\_t x )

**Summary**

Convert Q15 block floating point to Q31 fixed point.

**Description**

Convert Q15 block floating point to Q31 fixed point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 Block Floating Point

**Returns**

Input converted to Q31 fixed point.

**Remarks**

No effort is made to trap overflows of underflows,

**Example**

**C**

fract\_q31\_t **Fract\_Convert\_Q15bfpToQ31** (fract\_q15bfp\_t **x** );

**Fract\_Convert\_Q15d16ToQ15bfp Function**

fract\_q15bfp\_t Fract\_Convert\_Q15d16ToQ15bfp( fract\_q15d16\_t x )

**Summary**

Convert from Q15.16 fixed point to Q15 Block Floating Point

**Description**

Convert from Q15.16 fixed point to Q15 Block Floating Point

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15.16 fixed point

**Returns**

Input convertd to Q15 Block Floating Point.

**Remarks**

Mantissa and exponent are adjusted to remove redundant leading bits.

**Example**

fract\_q15d16\_t x\_Q15d16;

fract\_q15bfp\_t x\_Q15bfp;

x\_Q15d16 = 0xFFFFC000; *//-1/4*

x\_Q15bfp = Fract\_Convert\_Q15d16ToQ15bfp(x\_Q15d16);

*//x\_Q15bfp.m = 0xC000 // -1/2*

*//x\_Q15bfp.e = 0xFFFF = -1; // -1/2\>\>1 = -1/4*

**C**

fract\_q15bfp\_t **Fract\_Convert\_Q15d16ToQ15bfp** (fract\_q15d16\_t **x** );

**Fract\_Convert\_Q15ToQ15bfp Function**

fract\_q15bfp\_t Fract\_Convert\_Q15ToQ15bfp( fract\_q15\_t x )

**Summary**

Convert from Q15 fixed point to Q15 Block Floating Point

**Description**

Convert from Q15 fixed point to Q15 Block Floating Point

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 (aka Q1.15) fixed point

**Returns**

Input convertd to Q15 Block Floating Point.

**Remarks**

Mantissa and exponent are adjusted to remove redundant leading bits.

**Example**

fract\_q15\_t x\_Q15;

fract\_q15bfp\_t x\_Q15bfp;

x\_Q15 = 0xE000; *//-1/4*

x\_Q15bfp = Fract\_Convert\_Q15d16ToQ15bfp(x\_Q15d16);

*//x\_Q15bfp.m = 0xC000 // -1/2*

*//x\_Q15bfp.e = 0xFFFF = -1; // -1/2\>\>1 = -1/4*

**C**

fract\_q15bfp\_t **Fract\_Convert\_Q15ToQ15bfp** (fract\_q15\_t **x** );

**Fract\_InversePower Function**

fract\_q15bfp\_t Fract\_InversePower( uint16\_t nBase, uint16\_t nExponent )

**Summary**

Computes pow(nBase,-nExponent).

**Description**

Computes pow(nBase,-nExponent).

**Preconditions**

None

**Returns**

pow(nBase,-nExponent), as a Q15bfp block floating point number.

**Remarks**

pow(nBase,nExponent) must fit inside a uint32\_t variable.

**Example**

uint16\_t nBase, nExponent;

fract\_q15bfp\_t Answer;

nBase = 5;

nExponent = 3;

Answer = Fract\_InversePower(nBase,nExponent);

*// Answer = pow(5,-3) = 1/125*

*// Answer.m = 0x4189 = 16777*

*// Answer.e = 0xFFFA = -6*

*// Answer = (16777/32768)\>\>6 = 1/(125.001609)*

**C**

fract\_q15bfp\_t **Fract\_InversePower** (uint16\_t **nBase** , uint16\_t **nExponent** );

**Fract\_log10fix Function**

int32\_t Fract\_log10fix (int32\_t x, size\_t precision)

Calculates fixed point base 10 logarithm using number of fractional bits

specified by precision argument.

**Description**

Calculates fixed point base 10 logarithm using number of fractional bits specified by precision argument. Log base 10 is calculated using the log base 2 function Fract\_log2fix.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Fixed point input, if x == 0, function returns INT32\_MIN to represent negative

infinity. If x is input as a negative number it will be cast to be a unsigned 32 bit integer.

precision number of fractional bits in input and output, 1<= precision <= 31. if precision < 1 or precision \> 31 function returns INT32\_MAX.

**Returns**

Logarithm base 10 of input, in same Q format as input.

**Remarks**

If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.

This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16\_t integer.

**Example**

See the code example under Fract\_log2fix.

**C**

int32\_t **Fract\_log10fix** (int32\_t **x** , size\_t **precision** );

**Fract\_log2fix Function**

int32\_t Fract\_log2fix (int32\_t X32, size\_t precision)

**Summary**

Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument.

**Description**

Calculates fixed point base 2 logarithm using number of fractional bits specified by precision argument. This implementation is based on Clay. S. Turners fast binary logarithm algorithm.

**Preconditions**

None.

**Parameters**

**Parameters Description**

X32 Fixed point input, if x == 0, function returns INT32\_MIN to represent negative

infinity. If x < 0 function returns INT32\_MAX as error.

precision number of fractional bits in input and output, 1<= precision <= 31. if precision < 1 or

precision \> 31 function returns INT32\_MAX as error.

**Returns**

Logarithm base 2 of input, in same Q format as input. The Q format used is based on the value of precision. For example, if

precision == 16 then the Q format used is Q15.16.

**Remarks**

If precision = N, then the input and output are Q(31-N).N . For example, if precision = 16 then the input and output are Q15.16.

This means that there are 16 fractional bits (the LS word) and the upper 16 bits (MS word) represents an int16\_t integer.

References:  C. S. Turner, "A Fast Binary Logarithm Algorithm", IEEE Signal Processing Mag., pp. 124,140, Sep. 2010.

**Example**

*// Make log output Q15.16*

**\#define** PRECISION 16

**\#define** STRING\_MAX\_SIZE 133

**char** ioString;

**double** Xdouble;

**double** scale = 1U << PRECISION;

**float** Xfloat;

int16\_t X16;

int32\_t X32;

while ( Xdouble != -1.0 )

\{

sprintf(ioString,"rnX: ");

SendDataBuffer(ioString, strlen(ioString) );

GetDataBuffer(ioString,STRING\_MAX\_SIZE);

sscanf(ioString,"%f",&Xfloat);

Xdouble = Xfloat;

**if** ( Xdouble == -1 )

\{

sprintf(ioString,"rnWere done!rn");

SendDataBuffer(ioString, strlen(ioString) );

**return** 0;

\}

**else if** ( Xdouble < 0 )

\{

sprintf(ioString,"%f is Negative!rn",Xdouble);

SendDataBuffer(ioString, strlen(ioString) );

**continue** ;

\}

**else if** ( Xdouble \>= 1 << (32 - PRECISION) )

\{

sprintf(ioString, "%f is too bigrn", Xdouble);

SendDataBuffer(ioString, strlen(ioString) );

**continue** ;

\}

sprintf(ioString," log10(%f) = %frn", Xdouble, ( **double** )log10(Xdouble));

SendDataBuffer(ioString, strlen(ioString) );

X32 = Fract\_log10fix(Xdouble \* scale, PRECISION);

sprintf(ioString,"Fract\_log10fix(%f) = %f (0x%08X)rn", Xdouble, X32/scale, X32);

SendDataBuffer(ioString, strlen(ioString) );

X32 = Fract\_log2fix(Xdouble \* scale, PRECISION) ;

sprintf(ioString," Fract\_log2fix(%f) = %f (0x%08X)rn", Xdouble, X32/scale, X32 );

SendDataBuffer(ioString, strlen(ioString) );

\}*//end while ( Xdouble != -1.0 )*

**C**

int32\_t **Fract\_log2fix** (int32\_t **X32** , size\_t **precision** );

**Fract\_Power Function**

uint32\_t Fract\_Power( uint16\_t nBase, uint16\_t nExponent )

**Summary**

Computes pow(nBase,nExponent) using for loop.

**Description**

Computes pow(nBase,nExponent) using for loop.

**Preconditions**

None

**Returns**

pow(nBase,nExponent), this must fit into a 32 bit unsigned integer.

**Remarks**

none

**Example**

uint16\_t nBase, nExponent;

uint32\_t answer;

nBase = 5;

nExponent = 3;

answer = Fract\_Power(nBase,nExponent);

*// Answer = pow(5,3) = 125 = 0x007D*

**C**

uint32\_t **Fract\_Power** (uint16\_t **nBase** , uint16\_t **nExponent** );

**Fract\_sqrtQ15 Function**

fract\_q15\_t Fract\_sqrtQ15(fract\_q15\_t X)

**Summary**

Fixed point Q15 squareroot.

**Description**

Returns square root of Q15 (Q0.15) fraction. Since -1 <= X < 1, we know that the 0<= SquareRoot(\|\|X\|\|) < 1.

**Preconditions**

None.

**Parameters**

**Parameters Description**

X Q15 input, should be non-negative.

**Returns**

Square root of abs(X).

**Remarks**

Given integer X, solve for Y such that

Y Y X

---- \* ---- = ----

2^15 2^15 2^15

This is equivalent to

Y \* Y = X \* 2^15 = X<<15

So as integers:

Y = integer sqrt(X<<15)

thus

fixed\_point\_sqrt(X) = integer\_sqrt(X<<15)

For X = 0,1,...32767, define

ErrSqrt = (sqrt(X/32768.0) - FixedPointSQRT(X))/sqrt(X/32768.0)

This error ranges from 0 to 0.015259, with an average error of 0.0054096

The fast integer square root function used is based on

http://stackoverflow.com/questions/1100090/looking-for-an-efficient-integer-square-root-algorithm-for-arm-thumb2

**Example**

**C**

fract\_q15\_t **Fract\_sqrtQ15** (fract\_q15\_t **X** );

**Fract\_XminusY\_Q15bfp Function**

fract\_q15bfp\_t Fract\_XminusY\_Q15bfp( fract\_q15bfp\_t x, fract\_q15bfp\_t y )

**Summary**

Subtract two Q15 block floating point numbers.

**Description**

Subtract two Q15 block floating point numbers.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x Q15 block floating point term

y Q15 block floating point term

**Returns**

x-y as Q15 block floating point

**Remarks**

None.

**Example**

fract\_q15d16\_t x, y;

fract\_q15bfp\_t X, Y, XminusY;

x = 0x00030000; *// 3*

y = 0x00070000; *// 7*

X = Fract\_Convert\_Q15d16ToQ15bfp(x);

Y = Fract\_Convert\_Q15d16ToQ15bfp(y);

XminusY = Fract\_XminusY\_Q15bfp( X, Y );

*// XplusY.m = 0xC000 = -16384/32768 = -0.5*

*// XPlusY.e = 3*

*// XPlusY = -0.5<<3 = -4*

**C**

fract\_q15bfp\_t **Fract\_XminusY\_Q15bfp** (fract\_q15bfp\_t **x** , fract\_q15bfp\_t **y** );

**Fract\_XoverY\_Q15bfp Function**

fract\_q15bfp\_t Fract\_XoverY\_Q15bfp(fract\_q15bfp\_t x, fract\_q15bfp\_t y )

**Summary**

Division x/y as Q15 block floating point.

**Description**

Division x/y as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Numerator as Q15 block floating point

y Denominator as Q15 block floating point

**Returns**

Ratio x/y as Q15 block floating point.

**Remarks**

None.

**Example**

fract\_q15\_t x,y;

fract\_q15bfp\_t X, Y, XoverY;

x = 0x1234; *// 4660/32768 = 0.142219*

y = 0x5678; *// 22136/32768 = 0.675537*

X = Fract\_Convert\_Q15d16ToQ15bfp((fract\_q15d16\_t)x);

Y = Fract\_Convert\_Q15d16ToQ15bfp((fract\_q15d16\_t)y);

XoverY = Fract\_XoverY\_Q15bfp(X,Y);

*// x/y = 4660/22136 = 6898/32768 = 0.210516*

*// XoverY.m = 0x6BC8 = 27592*

*// XoverY.e = 0xFFFE = -2*

*// XoverY = (27592/32768)\>\>2 = 0.210510*

**C**

fract\_q15bfp\_t **Fract\_XoverY\_Q15bfp** (fract\_q15bfp\_t **x** , fract\_q15bfp\_t **y** );

**Fract\_XoverY\_Q15bfpFromQ15 Function**

fract\_q15bfp\_t Fract\_XoverY\_Q15bfpFromQ15(fract\_q15\_t x, fract\_q15\_t y )

**Summary**

Calculate ratio of X/Y as Q15s but return result as Q15 block floating point.

**Description**

Calculate ratio of X/Y as Q15s but return result as Q15 block floating point.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 numerator

y Q15 denominator

**Returns**

Ratio x/y as Q15 block floating point

**Remarks**

None.

**Example**

fract\_q15\_t x,y;

fract\_q15bfp\_t XoverY;

x = 0x1234; *// 4660/32768 = 0.142219*

y = 0x5678; *// 22136/32768 = 0.675537*

XoverY = Fract\_XoverY\_Q15bfpFromQ15(x,y);

*// x/y = 4660/22136 = 6898/32768 = 0.210516*

*// XoverY.m = 0x6BC8 = 27592*

*// XoverY.e = 0xFFFE = -2*

*// XoverY = (27592/32768)\>\>2 = 0.210510*

**C**

fract\_q15bfp\_t **Fract\_XoverY\_Q15bfpFromQ15** (fract\_q15\_t **x** , fract\_q15\_t **y** );

**Fract\_XoverY\_Q15d16FromQ15 Function**

fract\_q15d16\_t Fract\_XoverY\_Q15d16FromQ15( fract\_q15\_t x, fract\_q15\_t y );

**Summary**

Calculates ratio X/Y for two Q15 fixed points

**Description**

Calculates ratio X/Y for two Q15 fixed points

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 numerator

y Q15 denominator

**Returns**

Ratio x/y as Q15.16 fixed point

**Remarks**

Since ratio x/y can be bigger than unity, result must be Q15.16.

**Example**

fract\_q15\_t x,y;

fract\_q15d16\_t xovery;

x = 0xDEAD; *// -8531/32768 = -0.260345*

y = 0xBEEF; *// -16657/32768 = -0.508331*

xovery = Fract\_XoverY\_Q15d16FromQ15(x,y);

*// x/y = -8531/-16657 = 33564/65536 = 0.512157*

*// xovery = 0x0000 831C = 33564*

**C**

fract\_q15d16\_t **Fract\_XoverY\_Q15d16FromQ15** (fract\_q15\_t **x** , fract\_q15\_t **y** );

**Fract\_XplusY\_Q15bfp Function**

fract\_q15bfp\_t Fract\_XplusY\_Q15bfp( fract\_q15bfp\_t x, fract\_q15bfp\_t y )

**Summary**

Add two Q15 block floating point numbers.

**Description**

Add two Q15 block floating point numbers.

**Preconditions**

none.

**Parameters**

**Parameters Description**

x Q15 block floating point term

y Q15 block floating point term

**Returns**

x+y as Q15 block floating point

**Remarks**

None.

**Example**

fract\_q15d16\_t x, y;

fract\_q15bfp\_t X, Y, XplusY;

x = 0x00030000; *// 3*

y = 0x00070000; *// 7*

X = Fract\_Convert\_Q15d16ToQ15bfp(x);

Y = Fract\_Convert\_Q15d16ToQ15bfp(y);

XplusY = Fract\_XplusY\_Q15bfp( X, Y );

*// XplusY.m = 0x5000 = 20480/32768 = 0.625*

*// XPlusY.e = 4*

*// XPlusY = 0.625<<4 = 10*

**C**

fract\_q15bfp\_t **Fract\_XplusY\_Q15bfp** (fract\_q15bfp\_t **x** , fract\_q15bfp\_t **y** );

**Fract\_XtimesY\_Q15 Function**

fract\_q15\_t Fract\_XtimesY\_Q15(fract\_q15\_t x, fract\_q15\_t y );

**Summary**

Calculates product of X\*Y for Q15 fixed point

**Description**

Calculates product of X\*Y for Q15 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q15 multiplicand

y Q15 multiplicand

**Returns**

Q15 product x\*y

**Remarks**

Since both x and y are Q15 fixed point numbers the product x\*y is also Q15.

**Example**

fract\_q15\_t x, y, xtimesy;

x = 0x1234; *// 4660/32768 = 0.142219*

y = 0x5678; *// 22136/32768 = 0.675537*

xtimesy = Fract\_XtimesY\_Q15(x,y);

*// x\*y = 0.142219 \* 0.675537 = 0.096069*

*// xtimesy = 0x0C4C = 3148/32768 = 0.096069*

**C**

fract\_q15\_t **Fract\_XtimesY\_Q15** (fract\_q15\_t **x** , fract\_q15\_t **y** );

**Fract\_XtimesY\_Q15bfp Function**

fract\_q15bfp\_t Fract\_XtimesY\_Q15bfp(fract\_q15bfp\_t x, fract\_q15bfp\_t y )

**Summary**

Multiply X times Y, for Q15 block floating point arguments.

**Description**

Multiply X times Y, for Q15 block floating point arguments.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 block floating point multiplicand

y Q15 block floating point multiplicand

**Returns**

Product x\*y as Q15 block floating point

**Remarks**

None.

**Example**

fract\_q15bfp\_t X,Y,XtimesY;

X.m = 0x1234;

X.e = 0; *// 4660/32768 = 0.142219*

Y.m = 0x5678;

Y.e = 0; *// 22136/32768 = 0.675537*

XtimesY = Fract\_XtimesY\_Q15bfp(X,Y);

*// XtimesY.m = 0x6260 = 25184/32768 = 0.768554*

*// XtimesY.e = 0xFFFD = -3*

*// XtimesY = 0.768554\>\>3 = 0.096069*

*// X\*Y = 0.142219 \* 0.675537 = 0.096069*

**C**

fract\_q15bfp\_t **Fract\_XtimesY\_Q15bfp** (fract\_q15bfp\_t **x** , fract\_q15bfp\_t **y** );

**Fract\_XtimesY\_Q15d16 Function**

fract\_q15d16\_t Fract\_XtimesY\_Q15d16(fract\_q15d16\_t x, fract\_q15d16\_t y );

**Summary**

Calculates product of X\*Y for Q15.16 fixed point

**Description**

Calculates product of X\*Y for Q15.16 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q15.16 multiplicand

y Q15.16 multiplicand

**Returns**

Q15.16 product x\*y

**Remarks**

Since both x and y are Q15.16 fixed point numbers the product x\*y is also Q15.16.

**C**

fract\_q15d16\_t **Fract\_XtimesY\_Q15d16** (fract\_q15d16\_t **x** , fract\_q15d16\_t **y** );

**Fract\_XtimesY\_Q31 Function**

fract\_q31\_t Fract\_XtimesY\_Q31(fract\_q31\_t x, fract\_q31\_t y );

**Summary**

Calculates product of X\*Y for Q31 fixed point

**Description**

Calculates product of X\*Y for Q31 fixed point

**Preconditions**

None

**Parameters**

**Parameters Description**

x Q31 multiplicand

y Q31 multiplicand

**Returns**

Q31 product x\*y

**Remarks**

Since both x and y are Q31 fixed point numbers the product x\*y is also Q31.

**C**

fract\_q31\_t **Fract\_XtimesY\_Q31** (fract\_q31\_t **x** , fract\_q31\_t **y** );

**Fx16Norm Function**

Normalize the 16-bit fractional value.

**Description**

Function Fx16Norm:

Produces then number of left shifts needed to Normalize the 16-bit fully fractional input. If the input a is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of  to a maximum of . If the input a is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of  to a maximum of . This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left shift function should be used with the value returned From this function.

the 16-bit input on range: 0 =\> result < 16 (i.e. NUMBITSFRACT16) If a\>0: 0x4000 \> Normalized Value <= 0x7fff i.e. (MAXFRACT16+1)/2 \> aNorm <= MAXFRACT16 If a<0: 0x8000 \>= Normalilzed Value < 0xC000 i.e. MINFRACT16\>= aNorm <

MINFRACT16/2

This function relates to the ETSI norm\_s function.

**Parameters**

**Parameters Description**

q15 a in Q1.15

**Returns**

i16 result - The number of left shifts required to normalize

**C**

int16\_t **Fx16Norm** (q15);

**Fx32Norm Function**

Normalize the 32-bit number.

**Description**

Function Fx32Norm:

Produces then number of left shifts needed to Normalize the 32-bit fractional input. If the input a is a positive number, it will produce the number of left shifts required to normalized it to the range of a minimum of  to a maximum of . If the input a is a negative number, it will produce the number of left shifts required to normalized it to the range of a minimum of  to a maximum of . This function does not actually normalize the input, it just produces the number of left shifts required. To actually normalize the value the left-shift function should be used with the value returned From this function.

32-bit input on range: 0 =\> result < 32 (i.e. NUMBITSFRACT32) If a\>0: 0x40000000 \> Normalized Value <= 0x7fffffff i.e.

(MAXFRACT32+1)/2 \> aNorm <= MAXFRACT32 If a<0: 0x80000000 \>= Normalized Value < 0xC0000000 i.e. MINFRACT32\>=

aNorm < MINFRACT32/2

This function relates to the ETSI norm\_l function.

**Parameters**

**Parameters Description**

q31 a 32-bit Q1.d31 to be normalized

**Returns**

int16\_t result - The number of left shifts required to normalize the

**C**

int16\_t **Fx32Norm** (q31);

**libq\_q15\_Abs\_q15 Function**

Saturated Absolute value.

**Description**

Function libq\_q15\_Abs\_q15:

Creates a saturated Absolute value. It takes the absolute value of the 16-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT16 is greater than MAXFRACT16, or the allowable range of 16-bit values. This function relates to the ETSI abs function.

**Parameters**

**Parameters Description**

q15 a input argument

**Returns**

q15 result - abs(input) <= MAXFRACT16

**C**

q15 **libq\_q15\_Abs\_q15** (q15);

**libq\_q15\_Add\_q15\_q15 Function**

Add two 16-bit 2s-complement fractional values.

**Description**

Function libq\_q15\_Add\_q15\_q15: f

Add two 16-bit 2s-complement fractional (op1 + op2) to produce a 16-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output.

**Returns**

q15 - a+b on Range: MINFRACT16 <= result <= MAXFRACT16

**C**

q15 **libq\_q15\_Add\_q15\_q15** (q15, q15);

**libq\_q15\_DivisionWithSaturation\_q15\_q15 Function**

Fractional division with saturation.

**Description**

Function libq\_q15\_DivisionWithSaturation\_q15\_q15():

Performs fractional division with saturation. There are three restrictions that the calling code must satisfy.

1.  Both the numerator and denominator must be positive.

2.  In order to obtain a non-saturated result, the numerator must be LESS than or equal to the denominator.

3.  The denominator must not equal zero.


If num equals den, then the result equals MAXINT16.

This function relates to the ETSI div\_s function.

**Parameters**

**Parameters Description**

q15 num 16-bit fractional numerator

q15 den 16-bit fractional denumerator

**Returns**

q15 result - ratio a/b in 16-bit fractional format

**C**

q15 **libq\_q15\_DivisionWithSaturation\_q15\_q15** (q15, q15);

**libq\_q15\_ExpAvg\_q15\_q15\_q1d15 Function**

Exponential averaging

**Description**

Function libq\_q15\_ExpAvg\_q15\_q15\_q1d15()

Exponential averaging implements a smoothing function based on the form: avg = avg \* lamda + new \* (1-lamda) In this implementation, is has been optimized as follows. avg = (avg - new) \* lamda + new

The optimization precludes accurate processing of new numbers that differ from the current average by more than unity. If the difference is greater than unity or less than negative unity, the difference is saturated.

The effect is akin to a smaller lambda, e.g., the new value will have a greater weight than expected. If the smoothing is of data that is entirely positive or entirely negative, then the saturation will not be an issue.

**Parameters**

**Parameters Description**

q15 S(k) Previous exponential average

q15 X(k) New value to be averaged in

q15 L exponential averaging constant in Q1.15

**Returns**

q15 result - S(k+1) = S(k)*L + X(k)*(1-L)

**C**

q15 **libq\_q15\_ExpAvg\_q15\_q15\_q1d15** (q15 **prevAvgQ15** , q15 **newMeasQ15** , q15 **lamdaQ1d15** );

**libq\_q15\_ExtractH\_q31 Function**

Extracts upper 16 bits of input 32-bit fractional value.

**Description**

Function libq\_q15\_ExtractH\_q31:

Extracts upper 16 bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the top 16-bits of the 32-bit input. This function relates to the ETSI extract\_h function.

**Returns**

q15 result - Upper 16 bits of 32-bit argument a

**C**

q15 **libq\_q15\_ExtractH\_q31** (q31);

**libq\_q15\_ExtractL\_q31 Function**

Extracts lower 16-bits of input 32-bit fractional value.

Descriptionf Extracts lower 16-bits of input 32-bit fractional value and returns them as 16-bit fractional value. This is a bit-for-bit extraction of the bottom 16-bits of the 32-bit input. This function relates to the ETSI extract\_l function.

**Description**

Function libq\_q15\_ExtractL\_q31:

**Returns**

q15 - Lower 16 bits of 32-bit argument a

**C**

q15 **libq\_q15\_ExtractL\_q31** (q31);

**libq\_q15\_MacR\_q31\_q15\_q15 Function**

Multiply accumulate with rounding.

**Description**

Function libq\_q15\_MacR\_q31\_q15\_q15:

This function is multiply-accumulate WITH Rounding applied to the accumulator result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a 0 in the Lsb. The shifted multiplier output is then added to the 32-bit fractional input a. Then the 32-bits of the accumulator output are rounded by adding 2^15. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output. This function is for fractional Qtype format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI L\_mac\_r function.

**Parameters**

**Parameters Description**

q31 a 32-bit accumulator operand

q15 b 16-bit multiplication operand

q15 c 16-bit multiplication operand

**Returns**

q15 result - a+b\*c rounded

**C**

q15 **libq\_q15\_MacR\_q31\_q15\_q15** (q31, q15, q15);

**libq\_q15\_MsuR\_q31\_q15\_q15 Function**

Multiply-Subtraction with rounding

**Description**

Function libq\_q15\_MsuR\_q31\_q15\_q15:

This function is like Multiply-Subtract but WITH Rounding applied to the subtractor result before it is saturated and the top 16-bits taken. This function first multiplies the two 16-bit input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fractional-type multiply. So, the shifted number now has a 0 in the Lsb. The shifted multiplier output is then SUBTRACTED From the 32-bit fractional input a. Then the 32-bits output From this subtraction are rounded by adding 2^15. This value is then saturated to be within the q15 range. It is assumed that the binary point of the 32-bit input value a is in the same bit position as the shifted multiplier output.

This function is for fractional Q-type format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI msu\_r function.

**Parameters**

**Parameters Description**

q31 a Value which is subtracted from

q15 b multiplication operand 1

q15 c multiplication operand 2

**Returns**

q15 result - a-b\*c rounded to Q1.15

**C**

q15 **libq\_q15\_MsuR\_q31\_q15\_q15** (q31, q15, q15);

**libq\_q15\_MultiplyR2\_q15\_q15 Function**

fractional multiplication of two 16-bit fractional values giving a 16 bit rounded result.

**Description**

Function libq\_q15\_MultiplyR2\_q15\_q15:

Performs fractional multiplication of two 16-bit fractional values and returns a ROUNDED 16-bit fractional result. The function performs a Q15xQ15-\>Q30 bit multiply with a left shift by 1 to give a Q31 result. This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any 32-bit result that overflows. Rounding is applied to the 32-bit SHIFTED result by adding in a weight factor of 2^15, again any overflows are saturated. The TOP 16-bits are extracted and returned. This function is for fractional Qtype data only and it therefore will not give the correct results for true integers (because left shift by 1). This function assumes that the binary point in the 32-bit shifted multiplier output is between bit\_16 and bit\_15 when the rounding factor is added. For the special case where both inputs equal the MINFACT16, the function returns a value equal to MAXFACT16, i.e. 0x7fff = libq\_q15\_Mult2\_q15\_q15(0x8000,0x8000). This function internally calls the libq\_q15\_mult\_q15\_q31() routine to perform the actual multiplication and the rounding routine to perform the actual rounding.

This function relates to the ETSI mult\_r function.

**Parameters**

**Parameters Description**

q15 a value in Q1.15

q15 b value in Q1.15

**Returns**

q15 result - a\*b rounded 16-bit signed integer (Q1.15) output value

**C**

q15 **libq\_q15\_MultiplyR2\_q15\_q15** (q15, q15);

**libq\_q15\_Negate\_q15 Function**

Negate 16-bit 2s-complement fractional value with saturation.

**Description**

Function libq\_q15\_Negate\_q15:

Negate 16-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT16 is greater than MAXFRACT16, or the allowable range of values. This function relates to the ETSI negate function.

**Returns**

q15 result on range: MINFRACT16 <= result <= MAXFRACT16

**C**

q15 **libq\_q15\_Negate\_q15** (q15);

**libq\_q15\_RoundL\_q31 Function**

Rounds the lower 16-bits of the 32-bit fractional input.

**Description**

Function libq\_q15\_RoundL\_q31:

Rounds the lower 16-bits of the 32-bit fractional input into a 16-bit fractional value with saturation. This converts the 32-bit fractional value to 16-bit fractional value with rounding. This function calls the Add function to perform the 32-bit rounding of the input value and ExtractH function to extract to top 16-bits. This has the effect of rounding positive fractional values up and more positive, and has the effect of rounding negative fractional values up and more positive. This function relates to the ETSI round function.

**Returns**

q15 result

**C**

q15 **libq\_q15\_RoundL\_q31** (q31);

**libq\_q15\_ShiftLeft\_q15\_i16 Function**

Arithmetic Shift of the 16-bit input argument.

**Description**

Function libq\_q15\_ShiftLeft\_q15\_i16:

Performs an Arithmetic Shift of the 16-bit input argument a left by the input argument b bit positions. If b is a positive number, a 16-bit left shift is performed with zeros inserted to the right of the shifted bits. If b is a negative number, a right shift by abs(b) positions with sign extention Saturation is applied if shifting causes an overflow or an underflow.

positive value: \# of bits to left shift (zeros inserted at LSBs) \{To not always saturate: if a=0, then max b=15, else max b=14\}

negative value: \# of bits to right shift (sign extend)

This function relates to the ETSI shl function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed integer value to be shifted.

i16 b 16-bit signed integer shift value

**Returns**

q15 result - arithmetically shifted 16-bit signed integer output

**C**

q15 **libq\_q15\_ShiftLeft\_q15\_i16** (q15, i16);

**libq\_q15\_ShiftRight\_q15\_i16 Function**

Arithmetic RIGHT Shift on a 16-bit value.

**Description**

Function libq\_q15\_ShiftRight\_q15\_q15:

Performs an Arithmetic RIGHT Shift on a 16-bit input by b bit positions. For positive shift directions (b\>0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b<0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 16-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.

positive value: \# of bits to right shift (sign extend) \{ To get all sign bits, b\>=15 \} negative value: \# of bits to left shift (zeros inserted

at LSBs)

This function relates to the ETSI shr function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed input value to shift

i16 b 16-bit signed integer shift index

**Returns**

q15 result - 16-bit signed shifted output

**C**

q15 **libq\_q15\_ShiftRight\_q15\_i16** (q15, i16);

**libq\_q15\_ShiftRightR\_q15\_i16 Function**

Performs an Arithmetic RIGHT Shift on a 16-bit input.

**Description**

Function libq\_q15\_ShiftRightR\_q15\_q15:

Performs an Arithmetic RIGHT Shift on a 16-bit input by b bits with Rounding applied. The rounding occurs by adding a bit weight of "1/2 Lsb", where the "Lsb" is the Ending (shifted) Lsb. For example: The initial Bit\#(b) is after the right shift Bit\#(0), so the rounding bit weight is Bit\#(b-1). Rounding does not occur on either left shifts or on no shift needed cases. For positive shift directions (b\>0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b<0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 16-bit left shift. This function does not provide any status-type information to indicate when overflows occur.

positive value: \# of bits to right shift (sign extend) \{b \> 15, results in all sign bits\} negative value: \# of bits to left shift (zeros

inserted at LSBs)

This function relates to the ETSI shr\_r function.

**Parameters**

**Parameters Description**

q15 a 16-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q15 result - Arithmetically shifted 16-bit signed integer output

**C**

q15 **libq\_q15\_ShiftRightR\_q15\_i16** (q15, i16);

**libq\_q15\_Sub\_q15\_q15 Function**

Subtract two 16-bit 2s-complement fractional values

**Description**

Function libq\_q15\_Sub\_q15\_q15:

Subtract two 16-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX16 when an overflow occurs and the result is set to MIN16 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.

**Returns**

q15 result a+b on range: MINFRACT16 <= result <= MAXFRACT16

**C**

q15 **libq\_q15\_Sub\_q15\_q15** (q15, q15);

**libq\_q1d15\_Sin\_q10d6 Function**

Approximates the sine of an angle.

**Description**

Function libq\_q1d15\_Sin\_q10d6:

This function approximates the sine of an angle using the following algorithm: sin(x) = 3.140625x + 0.02026367x^2 - 5.325196x^3

-   0.5446778x^4 + 1.800293x^5. The approximation is accurate for any value of x from 0 degrees to 90 degrees. Because sin(-x) =


-   sin(x) and sin(x) = sin(180 - x), the sine of any angle can be inferred from an angle in the first quadrant. Therefore, any angle \>


90 is converted to an angle between 0 & 90. The coefficients of the algorithm have been scaled by 1/8 to fit a Q1d15 format. So the result is scaled up by 8 to obtain the proper magnitudes. The algorithm expects the angle to be in degrees and represented in Q10.6 format. The computed sine value is returned in Q1.15 format.

**Preconditions**

none.

**Parameters**

**Parameters Description**

q15 angle The angle in degrees for which the sine is computed in Q10.6

**Returns**

q15 sine(angle) value in Q1.15

**C**

q15 **libq\_q1d15\_Sin\_q10d6** (q15 **angleQ10d6** );

**libq\_q20d12\_Sin\_q20d12 Function**

3rd order Polynomial apprx. of a sine function

**Description**

Function libq\_q20d12\_Sin\_q20d12:

3rd order Polynomial apprx. of a sine function

**Preconditions**

none.

**Parameters**

**Parameters Description**

q31 angle The angle in radians for which the sine is computed in Q20.12

**Returns**

q31 Sine(angle) value in Q20.12

**C**

q31 **libq\_q20d12\_Sin\_q20d12** (q31 **angQ20d12** );

**libq\_q31\_Abs\_q31 Function**

Saturated Absolute value.

**Description**

Function libq\_q31\_Abs\_q31:

Creates a saturated Absolute value. It takes the absolute value of the 32-bit 2s-complement fractional input with saturation. The saturation is for handling the case where taking the absolute value of MINFRACT32 is greater than MAXFRACT32, or the allowable range of 32-bit values.

This function relates to the ETSI L\_abs function.

**Returns**

q31 result - abs(a) <= MAXFRACT32

**C**

q31 **libq\_q31\_Abs\_q31** (q31);

**libq\_q31\_Add\_q31\_q31 Function**

Add two 32-bit 2s-complement fractional values.

**Description**

Function libq\_q31\_Add\_q31\_q31:

Add two 32-bit 2s-complement fractional (op1 + op2) to produce a 32-bit 2s-complement fractional result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 32-bit inputs and the resulting 32-bit

output. This function relates to the ETSI L\_add function.

**Returns**

q31 result a+b on range: MINFRACT32 <= result <= MAXFRACT32

**C**

q31 **libq\_q31\_Add\_q31\_q31** (q31, q31);

**libq\_q31\_DepositH\_q15 Function**

Place 16 bits in the upper half of 32 bit word.

**Description**

Function libq\_q31\_DepositH\_q15:

Composes a 32-bit fractional value by placing the input 16-bit fractional value in the composite MSBs and zeros the composite 16-bit LSBs This is a bit-for-bit placement of input 16-bits into the upper part of 32-bit result.

This function relates to the ETSI L\_deposit\_H function.

**Returns**

q31 result 16-bits of a in upper MSBs and zeros in the lower LSBs

**C**

q31 **libq\_q31\_DepositH\_q15** (q15);

**libq\_q31\_DepositL\_q15 Function**

Place 16 bits in the lower half of 32 bit word.

**Description**

Function libq\_q31\_DepositL\_q15:

Composes a 32-bit fractional value by placing the 16-bit Fraction input value into the lower 16-bits of the 32-bit composite value.

The 16-bit MSBs of the composite output are sign extended. This is a bit-for-bit placement of input 16-bits into the bottom portion of the composite 32-bit result with sign extention. This function relates to the ETSI L\_deposit\_l function.

**Returns**

q31 result - SignExtended 16-bit MSBs and a Value in lower 16-bit LSBs

**C**

q31 **libq\_q31\_DepositL\_q15** (q15);

**libq\_q31\_Mac\_q31\_q15\_q15 Function**

Multiply-Accumulate function WITH saturation

**Description**

Function libq\_q31\_Mac\_q31\_q15\_q15():

Performs a Multiply-Accumulate function WITH saturation. This routine returns the fully fractional 32-bit result From the accumulator output SAT(addOut\_Q1d31)=outQ1d15 where multOut\_Q1d31 + a\_Q1d31 = addOut\_Q1d31, and b\_Q1d15 x c\_Q1d15 = multOut\_Q1d31. The multiply is performed on the two 16-bit fully fully fractional input values b x c which results in a 32-bit value. This result is left shifted by one to account for the extra sign bit inherent in the fully fully fractional-type multiply. The shifted number represents a Q1d31 number with the lsb set to 0. This Q1d31 number is added with the 32-bit fully fully fractional input argument a. Saturation is applied on the output of the accumulator to keep the value within the 32-bit fully fractional range and then this value is returned. This function is for fully fractional Q-type format data only and it therefore will not give the correct results for true integers.

This function relates to the ETSI L\_mac function.

**Parameters**

**Parameters Description**

q31 a 32-bit accumulator operand 1 in Q1d31

q15 b 16-bit multiplication operand 1 in Q1d15

q15 c 16-bit multiplication operand 2 in Q1d15

**Returns**

q31 result, a+b\*c saturated

**C**

q31 **libq\_q31\_Mac\_q31\_q15\_q15** (q31, q15, q15);

**libq\_q31\_Msu\_q31\_q15\_q15 Function**

L\_msu(a,b,c)

**C**

q31 **libq\_q31\_Msu\_q31\_q15\_q15** (q31, q15, q15);

**libq\_q31\_Mult2\_q15\_q15 Function**

fractional multiplication of two 16-bit fractional values.

**Description**

Function libq\_q31\_Mult2\_q15\_q15:

Performs fractional multiplication of two 16-bit fractional values and returns the 32-bit fractional scaled result. The function performs the Q15xQ15-\>Q30 fractional bit multiply. It then shifts the result left by 1, to give a Q31 type result, (the lsb is zero-filled). This automatic shift left is done to get rid of the extra sign bit that occurs in the interpretation of the fractional multiply result. Saturation is applied to any results that overflow, and then the function returns the 32-bit fractional q31 result. This function is for fractional Q data only and it therefore will not give correct results for true integers (because left shift by 1). For the special case where both inputs equal the MINFRACT16, the function returns a value equal to MAXFACT32, i.e. 0x7fffffff = libq\_q15\_mult\_q15\_q31(0x8000,0x8000).

This function relates to the ETSI L\_mult function.

**Parameters**

**Parameters Description**

q15 a multiplicand a

q15 b multiplicand b

**Returns**

q31, a\*b

**C**

q31 **libq\_q31\_Mult2\_q15\_q15** (q15, q15);

**libq\_q31\_Multi\_q15\_q31 Function**

Implement 16 bit by 32 bit multiply.

**Description**

Function libq\_q31\_Multi\_q15\_q31():

Implement 16 bit by 32 bit multiply as shown below The s and u notation shows the processing of signed and unsigned numbers.

-B1- -B0- s u 2nd argument is 32 bits -A0- s 1st argument is 16 bits

**------------**

A0B0 A0B0 s=s*u 1st 32-bit product is A0*B0 A0B1 A0B1 s=s*s 2nd 32-bit product is A0*B1

**------------**

-S2- -S1- -S0- s=s+s 48-bit result is the sum of products -P1- -P0- 32-bit return is the most significant bits of sum

The algorithm is implemented entirely with the fractional arithmetic library. The unsigned by signed multiply is implemented by shifting bits 15:1 to bits 14:0 of a 16-bit positive fractional number, which throws away bit 0 of the 32-bit number. Since that affects result bits that are used for rounding, rounding processing is included. Saturation processing is handled implicitly in the fractional arithmetic library, except for the case of maximum negative numbers.

**Returns**

q31 result - a\*b rounded

**C**

q31 **libq\_q31\_Multi\_q15\_q31** (q15 **argAQ1d15** , q31 **argBQ1d31** );

**libq\_q31\_Negate\_q31 Function**

Negate 32-bit 2s-complement fractional value with saturation.

**Description**

Function libq\_q31\_Negate\_q31:

Negate 32-bit 2s-complement fractional value with saturation. The saturation is for handling the case where negating a MINFRACT32 is greater than MAXFRACT32, or the allowable range of values. This function relates to the ETSI L\_negate function.

**Returns**

q31 result on range: MINFRACT32 <= result <= MAXFRACT32

**C**

q31 **libq\_q31\_Negate\_q31** (q31);

**libq\_q31\_ShiftLeft\_q31\_i16 Function**

Arithmetic Shift of the 32-bit value.

**Description**

Function libq\_q31\_ShiftLeft\_q31\_i16:

Performs an Arithmetic Shift of the 32-bit input argument a left by the input argument b bit positions. If b is a positive number, a 32-bit left shift is performed with zeros inserted to the right of the shifted bits. If b is a negative number, a 32-bit right shift by b bit positions with sign extention:

positive value: \# of bits to left shift (zeros inserted at LSBs) negative value: \# of bits to right shift (sign extend)

Saturation is applied if shifting causes an overflow or an underflow.

This function relates to the ETSI L\_shl function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 16-bit signed integer shift index

**Returns**

q31 result - arithmetically shifted 32-bit signed integer output

**C**

q31 **libq\_q31\_ShiftLeft\_q31\_i16** (q31, i16);

**libq\_q31\_ShiftRight\_q31\_i16 Function**

Arithmetic RIGHT Shift on a 32-bit value.

**Description**

Function libq\_q31\_ShiftRight\_q31\_q15:

Performs an Arithmetic RIGHT Shift on a 32-bit input by b bit positions. For positive shift directions (b\>0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b<0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform any 32-bit left shifts. This function does not provide any status-type information to indicate when overflows occur.

positive value: \# of bits to right shift (sign extend) negative value: \# of bits to left shift (zeros inserted at LSBs)

This function relates to the ETSI L\_shr function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q31 result - Arithmetically shifted 32-bit signed integer output

**C**

q31 **libq\_q31\_ShiftRight\_q31\_i16** (q31, i16);

**libq\_q31\_ShiftRightR\_q31\_i16 Function**

Arithmetic RIGHT Shift on a 32-bit value

**Description**

Function libq\_q31\_ShiftRightR\_q31\_q15:

Performs an Arithmetic RIGHT Shift on a 32-bit input by b bits with Rounding applied. The rounding occurs before any shift by adding a bit weight of "1/2 Lsb", where the "Lsb" is the Ending (shifted) Lsb. For example: The initial Bit\#(i+b) is after the right shift Bit\#(i), so the rounding bit weight is Bit\#(i+b-1). Rounding does not occur on left shifts, when b is negative. After rounding, this function calls the right-shift function to perform the actual 32-bit right shift. For positive shift directions (b\>0), b Lsb-bits are shifted out to the right and b sign-extended Msb-bits fill in From the left. For negative shift directions (b<0), b Lsbs are shifted to the LEFT with 0s filling in the empty lsb position. The left shifting causes b Msb-bits to fall off to the left, saturation is applied to any shift left value that overflows. This function calls the left-shift function to perform the actual 32-bit left shift. This function does not provide any status-type flag to indicate occurence of overflow.

positive value: \# of bits to right shift (sign extend) negative value: \# of bits to left shift (zeros inserted at LSBs)

This function relates to the ETSI L\_shr\_r function.

**Parameters**

**Parameters Description**

q31 a 32-bit signed integer value to be shifted

i16 b 16-bit signed integer shift index

**Returns**

q31 result - Arithmetically shifted 32-bit signed integer output

**C**

q31 **libq\_q31\_ShiftRightR\_q31\_i16** (q31, i16);

**libq\_q31\_Sub\_q31\_q31 Function**

Subtract two 32-bit 2s-complement fractional values

**Description**

Function libq\_q31\_Sub\_q31\_q31:

Subtract two 32-bit 2s-complement fractional (op1 - op2) to produce a 16-bit 2s-complement fractional difference result with saturation. The saturation is for handling the overflow/underflow cases, where the result is set to MAX32 when an overflow occurs and the result is set to MIN32 when an underflow occurs. This function does not produce any status flag to indicate when an overflow or underflow has occured. It is assumed that the binary point is in exactly the same bit position for both 16-bit inputs and the resulting 16-bit output. This function relates to the ETSI sub function.

**Returns**

q31 result a-b on range: MINFRACT31 <= result <= MAXFRACT31

**C**

q31 **libq\_q31\_Sub\_q31\_q31** (q31, q31);

**LUTwInterpolation\_Q15 Function**

fract\_q15\_t LUTwInterpolation\_Q15( fract\_q15\_t x,

const fract\_q15\_t \* pX\_LUT\_Vector,

const fract\_q15\_t \* pY\_LUT\_Vector,

const uint16\_t nLUTSize );

**Summary**

Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.

**Description**

Calculates calculates y = f(x) based on a lookup table with linear interpolation between table entries.

**Preconditions**

None.

**Parameters**

**Parameters Description**

x Q15 value, independent variable

pX\_LUT\_Vector X column of LUT in Q15

pY\_LUT\_Vector Y column of LUT in Q15

nLutSize number of rows (entries) in the LUT

**Returns**

y = f(x) based on the LUT using linear interpolation between table entries.

**Remarks**

It is assumed that X LUT vector is in strictly monotonically increasing order. That is: pX\_LUT\_Vector < pX\_LUT\_Vector for i = 0,1,...nLUTSize-2

Internal math is done in signed 32 integers and truncated to Q15.

If x <= pX\_LUT\_Vector then pY\_LUT\_Vector is returned.

if pX\_LUT\_Vector <= x then pY\_LUT\_Vector is returned.

WARNING: It is strongly recommended that you test out the LUT and compare actual vs. desired values in Matlab/Octave or Excel! You may need to add additional rows where the interpolation does not produce the needed accuracy.

**C**

fract\_q15\_t **LUTwInterpolation\_Q15** (fract\_q15\_t **x** , **const** fract\_q15\_t \* **pX\_LUT\_Vector** , **const**

fract\_q15\_t \* **pY\_LUT\_Vector** , **const** uint16\_t **nLUTSize** );

**SinInDegs Function**

fract\_q0d15\_t SinInDegs( fract\_q9d6\_t theta );

**Summary**

Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Description**

Calculates fixed point Sin(theta) (Q0.15 fixed point), where theta is in degrees (Q8.6 fixed point)

**Preconditions**

None

**Parameters**

**Parameters Description**

theta Q9.6 fixed point angle

**Returns**

sin(theta) in Q0.15 fixed point

**Remarks**

None.

**Example**

int32\_t nTests = 400;

**float** theta;

**float** delta\_theta = 360.0/(nTests-1);

**float** theta0 = 0;

int32\_t i;

int32\_t x;

for ( i = 0; i < nTests; i++ )

\{

theta = theta0 + i\*delta\_theta;

x = theta\*(32768/512); *//Q9.6*

printf("%d, %d rn",( int )x,SinInDegs(x)));

\}

**C**

fract\_q0d15\_t **SinInDegs** (fract\_q9d6\_t **theta** );

